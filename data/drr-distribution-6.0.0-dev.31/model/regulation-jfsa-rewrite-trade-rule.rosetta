namespace drr.regulation.jfsa.rewrite.trade
version "6.0.0-dev.31"

import cdm.base.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.qualification.*
import cdm.event.workflow.*
import cdm.product.collateral.*
import cdm.product.qualification.*

import drr.regulation.common.*
import drr.regulation.jfsa.*
import drr.standards.iosco.cde.* as cde
import drr.standards.iso.*

corpus Dissemination Trade

report JFSA Trade in T+1
  	from TransactionReportInstruction
  	when ReportableProduct
  	with type JFSATransactionReport

eligibility rule ReportableProduct from TransactionReportInstruction:
    [regulatoryReference JFSA Trade
        provision "Demonstrative eligibility rule for display"]
    True

reporting rule EffectiveDate from TransactionReportInstruction: <"Effective Date">
    [regulatoryReference JFSA Trade dataElement "1" field "Effective Date"
        provision "Unadjusted date at which obligations under the OTC derivative transaction come into effect, as included in the confirmation."]
    [regulatoryReference JFSA Trade dataElement "1" field "Effective Date - Remark"
        provision "If the effective date is not stated in the confirmation, report the Execution date. If the Execution date is not stated, report the Trade Date. Otherwise, the definition used by the internal management of each financial institution is permitted."]
    filter IsAllowableActionForJFSA
    then cde.datetime.EffectiveDate
        as "1 Effective Date"

reporting rule ExpirationDate from TransactionReportInstruction: <"Expiration date">
    [regulatoryReference JFSA Trade dataElement "2" field "Expiration date"
        provision "Unadjusted date at which obligations under the OTC derivative transaction stop being effective, as included in the confirmation. Early termination does not affect this data element."]
    [regulatoryReference JFSA Trade dataElement "2" field "Expiration date - Remark"
        provision "If a contract is early terminated, the date of when the early termination occurred is to be entered in the Early termination date column, and the expiration date determined at the time of the original execution shall continue to be entered in the Expiration date column."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract cde.datetime.ExpirationDate
        as "2 Expiration date"

reporting rule EarlyTerminationDate from TransactionReportInstruction: <"Early termination date">
    [regulatoryReference JFSA Trade dataElement "3" field "Early termination date"
        provision "Effective date of the early termination (expiry) of the reported transaction. This data element is applicable if the termination of the transaction occurs prior to its maturity due to an ex-interim decision of a counterparty (or counterparties).
        Examples of early terminations (expiry) are: negotiated early termination; early termination under an optional early termination provision (mutual put); novation; offsetting (netting) transaction; option exercise; compression; early termination clause specified in the original contract which is a callable swap (bought embedded option); mutual credit break."]
    [regulatoryReference JFSA Trade dataElement "3" field "Early termination date - Remark"
        provision "Early termination includes the exercise of options (including Swaption). This applies to cases where options are exercisable at any time during the term, such as American-type options. In such cases, enter the effective date when the rights are exercised. Offsetting (netting) transactions have the same effect as early termination, however reporting is not required unless the position held by the financial institution is offsetted and cleared out."]
    filter IsActionTypeCORR or IsActionTypeREVI or IsActionTypeTERM
    then extract cde.datetime.EarlyTerminationDate
        as "3 Early termination date"

reporting rule ReportingTimestamp from TransactionReportInstruction: <"Reporting timestamp">
    [regulatoryReference JFSA Trade dataElement "4" field "Reporting timestamp"
        provision "Date and time of the submission of the report to the trade repository"]
    [regulatoryReference JFSA Trade dataElement "4" field "Reporting timestamp - Remark"
        provision "System input time, data generation time, and system connection time are to be considered as acceptable values. In addition, if determining the time up to the seconds is impossible due to system restrictions, setting the seconds to 00 shall be acceptable. If it can be determined that the reporting date and time are the same as the trade date, then Trade Date, may be used as a substitute value. (If different, substitution will not be permitted.)"]
    cde.datetime.ReportingTimestamp
        as "4 Reporting timestamp"

reporting rule ExecutionTimestamp from TransactionReportInstruction: <"Execution timestamp">
    [regulatoryReference JFSA Trade dataElement "5" field "Execution timestamp"
        provision "Date and time a transaction was originally executed, resulting in the generation of a new UTI. This data element remains unchanged throughout the life of the UTI."]
    [regulatoryReference JFSA Trade dataElement "5" field "Execution timestamp - Remark"
        provision "System input time, data generation time, and system connection time are to be considered as acceptable values. In addition, if determining the time up to the seconds is impossible due to system restrictions, setting the seconds to '00' shall be acceptable. If it can be determined that the reporting date and time are the same as the trade date, then Trade Date, may be used as a substitute value. (If different, substitution will not be permitted.)"]
    filter IsAllowableActionForJFSA
    then cde.datetime.ExecutionTimestamp
        as "5 Execution timestamp"

reporting rule EntityResponsibleForReporting from TransactionReportInstruction: <"Entity responsible for reporting">
    [regulatoryReference JFSA Trade dataElement "6" field "Entity responsible for reporting"
        provision "The identifier of the financial institution that is the reporting obligation."]
    [regulatoryReference JFSA Trade dataElement "6" field "Entity responsible for reporting - Remark"
        provision "Reporting party of the trades will be determined based on the identifier reported for 'Entity responsible for reporting' and by 'Submitter identifier'. Examples of who the reporting party is:
        [Case 1] Where a party to a transaction is other than a fund (normal case):
        'Entity responsible for reporting' = Financial institution with reporting obligation and involved in the transaction as Counterparty 1
        'Counterparty 1 (reporting counterparty)' = Same as above
        'Submitter identifier' = Same as above
        [Case 2] Where a trading party is a fund:
        'Entity responsible for reporting' = Trust Bank LEI
        'Counterparty 1 (reporting counterparty)' = Fund LEI
        'Submitter identifier' = Trust bank LEI 
        [Case 3] Reporting party is an agent, etc. (where a regional bank requests the Trust Bank, etc. to report):
        'Entity responsible for reporting' = Financial institution with reporting obligation and involved in the transaction as Counterparty 1
        'Counterparty 1 (reporting counterparty)' = Same as above
        'Submitter identifier' = LEI of the agent acting as the service provider for reporting"]
    extract ExtractPartyResponsibleForReportingIdentifier(reportingSide)
        as "6 Entity responsible for reporting"

reporting rule Counterparty1 from TransactionReportInstruction: <"Counterparty 1 (reporting counterparty)">
    [regulatoryReference JFSA Trade dataElement "7" field "Counterparty 1 (reporting counterparty)"
        provision "Identifier of the counterparty to an OTC derivative transaction who is fulfilling its reporting obligation via the report in question. In jurisdictions where both parties must report the transaction, the identifier of Counterparty 1 always identifies the reporting counterparty. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund and not the fund manager is reported as the counterparty."]
    [regulatoryReference JFSA Trade dataElement "7" field "Counterparty 1 (reporting counterparty) - Remark"
        provision "Reporting using branch/international branch LEI is not allowed."]
    extract cde.party.Counterparty1
        as "7 Counterparty 1"

reporting rule Counterparty2 from TransactionReportInstruction: <"Counterparty 2">
    [regulatoryReference JFSA Trade dataElement "8" field "Counterparty 2"
        provision "Identifier of the second counterparty to an OTC derivative transaction. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund, and not the fund manager is reported as the counterparty."]
    [regulatoryReference JFSA Trade dataElement "8" field "Counterparty 2 - Remark"
        provision "If LEI cannot be obtained, a tentative LEI is permitted. Tentative LEI must have a unique alphanumeric string to ensure the party can be uniquely identified.
        Examples for assigning tentative LEI: [In the case of financial institutions] Tentative LEI = Party LEI + Counterparty BIC Code
        [In the case of corporations and individuals] Tentative LEI = Trading Party LEI + Unique Alphanumeric Code (Control number assigned by the financial institution, etc.)
        If a fund LEI is yet to be obtained, the Trust Bank must share a tentative LEI for the fund (Trust Bank LEI + Unique Alphanumeric Code) with its counterparty financial institution.
        Enter the LEI of the clearing organization if the company transacts with a clearing organization prescribed in JFSA Notification No.105.
        Reporting using branch/international branch LEI is not allowed."]
    extract cde.party.Counterparty2
        as "8 Counterparty 2"

reporting rule Counterparty2IdentifierType from TransactionReportInstruction: <"Counterparty 2 identifier type">
    [regulatoryReference JFSA Trade dataElement "9" field "Counterparty 2 identifier type"
        provision "Indicator of whether LEI was used to identify the Counterparty 2."]
    [regulatoryReference JFSA Trade dataElement "9" field "Counterparty 2 identifier type - Remark"
        provision "Under the CDE Guidance, legal entity is to be reported as True and individual as False. However, for cases where a tentative LEI is used to report for a legal entity, it should be reported as False."]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."]
    extract cde.party.Counterparty2IdentifierType
        as "9 Counterparty 2 identifier type"

reporting rule Direction1 from TransactionReportInstruction: <"Direction 1 (Buyer/Seller)">
    [regulatoryReference JFSA Trade dataElement "10" field "Direction 1 (Buyer/Seller)"
        provision "Indicator of whether the counterparty 1 is the buyer or the seller as determined at the time of the transaction. A non-exhaustive list of examples of instruments for which this data element could apply are: most forwards and forward-like contracts (except for foreign exchange forwards and foreign exchange non-deliverable forwards); most options and option-like contracts including swaptions, caps and floors; credit default swaps (buyer/seller of protection); variance, volatility and correlation swaps; contracts for difference and spreadbets. This data element is not applicable to instrument types covered by data elements Direction 2."]
    filter IsAllowableActionForJFSA
    then extract cde.party.Direction1
        as "10 Direction 1"

reporting rule Direction2Leg1 from TransactionReportInstruction: <"Direction 2 (Payer/Receiver)-Leg 1">
    [regulatoryReference JFSA Trade dataElement "11" field "Direction 2 (Payer/Receiver)"
        provision "Indicator of whether the reporting counterparty is the payer or the receiver of the Leg 1 as determined at the time of the transaction. A non-exhaustive list of examples of instruments for which this data element could apply are: most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps); foreign exchange swaps, forwards, non-deliverable forwards. This data element is not applicable to instrument types covered by data elements Direction 1."]
    filter IsAllowableActionForJFSA
    then extract
        cde.party.Direction2(
                item,
                TradeForEvent
                    extract trade [
                        trade -> tradableProduct -> product
                            extract
                                if IsCommoditySwapFloatFloat
                                then CommodityLeg1 -> payerReceiver
                                else if IsCommoditySwapFixedFloat
                                then FixedPriceLeg1 -> payerReceiver
                                else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                                then contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver
                                else if IsFXForward
                                then FXLeg1 -> payerReceiver
                                else if Qualify_InterestRate_Option_Swaption(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_InterestRate_CapFloor(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_AssetClass_Credit(
                                                contractualProduct -> economicTerms
                                            ) = False
                                then InterestRateLeg1 -> payerReceiver
                    ]
            )
        as "11 Direction 2-Leg 1"

reporting rule Direction2Leg2 from TransactionReportInstruction: <"Direction 2 (Payer/Receiver)-Leg 2">
    [regulatoryReference JFSA Trade dataElement "11" field "Direction 2 (Payer/Receiver)"
        provision "Indicator of whether the reporting counterparty is the payer or the receiver of the Leg 2 as determined at the time of the transaction. A non-exhaustive list of examples of instruments for which this data element could apply are: most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps); foreign exchange swaps, forwards, non-deliverable forwards. This data element is not applicable to instrument types covered by data elements Direction 1."]
    filter IsAllowableActionForJFSA
    then extract
        cde.party.Direction2(
                item,
                TradeForEvent -> tradableProduct -> product
                    then extract
                        if IsCommoditySwap
                        then CommodityLeg2 -> payerReceiver
                        else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                        then (if InterestRateLeg2 exists
                            then InterestRateLeg2 -> payerReceiver
                            else if contractualProduct -> economicTerms -> payout -> fixedPricePayout exists
                            then contractualProduct -> economicTerms -> payout -> fixedPricePayout -> payerReceiver
                                distinct
                                only-element)
                        else if IsFXForward
                        then FXLeg2 -> payerReceiver
                        else if Qualify_InterestRate_Option_Swaption(
                                        contractualProduct -> economicTerms
                                    ) = False
                                and Qualify_InterestRate_CapFloor(
                                        contractualProduct -> economicTerms
                                    ) = False
                                and Qualify_AssetClass_Credit(
                                        contractualProduct -> economicTerms
                                    ) = False
                        then InterestRateLeg2 -> payerReceiver
            )
        as "11 Direction 2-Leg 2"

reporting rule SubmitterIdentifier from TransactionReportInstruction: <"Submitter identifier">
    [regulatoryReference JFSA Trade dataElement "12" field "Submitter identifier"
        provision "Identifier of the entity submitting the data to the swap data repository (SDR). The Submitter identifier will be the same as the reporting counterparty, unless they use a third-party service provider to submit the data to SDR in which case, report the identifier of the third-party service provider."]
    [regulatoryReference JFSA Trade dataElement "12" field "Submitter identifier - Remark"
        provision "See 'Entity responsible for reporting'. Applicable for central counterparty and financial institutions. If reporting is conducted using a platform, then the platform is deemed to be the submitter."]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Check whether trade is executed in a SEF first. If it is, SEF is obliged to be the Submitter. Then check for Reporting Party and Data Submitter."]
    extract ExtractReportSubmittingPartyIdentifier(reportingSide)
        as "12 Submitter identifier"

reporting rule NewSDRIdentifier from TransactionReportInstruction: <"New SDR Identifier">
    [regulatoryReference JFSA Trade dataElement "13" field "New SDR Identifier"
        provision "Identifier of the new swap data repository where the swap transaction is transferred to."]
    [regulatoryReference JFSA Trade dataElement "13" field "New SDR Identifier - Remark"
        provision "If unapplicable, leave it blank."]
    filter IsAllowableActionForJFSA or IsActionTypeVALU
    then extract
        if IsCleared(originatingWorkflowStep) = True
        then ExtractPartyFromRelatedPartyByRole(
                    reportableInformation -> partyInformation -> relatedParty,
                    PartyRoleEnum -> TradeRepository
                )
    then extract PartyLei(partyId)
        as "13 New SDR identifier"

reporting rule OriginalSwapSDRIdentifier from TransactionReportInstruction: <"Original Swap SDR Identifier">
    [regulatoryReference JFSA Trade dataElement "14" field "Original Swap SDR Identifier"
        provision "Identifier of the swap data repository (SDR) to which the original swap was reported."]
    [regulatoryReference JFSA Trade dataElement "14" field "Original Swap SDR Identifier - Remark"
        provision "Applicable for central counterparty and financial institutions."]
    filter IsAllowableActionForJFSA
    then extract
        if IsCleared(originatingWorkflowStep) = True and cde.event.EventType = CLRG
        then ExtractPartyFromRelatedPartyByRole(
                    reportableInformation -> partyInformation -> relatedParty,
                    PartyRoleEnum -> PriorTradeRepository
                )
        else if IntendedToClear(originatingWorkflowStep) = True and IsActionTypeTERM = True
        then ExtractPartyFromRelatedPartyByRole(
                    reportableInformation -> partyInformation -> relatedParty,
                    PartyRoleEnum -> TradeRepository
                )
    then extract PartyLei(partyId)
        as "14 Original swap SDR identifier"

reporting rule Cleared from TransactionReportInstruction: <"Cleared">
    [regulatoryReference JFSA Trade dataElement "15" field "Cleared"
        provision "Indicator of whether the transaction has been cleared, or is intended to be cleared, by a central counterparty."]
    [regulatoryReference JFSA Trade dataElement "15" field "Cleared - Remark"
        provision "'N' will be acceptable if 'I' cannot be distinguished due to system limitation. If N or I, it is to be reported by the financial institution. If Yes, it is to be reported by the central counterparty. However, if the financial institution conducts a transaction with a clearing organization prescribed in Financial Services Agency Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction. Examples of reporting transactions with the central counterparty prescribed in JFSA Notification No. 105 are as follows : (Example : The following items are mandatory) 15 Cleared Y 16 LEI of central counterparty 17 LEI of the clearing member 22 Clearing account origin 23 Orginal swap UTI for alpha transaction"]
    filter IsAllowableActionForJFSA
    then cde.settlement.Cleared
        as "15 Cleared"

reporting rule CentralCounterparty from TransactionReportInstruction: <"Central counterparty">
    [regulatoryReference JFSA Trade dataElement "16" field "Central counterparty"
        provision "Identifier of the central counterparty that cleared the transaction. This data element is not applicable if the value of the data element Cleared is N (No, not centrally cleared) or I (Intent to clear)."]
    [regulatoryReference JFSA Trade dataElement "16" field "Central counterparty - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction."]
    filter IsAllowableActionForJFSA
    then cde.settlement.CentralCounterparty
        as "16 Central counterparty"

reporting rule ClearingMember from TransactionReportInstruction: <"Clearing member">
    [regulatoryReference JFSA Trade dataElement "17" field "Clearing member"
        provision "Identifier of the clearing member through which a derivative transaction was cleared at a CCP. This data element is applicable to cleared transactions."]
    [regulatoryReference JFSA Trade dataElement "17" field "Clearing member - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction. (If clearing is concentrated through a clearing broker, report the identifiers of the clearing brokers.)"]
    filter IsAllowableActionForJFSA
    then cde.settlement.ClearingMember
        as "17 Clearing member"

reporting rule PlatformIdentifier from TransactionReportInstruction: <"Platform Identifier">
    [regulatoryReference JFSA Trade dataElement "18" field "Platform Identifier"
        provision "Identifier of the trading facility (e.g., multilateral trading facility, swap execution facility) on which the transaction was executed."]
    [regulatoryReference JFSA Trade dataElement "18" field "Platform Identifier - Remark"
        provision "In Japan, an electronic trading platform operator is applicable as a swap execution facility. This may also be applicable for reporting when facilities in the United States and Europe are used. The CDE and CFTC Technical Specifications definitions include, but are not limited to, MTFs and SEFs. Referencing to the examples used in the definition, Japanese electronic trading platform operators will need to be included for reporting."]
    filter IsAllowableActionForJFSA
    then cde.settlement.PlatformIdentifier
        as "18 Platform Identifier"

reporting rule Confirmed from TransactionReportInstruction: <"Confirmed">
    [regulatoryReference JFSA Trade dataElement "19" field "Confirmed"
        provision "For new reportable transactions (as defined by the CPMI-IOSCO Technical Guidance: Harmonisation of the Unique Transaction Identifier), whether the legally binding terms of an OTC derivatives contract were documented and agreed upon (confirmed) or not (unconfirmed). If documented and agreed, whether such confirmation was done:
            Via a shared confirmation facility or platform, or a private/bilateral electronic system (electronic);
            Via a human-readable written document, such as fax, paper or manually processed e-mails (non-electronic)."]
    [regulatoryReference JFSA Trade dataElement "19" field "Confirmed - Remark"
        provision "In cases where it is difficult to ascertain the status of the agreement through paper confirmation, it is acceptable to report as non-electronic (YCNF) with agreement (DONE), However, this will be limited to cases where the status can be promptly confirmed post agreement. In cases where it is already known in advance that it will take some time before an agreement can be reached, it is expected to be reported as unconfirmed (NCNF) and then changed to non-electronic (YCNF) post agreement. Reporting of Confirmation Timestamp is optional."]
    filter IsAllowableActionForJFSA
    then filter (IsCleared(originatingWorkflowStep) = False)
    then extract cde.settlement.Confirmed
        as "19 Confirmed"

reporting rule ConfirmationTimestampDTCC from ReportableEvent: <"Confirmation Timestamp (DTCC)">
    [regulatoryReference JFSA Trade dataElement "[Internal]" field "Confirmation Timestamp (DTCC)"
        provision "Date and time of the confirmation, as set out in Article 12 of Commission Delegated Regulation (EU) No 149/2013. Applicable only to OTC derivative contracts not cleared by a CCP."]
    filter IsAllowableActionForJFSA
    then extract
        if IsCleared(originatingWorkflowStep) = False
        then originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> confirmationDateTime
    then distinct only-element
    then extract dateTime
        as "[Internal] Confirmation Timestamp (DTCC)"

reporting rule FinalContractualSettlementDate from TransactionReportInstruction: <"Final contractual settlement date">
    [regulatoryReference JFSA Trade dataElement "20" field "Final contractual settlement date"
        provision "Unadjusted date as per the contract, by which all transfer of cash or assets should take place and the counterparties should no longer have any outstanding obligations to each other under that contract. For products that may not have a final contractual settlement date (eg American options), this data element reflects the date by which the transfer of cash or asset would take place if termination were to occur on the expiration date."]
    filter IsAllowableActionForJFSA
    then extract cde.settlement.FinalContractualSettlementDate
        as "20 Final contractual settlement date"

reporting rule SettlementCurrencyLeg1 from TransactionReportInstruction: <"Settlement Currency-Leg 1">
    [regulatoryReference JFSA Trade dataElement "21" field "Settlement currency"
        provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of the leg 1. This data element is not applicable for physically settled products (eg physically settled swaptions)."]
    [regulatoryReference JFSA Trade dataElement "21" field "Settlement currency - Remark"
        provision "Offshore currencies are to be reported as onshore currency. For products denominated in multiple currencies which do not net (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    [regulatoryReference ISDA PeerReviewGroup date "unknown"
        provision "In the case where settlement currency is not provided, model does not infer cash vs. physical settlement based on the product and then extract the notional currency as settlement currency. The conclusion at Peer Review was that firms should fill out the settlement currency field if it is reportable and DRR should not infer it from the notional."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract ProductForTrade
    then extract SettlementTermsLeg1
    then cde.settlement.SettlementCurrency
        as "21 Settlement Currency-Leg 1"

reporting rule SettlementCurrencyLeg2 from TransactionReportInstruction: <"Settlement Currency-Leg 2">
    [regulatoryReference JFSA Trade dataElement "21" field "Settlement currency"
        provision "Currency for the cash settlement of the transaction when applicable. For multi-currency products that do not net, the settlement currency of each leg. This data element is not applicable for physically settled products (e.g., physically settled swaptions)."]
    [regulatoryReference JFSA Trade dataElement "21" field "Settlement currency - Remark"
        provision "Offshore currencies are to be reported as onshore currency. For products denominated in multiple currencies which do not net (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract ProductForTrade
    then extract SettlementTermsLeg2
    then cde.settlement.SettlementCurrency
        as "21 Settlement Currency-Leg 2"

reporting rule ClearingAccountOrigin from TransactionReportInstruction: <"Clearing Account Origin">
    [regulatoryReference JFSA Trade dataElement "22" field "Clearing Account Origin"
        provision "Indicator of whether the clearing member acted as principal for a house trade or an agent for a customer trade."]
    [regulatoryReference JFSA Trade dataElement "22" field "Clearing Account Origin - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if IsCleared(originatingWorkflowStep) = True
        then if Counterparties(TradeForEvent)
                    any = ExtractPartyFromRelatedPartyByRole(
                            reportableInformation -> partyInformation -> relatedParty,
                            PartyRoleEnum -> ClearingFirm
                        )
            then "HOUS"
            else "CLIE"
        as "22 Clearing account origin"

reporting rule OriginalSwapUTI from TransactionReportInstruction: <"Original Swap UTI">
    [regulatoryReference JFSA Trade dataElement "23" field "Original Swap UTI"
        provision "The unique transaction identifier (UTI) of the original swap submitted for clearing to the derivatives clearing organization (DCO) that is replaced by clearing swaps."]
    [regulatoryReference JFSA Trade dataElement "23" field "Original Swap UTI - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if IsCleared(originatingWorkflowStep) = True
                and IsActionTypeNEWT = True
                and cde.event.EventType = CLRG
        then BeforeTradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then filter IsMax32UpperCaseAlphanumericText = True
    then last
        as "23 Original Swap UTI"

reporting rule OriginalSwapUTIProprietary from TransactionReportInstruction: <"Original Swap UTI">
    [regulatoryReference JFSA Trade dataElement "23" field "Original Swap UTI"
        provision "The unique transaction identifier (UTI) of the original swap submitted for clearing to the derivatives clearing organization (DCO) that is replaced by clearing swaps."]
    [regulatoryReference JFSA Trade dataElement "23" field "Original Swap UTI - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if IsCleared(originatingWorkflowStep) = True
                and IsActionTypeNEWT = True
                and cde.event.EventType = CLRG
        then BeforeTradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then filter IsMax32UpperCaseAlphanumericText = False
    then last
        as "23 Original Swap UTI (Proprietary)"

reporting rule ClearingReceiptTimestamp from TransactionReportInstruction: <"Clearing receipt timestamp">
    [regulatoryReference JFSA Trade dataElement "24" field "Clearing receipt timestamp"
        provision "The date and time, expressed in UTC, the original swap was received by the derivatives clearing organization (DCO) for clearing and recorded by the DCOs system."]
    [regulatoryReference JFSA Trade dataElement "24" field "Clearing receipt timestamp - Remark"
        provision "Reported by central counterparty. However, when a financial institution conducts a transaction with a central counterparty prescribed in JFSA Notification No. 105, the financial institution must report the transaction information as a bilateral transaction, even if it is a clearing transaction."]
    filter IsAllowableAction or IsActionTypeTERM
    then extract
        if ((IsCleared(originatingWorkflowStep) or (IntendedToClear(originatingWorkflowStep) and IsActionTypeTERM))
                and cde.event.EventType = CLRG)
        then originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> clearingReceiptDateTime
    then only-element
    then extract dateTime
        as "24 Clearing receipt timestamp"

reporting rule JfsaUti from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC">
    [regulatoryReference JFSA Trade dataElement "25" field "UTI"
        provision "A unique identifier assigned to all swap transactions which identifies the swap uniquely throughout its lifecycle."]
    extract
        if GetRegimeSpecificIdentifiers(
                reportableInformation,
                SupervisoryBodyEnum -> JFSA,
                TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            )
            exists
        then GetRegimeSpecificIdentifiers(
                    reportableInformation,
                    SupervisoryBodyEnum -> JFSA,
                    TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
                )
        else if TradeForEvent exists
        then (TradeForEvent -> tradeIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
        else if PositionForEvent exists
        then (PositionForEvent -> positionIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
    then distinct
    then only-element

reporting rule Uti from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC">
    [regulatoryReference JFSA Trade dataElement "25" field "UTI"
        provision "A unique identifier assigned to all swap transactions which identifies the swap uniquely throughout its lifecycle."]
    JfsaUti then filter IsMax32UpperCaseAlphanumericText = True
        as "25 Unique transaction identifier (UTI)"

reporting rule UtiProprietary from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC">
    [regulatoryReference JFSA Trade dataElement "25" field "UTI"
        provision "A unique identifier assigned to all swap transactions which identifies the swap uniquely throughout its lifecycle.  (Trade identifier expressed in a proprietary notation)"]
    JfsaUti then filter IsMax32UpperCaseAlphanumericText = False
        as "25 Unique transaction identifier (UTI Proprietary)"

reporting rule PriorUti from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference JFSA Trade dataElement "26" field "Prior UTI"
        provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (eg in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (eg in clearing or if a transaction is split into several different transactions).
			This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (eg in the case of a compression)."]
    [regulatoryReference JFSA Trade dataElement "26" field "Prior UTI - Remark"
        provision "This is applicable to one to-many or one to-one novation transactions. In addition to novation, it is to be applied to new transactions arising from the exercise of swap rights for swaptions and clearing transactions ( and  transactions) reported by central counterparty. Additionally, in the case of novation, it is to be reported in cases where a new financial institution joins the contract (step-in party). However, in cases where no UTI has been assigned in the past, or it is physically difficult to obtain the Prior UTI, a tentative Prior UTI (unique number established by each financial institution) may be used."]
    filter IsAllowableAction
    then extract
        if TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False
        then cde.link.PriorUTI
        else (extract reportableInformation -> transactionInformation
        then filter
            regimeName = RegimeNameEnum -> JFSA
                and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
        then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
        then flatten
        then distinct
        then only-element)
    then filter IsMax32UpperCaseAlphanumericText = True
        as "26 Prior UTI"

reporting rule PriorUtiProprietary from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference JFSA Trade dataElement "26" field "Prior UTI"
        provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (eg in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (eg in clearing or if a transaction is split into several different transactions).
			This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (eg in the case of a compression)."]
    [regulatoryReference JFSA Trade dataElement "26" field "Prior UTI - Remark"
        provision "This is applicable to one to-many or one to-one novation transactions. In addition to novation, it is to be applied to new transactions arising from the exercise of swap rights for swaptions and clearing transactions ( and  transactions) reported by central counterparty. Additionally, in the case of novation, it is to be reported in cases where a new financial institution joins the contract (step-in party). However, in cases where no UTI has been assigned in the past, or it is physically difficult to obtain the Prior UTI, a tentative Prior UTI (unique number established by each financial institution) may be used."]
    filter IsAllowableAction
    then if originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                or (TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                    and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False)
        then extract cde.link.PriorUTI
        else (extract reportableInformation -> transactionInformation
        then filter
            regimeName = RegimeNameEnum -> EMIR
                and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
        then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
        then flatten
        then distinct
        then only-element)
    then filter IsMax32UpperCaseAlphanumericText = False
        as "26 Prior UTI (Proprietary)"

reporting rule FixedRateDayCountConventionLeg1 from TransactionReportInstruction: <"Fixed rate day count convention-leg 1">
    [regulatoryReference JFSA Trade dataElement "27" field "Fixed rate day count convention-leg 1"
        provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference JFSA Trade dataElement "27" field "Fixed rate day count convention-leg 1 - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
        as "27 Fixed rate day count convention-Leg 1"

reporting rule FixedRateDayCountConventionLeg2 from TransactionReportInstruction: <"Fixed rate day count convention leg 2">
    [regulatoryReference JFSA Trade dataElement "27" field "Fixed rate day count convention leg 2"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference JFSA Trade dataElement "27" field "Fixed rate day count convention leg 2 - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
            // then ISO20022DayCountFractionFromCDM // uncomment when "as" syntax allows this
            // To-Do: Day count fraction is missing in leg2 of the sample use-case "IRS Cross Currency Fixed Fixed" - Technically CDM Object validation should fail where fixed rate is provided
        as "27 Fixed rate day count convention leg 2"

// Remap to the CDE, currently endpoint "as" is probiting this
//TODO: Update the samples to include Day Count Conventions on Floating legs
reporting rule FloatingRateDayCountConventionOfLeg1 from TransactionReportInstruction: <"Floating rate day count convention of leg 1">
    [regulatoryReference JFSA Trade dataElement "27" field "Floating rate day count convention of leg 1"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments for the floating rate of leg 1 are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference JFSA Trade dataElement "27" field "Floating rate day count convention of leg 1 - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "27 Floating rate day count convention of leg 1"

reporting rule FloatingRateDayCountConventionOfLeg2 from TransactionReportInstruction: <"Floating rate day count convention of leg 2">
    [regulatoryReference JFSA Trade dataElement "27" field "Floating rate day count convention of leg 2"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments for the floating rate of leg 2 are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference JFSA Trade dataElement "27" field "Floating rate day count convention of leg 2 - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "27 Floating rate day count convention of leg 2"

reporting rule FixedRatePaymentFrequencyPeriodLeg1 from TransactionReportInstruction: <"Fixed rate payment frequency period-Leg 1">
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "28 Fixed rate payment frequency period-Leg 1"

reporting rule FixedRatePaymentFrequencyPeriodLeg2 from TransactionReportInstruction: <"Fixed rate payment frequency period-Leg 2">
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "28 Fixed rate payment frequency period-Leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period-Leg 1">
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "28 Floating rate payment frequency period-Leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period-Leg 2">
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference JFSA Trade dataElement "28" field "Payment frequency period - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "28 Floating rate payment frequency period-Leg 2"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction: <"Fixed rate payment frequency period multiplier-Leg 1">
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2. This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is EXPI, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "29 Fixed rate payment frequency period multiplier-Leg 1"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction: <"Fixed rate payment frequency period multiplier-Leg 2">
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is EXPI, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "29 Fixed rate payment frequency period multiplier-Leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier-Leg 1">
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is EXPI, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "29 Floating rate payment frequency period multiplier-Leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier-Leg 2">
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is EXPI, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference JFSA Trade dataElement "29" field "Payment frequency period multiplier - Remark"
        provision "To be reported for fixed and variable convention, and for Leg1 and Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "29 Floating rate payment frequency period multiplier-Leg 2"

reporting rule FixingDateLeg1 from TransactionReportInstruction: <"Fixing date-Leg 1">
    [regulatoryReference JFSA Trade dataElement "30" field "Fixing date"
        provision "Describes the specific date when a non-deliverable forward as well as various types of FX OTC options such as cash-settled options that will 'fix' against a particular exchange rate, which will be used to compute the ultimate cash settlement"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Only applies to fixing date of an exchange rate as per definition"]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        // IR
        if InterestRateLeg1 -> settlementTerms exists
        then InterestRateLeg1 -> settlementTerms
        // Option
        else if contractualProduct -> economicTerms -> payout -> optionPayout exists
        then contractualProduct -> economicTerms -> payout -> optionPayout only-element -> settlementTerms
        // Forward
        else if contractualProduct -> economicTerms -> payout -> forwardPayout exists
        then contractualProduct -> economicTerms -> payout -> forwardPayout only-element -> settlementTerms
    then extract
        cashSettlementTerms only-element -> valuationDate -> fxFixingDate -> fxFixingDate -> adjustableDate -> unadjustedDate
    then ToDateTime
        as "30 Fixing date-Leg 1"

reporting rule FixingDateLeg2 from TransactionReportInstruction: <"Fixing date-Leg 2">
    [regulatoryReference JFSA Trade dataElement "30" field "Fixing date"
        provision "Describes the specific date when a non-deliverable forward as well as various types of FX OTC options such as cash-settled options that will 'fix' against a particular exchange rate, which will be used to compute the ultimate cash settlement"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Only applies to fixing date of an exchange rate as per definition"]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract InterestRateLeg2 -> settlementTerms
    then extract
        cashSettlementTerms only-element -> valuationDate -> fxFixingDate -> fxFixingDate -> adjustableDate -> unadjustedDate
    then ToDateTime
        as "30 Fixing date-Leg 2"

reporting rule FloatingRateResetFrequencyPeriodLeg1 from TransactionReportInstruction: <"Floating rate reset frequency period-Leg 1">
    [regulatoryReference JFSA Trade dataElement "31" field "Floating rate reset frequency period"
        provision "For each floating Leg of the swap transaction, where applicable, time unit associated with the frequency of resets, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "31 Floating rate reset frequency period-Leg 1"

reporting rule FloatingRateResetFrequencyPeriodLeg2 from TransactionReportInstruction: <"Floating rate reset frequency period-Leg 2">
    [regulatoryReference JFSA Trade dataElement "31" field "Floating rate reset frequency period"
        provision "For each floating Leg of the swap transaction, where applicable, time unit associated with the frequency of resets, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "31 Floating rate reset frequency period-Leg 2"

reporting rule FloatingRateResetFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction: <"Floating rate reset frequency period multiplier-Leg 1">
    [regulatoryReference JFSA Trade dataElement "32" field "Floating rate reset frequency period multiplier"
        provision "For each floating leg of the swap transaction, where applicable, number of time units (as expressed by the Floating rate reset frequency period) that determines the frequency at which periodic payment dates for reset occur. For example, a transaction with reset payments occurring every two months is represented with a Floating rate reset frequency period of MNTH (monthly) and a Floating rate reset frequency period multiplier of 2. This data element is not applicable if the Floating rate reset frequency period is ADHO. If Floating rate reset frequency period is EXPI, then the Floating rate reset frequency period multiplier is 1. If the reset frequency period is intraday, then the Floating rate reset frequency period is DAIL and the Floating rate reset frequency period multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "32 Floating rate reset frequency period multiplier-Leg 1"

reporting rule FloatingRateResetFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction: <"Floating rate reset frequency period multiplier-Leg 2">
    [regulatoryReference JFSA Trade dataElement "32" field "Floating rate reset frequency period multiplier"
        provision "For each floating leg of the swap transaction, where applicable, number of time units (as expressed by the Floating rate reset frequency period) that determines the frequency at which periodic payment dates for reset occur. For example, a transaction with reset payments occurring every two months is represented with a Floating rate reset frequency period of MNTH (monthly) and a Floating rate reset frequency period multiplier of 2. This data element is not applicable if the Floating rate reset frequency period is ADHO. If Floating rate reset frequency period is EXPI, then the Floating rate reset frequency period multiplier is 1. If the reset frequency period is intraday, then the Floating rate reset frequency period is DAIL and the Floating rate reset frequency period multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "32 Floating rate reset frequency period multiplier-Leg 2"

reporting rule OtherPayment from TransactionReportInstruction: <"Other payment">
    [regulatoryReference JFSA Trade dataElement "33-38" field "Other payment"
        provision "Fields 33-38 are repeatable"]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsAllowableActionForJFSA
    then extract transactionReportInstruction [
        TradeStateForEvent
            then extract transferHistory
            then filter IsOtherPayment
            then extract
                OtherPaymentReport {
                    paymentType: OtherPaymentType,
                    amount: OtherPaymentAmount,
                    currency: OtherPaymentCurrency,
                    date: OtherPaymentDate,
                    payer: ExtractOtherPaymentPayer(item, transactionReportInstruction),
                    payerFormat: OtherPaymentPayerFormat,
                    receiver: ExtractOtherPaymentReceiver(
                            item,
                            transactionReportInstruction
                        ),
                    receiverFormat: OtherPaymentReceiverFormat
                }
    ]

reporting rule OtherPaymentAmount from TransferState: <"Other payment amount">
    [regulatoryReference JFSA Trade dataElement "33" field "Other payment amount"
        provision "Payment amounts with corresponding payment types to accommodate requirements of transaction descriptions from different asset classes."]
    [regulatoryReference JFSA Trade dataElement "33" field "Other payment amount - Remark"
        provision "Exchange of principal amount is reported as both receipt and payment. With respect to the exchange of principal amount for currency swaps, following is an example of how to handle the principal amount difference arising for a Mark-to-Market type transaction.
        Example : If the initial USD principal is 1 and the spot at execution time is 110, then the JPY principal is fixed at 110. Assuming that the interest payment period is three months and the spot after three months is 100, the new principal amount in U.S. dollars is 1.1, which is calculated by dividing the fixed principal amount in yen of 110 by the spot amount of 100, and the change in the principal amount in U.S. dollars (0.1) shall be received and paid.
        For above example the expected values would be to:
        Report the difference as other payment amount.
        Report 'modify' and other payment type as 'PEXH'. Also, report the new principal amount in notional amount.
        In the above example : Notional Amount: USD 1.1; Other payment Type: PEXH; Other payment amount: USD 0.1"]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentAmount
        as "33/38-$ 33 Other payment amount"

reporting rule OtherPaymentType from TransferState: <"Other payment type">
    [regulatoryReference JFSA Trade dataElement "34" field "Other payment type"
        provision "Type of Other payment amount. Option premium payment is not included as a payment type as premiums for option are reported using the option premium dedicated data element."]
    [regulatoryReference JFSA Trade dataElement "34" field "Other payment type - Remark"
        provision "Exchange of principal amount is to be reported as both receipt and payment."]
    [regulatoryReference ISDA USComplianceGroup date "20220719"
        provision "For novation fees: US Working Group agreed that Example 01 Submission 03/04 indicate novation fee is not reported under the rewrite."]
    [regulatoryReference ISDA USComplianceGroup date "20220727"
        provision "For other fees, members expressed that the answer to this question is trade-dependent. After discussion, the WG concluded that each RCP must make its own determination whether other fees such as Amendment Fee, Unclassified Fee, Termination Fee, etc. fit within the definition of one of the 3 Allowable Values of #57, as the RCP would be most familiar with the particular transaction and therefore the particular fee."]
    filter IsOtherPayment
    then cde.payment.OtherPaymentType
        as "33/38-$ 34 Other payment type"

reporting rule OtherPaymentCurrency from TransferState: <"Other payment currency">
    [regulatoryReference JFSA Trade dataElement "35" field "Other payment currency"
        provision "Currency in which Other payment amount is denominated."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentCurrency
        as "33/38-$ 35 Other payment currency"

reporting rule OtherPaymentDate from TransferState: <"Other payment date">
    [regulatoryReference JFSA Trade dataElement "36" field "Other payment date"
        provision "Unadjusted date on which the Other payment amount is paid."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentDate
        as "33/38-$ 36 Other payment date"

reporting rule OtherPaymentPayer from TransferState: <"Other Payment Payer">
    [regulatoryReference JFSA Trade dataElement "37" field "Other payment payer"
        provision "Identifier of the payer of Other payment amount."]
    [regulatoryReference JFSA Trade dataElement "37" field "Other payment payer - Remark"
        provision "[In the case of financial institutions] Tentative LEI = Party LEI + Counterparty BIC Code
        [In the case of corporations and individuals] Tentative LEI = Trading Party LEI + Unique Alphanumeric Code (Control number assigned by the financial institution, etc.)
        Tentative LEI must have a unique alphanumeric string to ensure the party can be uniquely identified.The fund reports its LEI."]
    empty // This rule is implemented within repeating rule OtherPayment.  This rule has been maintained so the regulatoryReference and "as" name can be specified.  DSL change request to allow easier modelling https://github.com/finos/rune-dsl/issues/852 
        as "33/38-$ 37 Other Payment Payer"

reporting rule OtherPaymentPayerFormat from TransferState: <"Other Payment Payer Format">
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentPayerFormat
        as "Other Payment Payer Format (non-reportable)"

reporting rule OtherPaymentReceiver from TransferState: <"Other payment receiver">
    [regulatoryReference JFSA Trade dataElement "38" field "Other payment receiver"
        provision "Identifier of the receiver of Other payment amount."]
    [regulatoryReference JFSA Trade dataElement "38" field "Other payment receiver - Remark"
        provision "[In the case of financial institutions] Tentative LEI = Party LEI + Counterparty BIC Code
        [In the case of corporations and individuals] Tentative LEI = Trading Party LEI + Unique Alphanumeric Code (Control number assigned by the financial institution, etc.)
        Tentative LEI must have a unique alphanumeric string to ensure the party can be uniquely identified.The fund reports its LEI."]
    empty // This rule is implemented within repeating rule OtherPayment.  This rule has been maintained so the regulatoryReference and "as" name can be specified.  DSL change request to allow easier modelling https://github.com/finos/rune-dsl/issues/852 
        as "33/38-$ 38 Other Payment Receiver"

reporting rule OtherPaymentReceiverFormat from TransferState: <"Other Payment Receiver Format">
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentReceiverFormat
        as "Other Payment Receiver Format (non-reportable)"

reporting rule ValuationAmount from TransactionReportInstruction: <"Valuation amount">
    [regulatoryReference JFSA Trade dataElement "39" field "Valuation amount"
        provision "Current value of the outstanding contract without applying any valuation adjustments.
        Valuation amount is expressed as the exit cost of the contract or components of the contract, i.e. the price that would be received to sell the contract (in the market in an orderly transaction at the valuation date)."]
    [regulatoryReference JFSA Trade dataElement "39" field "Valuation amount - Remark"
        provision "Valuation amount does not take into account the various valuation adjustments such as CVA (Credit Valuation Adjustment). Amount to be reported is to be the preadjusted valuation amount."]
    filter IsActionTypeVALU
    then cde.valuation.ValuationAmount
        as "39 Valuation amount"

reporting rule ValuationCurrency from TransactionReportInstruction: <"Valuation currency">
    [regulatoryReference JFSA Trade dataElement "40" field "Valuation currency"
        provision "Currency in which the valuation amount is denominated."]
    filter IsActionTypeVALU
    then cde.valuation.ValuationCurrency
        as "40 Valuation currency"

reporting rule ValuationTimestamp from TransactionReportInstruction: <"Valuation Timestamp">
    [regulatoryReference JFSA Trade dataElement "41" field "Valuation timestamp"
        provision "Date and time of the last valuation marked to market, provided by the central counterparty (CCP) or calculated using the current or last available market price of the inputs. If for example a currency exchange rate is the basis for a transactions valuation, then the valuation timestamp reflects the moment in time that exchange rate was current."]
    [regulatoryReference JFSA Trade dataElement "41" field "Valuation timestamp - Remark"
        provision "Valuation time period specified by each financial institution is permitted."]
    filter IsActionTypeVALU
    then cde.valuation.ValuationTimestamp
        as "41 Valuation Timestamp"

reporting rule ValuationMethod from TransactionReportInstruction: <"Valuation method">
    [regulatoryReference JFSA Trade dataElement "42" field "Valuation method"
        provision "Source and method used for the valuation of the transaction by the reporting counterparty.
        If at least one valuation input is used that is classified as mark-to-model in appendix D of CFTC Technical Specification, then the whole valuation is classified as mark-to-model.
        If only inputs are used that are classified as mark-to-market in appendix D of CFTC Technical Specification then the whole valuation is classified as mark-to-market."]
    filter IsActionTypeVALU
    then extract cde.valuation.ValuationMethod(GetValuation)
        as "42 Valuation method"

reporting rule Delta from TransactionReportInstruction: <"Delta">
    [regulatoryReference JFSA Trade dataElement "43" field "Delta"
        provision "The ratio of the change in the price of an OTC derivative transaction to the change in the price of the underlier, at the time a new transaction is reported or when a change in the notional amount is reported."]
    [regulatoryReference JFSA Trade dataElement "43" field "Delta"
        provision "Reporting (including any amendments made on an existing trade), is required from April 7, 2025."]
    filter IsActionTypeVALU
    then extract cde.quantity.Delta
        as "43 Delta"

reporting rule CollateralPortfolioIndicator from TransactionReportInstruction: <"Collateral Portfolio Indicator">
    [regulatoryReference JFSA Trade dataElement "44" field "Collateral Portfolio Indicator"
        provision "Indicator of whether the collateralisation was performed on a portfolio basis. By on a portfolio basis, it is meant a set of transactions that are margined together (either on a net or a gross basis) contrary to the scenario where the margin is calculated and posted for each individual transaction separately."]
    [regulatoryReference JFSA Trade dataElement "44" field "Collateral Portfolio Indicator - Remark"
        provision "True, if collateralisation has been set for each parties involved in the transaction. Whether or not the collateralisation is set will be assumed based on CSA agreement, however it should also include any independently created collateral agreements other than CSA agreement. True, if there is a collateral agreement that covers more than one transaction even if there is only one currently outstanding balance."]
    filter IsAllowableActionForJFSA
    then extract cde.collateral.CollateralPortfolioIndicator
        as "44 Collateral Portfolio Indicator"

reporting rule InitialMarginCollateralPortfolioCode from TransactionReportInstruction: <"Initial margin collateral portfolio code">
    [regulatoryReference JFSA Trade dataElement "62" field "Initial margin collateral portfolio code"
        provision "If collateral is reported on a portfolio basis, a unique code assigned by the reporting counterparty to the portfolio that tracks the aggregate initial margin of a set of open swap transactions. This data element is not applicable if the collateralisation was performed on a transaction level basis, or if there is no collateral agreement, or if no collateral is posted or received. The portfolio code is required for both collateral reporting and valuation reporting in order to link the 2 data sets."]
    [regulatoryReference JFSA Trade dataElement "62" field "Initial margin collateral portfolio code - Remark"
        provision "Report the unique code assigned by the financial institution. If collateralisation is performed separately for each parties involved in the transaction, report the code per each party."]
    [regulatoryReference JFSA Trade dataElement "62" field "Initial margin collateral portfolio code" footnote "1"
        provision "Note: If the [Initial margin collateral portfolio code] is not applicable to your trade, clients could submit the value [NOAP] to represent 'No Applicable' in '/NoPrtfl' XML."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent -> collateral -> collateralPortfolio
    then filter
        legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = CollateralMarginTypeEnum -> InitialMargin
    then only-element
    then portfolioIdentifier -> assignedIdentifier -> identifier last
        as "62 Initial margin collateral portfolio code"

reporting rule VariationMarginCollateralPortfolioCode from TransactionReportInstruction: <"Variation margin collateral portfolio code">
    [regulatoryReference JFSA Trade dataElement "63" field "Variation margin collateral portfolio code"
        provision "If collateral is reported on a portfolio basis, a unique code assigned by the reporting counterparty to the portfolio that tracks the aggregate variation margin related to a set of open swap transactions. This data element is not applicable if the collateralisation was performed on a transaction level basis, or if there is no collateral agreement, or if no collateral is posted or received. The portfolio code is required for both collateral reporting and valuation reporting in order to link the 2 data sets."]
    [regulatoryReference JFSA Trade dataElement "63" field "Variation margin collateral portfolio code - Remark"
        provision "Report the unique code assigned by the financial institution. If collateralisation is performed separately for each parties involved in the transaction, report the code per each party."]
    [regulatoryReference JFSA Trade dataElement "63" field "Variation margin collateral portfolio code" footnote "1"
        provision "Note: If the [Variation margin collateral portfolio code] is not applicable to your trade, clients could submit the value [NOAP] to represent 'No Applicable' in '/NoPrtfl' XML."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent -> collateral -> collateralPortfolio
    then filter
        legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = CollateralMarginTypeEnum -> VariationMargin
    then only-element
    then portfolioIdentifier -> assignedIdentifier -> identifier last
        as "63 Variation margin collateral portfolio code"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule PriceFormatMonetary from TransactionReportInstruction: <"Price formatted as Monetary.">
    [regulatoryReference JFSA Trade dataElement "64" field "Price"
        provision "Price specified in the OTC derivative transaction. It does not include fees, taxes or commissions.
        For commodity fixed/float swaps and similar products with periodic payments, this data element refers to the fixed price of the fixed Leg(s).
        For commodity and equity forwards and similar products, this data element refers to the forward price of the underlying or reference asset.
        For equity swaps, portfolios swaps, and similar products, this data element refers to the initial price of the underlying or reference asset.
        For contracts for difference and similar products, this data element refers to the initial price of the underlier.
        This data element is not applicable to:
            - Interest rate swaps and forward rate agreements, as it is understood that the information included in the data elements Fixed rate and Spread may be interpreted as the price of the transaction.
            - Interest rate options and interest rate swaptions, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Commodity basis swaps and the floating leg of commodity fixed/float swaps, as it is understood that the information included in the data element Spread may be interpreted as the price of the transaction.
            - Foreign exchange swaps, forwards and options, as it is understood that the information included in the data elements Exchange rate, Strike price, and Option premium may be interpreted as the price of the transaction.
            - Equity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Credit default swaps and credit total return swaps, as it is understood that the information included in the data elements Fixed rate, Spread and Upfront payment (Other payment type: Upfront payment) may be interpreted as the price of the transaction.
            - Commodity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
        Where the price is not known when a new transaction is reported, the price is updated as it becomes available. For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference JFSA Trade dataElement "64" field "Price" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.Price, PriceNotationEnum -> Monetary)
        as "64 Price (Monetary)"

reporting rule PriceFormatDecimal from TransactionReportInstruction: <"Price formatted as Decimal.">
    [regulatoryReference JFSA Trade dataElement "64" field "Price"
        provision "Price specified in the OTC derivative transaction. It does not include fees, taxes or commissions.
        For commodity fixed/float swaps and similar products with periodic payments, this data element refers to the fixed price of the fixed Leg(s).
        For commodity and equity forwards and similar products, this data element refers to the forward price of the underlying or reference asset.
        For equity swaps, portfolios swaps, and similar products, this data element refers to the initial price of the underlying or reference asset.
        For contracts for difference and similar products, this data element refers to the initial price of the underlier.
        This data element is not applicable to:
            - Interest rate swaps and forward rate agreements, as it is understood that the information included in the data elements Fixed rate and Spread may be interpreted as the price of the transaction.
            - Interest rate options and interest rate swaptions, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Commodity basis swaps and the floating leg of commodity fixed/float swaps, as it is understood that the information included in the data element Spread may be interpreted as the price of the transaction.
            - Foreign exchange swaps, forwards and options, as it is understood that the information included in the data elements Exchange rate, Strike price, and Option premium may be interpreted as the price of the transaction.
            - Equity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Credit default swaps and credit total return swaps, as it is understood that the information included in the data elements Fixed rate, Spread and Upfront payment (Other payment type: Upfront payment) may be interpreted as the price of the transaction.
            - Commodity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
        Where the price is not known when a new transaction is reported, the price is updated as it becomes available. For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference JFSA Trade dataElement "64" field "Price" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if (cde.price.PriceNotationEnum = PriceNotationEnum -> Percentage or cde.price.PriceNotationEnum = PriceNotationEnum -> Decimal)
        then MultiplyPrice(cde.price.Price, PriceNotationEnum -> Decimal)
        as "64 Price (Decimal)"

/*------------------------------------------------------------------------------------ */
reporting rule PriceCurrency from TransactionReportInstruction: <"Price Currency">
    [regulatoryReference JFSA Trade dataElement "65" field "Price currency"
        provision "Currency in which the price is denominated. Price currency is only applicable if Price notation = 1."]
    filter IsAllowableActionForJFSA
    then extract cde.price.PriceCurrency
    then extract ConvertNonISOToISOCurrency
        as "65 Price currency"

reporting rule GetPriceNotationEnum from TransactionReportInstruction: <"Price Notation Enum">
    [regulatoryReference JFSA Trade dataElement "66" field "Price notation"
        provision "Manner in which the price is expressed."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a JFSA function which converts Percentage notation into Decimal."]
    if cde.price.PriceNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.PriceNotationEnum

reporting rule PriceNotation from TransactionReportInstruction: <"Price notation">
    [regulatoryReference JFSA Trade dataElement "66" field "Price notation"
        provision "Manner in which the price is expressed."]
    filter IsAllowableActionForJFSA
    then extract GetNotationString(GetPriceNotationEnum)
        as "66 Price notation"

reporting rule PriceUnitOfMeasure from TransactionReportInstruction: <"Price unit of measure">
    [regulatoryReference JFSA Trade dataElement "67" field "Price unit of measure"
        provision "Unit of measure in which the price is expressed."]
    filter IsAllowableActionForJFSA
    then cde.price.PriceUnitOfMeasure
        as "67 Price unit of measure"

reporting rule PriceSchedule from TransactionReportInstruction: <"Price Schedule">
    [regulatoryReference JFSA Trade dataElement "68-70" field "Price Schedule"
        provision "Fields 68-70 are repeatable and shall be populated in the case of derivatives involving price schedules."]
    [regulatoryReference JFSA Trade dataElement "68-70" field "Price Schedule - Remark"
        provision "Applicable for products where the prices will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    filter IsAllowableAction
    then extract GetReportablePricePeriod
    then extract
        PriceScheduleReport {
            effectiveDate: ContractPriceScheduleEffectiveDate,
            endDate: ContractPriceScheduleEndDate,
            priceMonetary: PriceScheduleAmountFormatMonetary,
            priceDecimal: PriceScheduleAmountFormatDecimal
        }
    then sort [ item -> effectiveDate ]

reporting rule ContractPriceScheduleEffectiveDate from PriceReportablePeriod: <"Price schedules - Unadjusted effective date of the price">
    [regulatoryReference JFSA Trade dataElement "68" field "Price schedules - Unadjusted effective date of the price"
        provision "For OTC derivative transactions with prices varying throughout the life of the transaction:
                    Unadjusted effective date of the price.
                    Price schedule is only applicable if the price varies per schedule.
                    The currency, notation, and unit of measure for the varying prices in the schedule are reported in Price currency, Price notation, and Price unit of measure data elements."]
    [regulatoryReference JFSA Trade dataElement "68" field "Price schedules - Unadjusted effective date of the price - Remark"
        provision "Applicable for products where the prices will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    cde.price.PriceScheduleEffectiveDate
        as "68/70-$ 68 Price schedules - Unadjusted effective date of the price"

reporting rule ContractPriceScheduleEndDate from PriceReportablePeriod: <"Price schedules - Unadjusted end date of the price">
    [regulatoryReference JFSA Trade dataElement "69" field "Price schedules - Unadjusted end date of the price"
        provision "For OTC derivative transactions with prices varying throughout the life of the transaction:
                    Unadjusted end date of the price (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)
                    Price schedule is only applicable if the price varies per schedule.
                    The currency, notation, and unit of measure for the varying prices in the schedule are reported in Price currency, Price notation, and Price unit of measure data elements."]
    [regulatoryReference JFSA Trade dataElement "69" field "Price schedules - Unadjusted end date of the price - Remark"
        provision "Applicable for products where the prices will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are only possible for commodities, which are out of scope for this jurisdiction."]
    cde.price.PriceScheduleEndDate
        as "68/70-$ 69 Price schedules - Unadjusted end date of the price"

reporting rule PriceScheduleAmountFormatMonetary from PriceReportablePeriod: <"Price schedules - Price in effect between the unadjusted effective and end date">
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date"
        provision "Price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date - Remark"
        provision "Applicable for products where the prices will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    cde.price.PriceScheduleAmountFormatMonetary
        as "68/70-$ 70 Price in effect between the unadjusted effective and end date (Monetary)"

reporting rule PriceScheduleAmountFormatDecimal from PriceReportablePeriod: <"Price schedules - Price in effect between the unadjusted effective and end date">
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date"
        provision "Price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date - Remark"
        provision "Applicable for products where the prices will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    [regulatoryReference JFSA Trade dataElement "70" field "Price in effect between the unadjusted effective and end date" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    cde.price.PriceScheduleAmountFormatDecimal
        as "68/70-$ 70 Price in effect between the unadjusted effective and end date (Decimal)"

reporting rule FixedRateLeg1 from TransactionReportInstruction: <"Fixed rate-Leg 1">
    [regulatoryReference JFSA Trade dataElement "71" field "Fixed rate"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed Leg(s)."]
    [regulatoryReference JFSA Trade dataElement "71" field "Fixed rate - Remark"
        provision "In case the receipt and payment amount is fixed, it is to be converted into a rate."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract cde.price.InterestRateFixedRate(InterestRateLeg1)
        as "71 Fixed rate-Leg 1"

reporting rule FixedRateLeg2 from TransactionReportInstruction: <"Fixed rate-Leg 2">
    [regulatoryReference JFSA Trade dataElement "71" field "Fixed rate"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed Leg(s)."]
    [regulatoryReference JFSA Trade dataElement "71" field "Fixed rate - Remark"
        provision "In case the receipt and payment amount is fixed, it is to be converted into a rate."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract cde.price.InterestRateFixedRate(InterestRateLeg2)
        as "71 Fixed rate-Leg 2"

reporting rule SpreadOfLeg1Monetary from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "72 Spread-Leg 1 (Monetary)"

reporting rule SpreadOfLeg1Decimal from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg1
    then extract
        if [PriceNotationEnum -> Percentage, PriceNotationEnum -> Decimal] any = GetPriceNotation
        then MultiplyPrice(value, PriceNotationEnum -> Decimal)
        as "72 Spread-Leg 1 (Decimal)"

reporting rule SpreadOfLeg1Basis from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Basis
        then MultiplyPrice(value, GetPriceNotation)
        as "72 Spread-Leg 1 (Basis)"

reporting rule SpreadCurrencyOfLeg1 from TransactionReportInstruction: <"Spread currency-Leg 1">
    [regulatoryReference JFSA Trade dataElement "73" field "Spread currency"
        provision "For each Leg of the transaction, where applicable: currency in which the spread is denominated. This data element is only applicable if Spread notation = 1."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg1Currency
    then extract ConvertNonISOToISOCurrency
        as "73 Spread currency-Leg 1"

reporting rule SpreadNotationOfLeg1 from TransactionReportInstruction: <"Spread notation-Leg 1">
    [regulatoryReference JFSA Trade dataElement "74" field "Spread notation"
        provision "For each Leg of the transaction, where applicable: manner in which the spread is expressed."]
    filter IsAllowableActionForJFSA
    then extract GetNotationString(GetSpreadLeg1NotationEnum)
        as "74 Spread notation-Leg 1"

reporting rule GetSpreadLeg1NotationEnum from TransactionReportInstruction: <"Spread notation-Leg 1 Enum">
    [regulatoryReference JFSA Trade dataElement "74" field "Spread notation"
        provision "For each Leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a JFSA function which converts Percentage notation into Decimal."]
    filter IsAllowableActionForJFSA
    then if cde.price.SpreadLeg1NotationEnum = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else cde.price.SpreadLeg1NotationEnum

/*------------------------------------------------  Spread Leg 1 Ends ------------------------------------------------*/
/*------------------------------------------------ Spread Leg 2 Starts------------------------------------------------*/
reporting rule SpreadOfLeg2Monetary from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg2
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "72 Spread-Leg 2 (Monetary)"

reporting rule SpreadOfLeg2Decimal from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.SpreadLeg2 exists
        then (if [PriceNotationEnum -> Percentage, PriceNotationEnum -> Decimal]
                    any = GetPriceNotation(cde.price.SpreadLeg2)
            then MultiplyPrice(cde.price.SpreadLeg2 -> value, PriceNotationEnum -> Decimal))
        as "72 Spread-Leg 2 (Decimal)"

reporting rule SpreadOfLeg2Basis from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference JFSA Trade dataElement "72" field "Spread"
        provision "For each Leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating Leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating Leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.SpreadLeg2 exists
        then (if GetPriceNotation(cde.price.SpreadLeg2) = PriceNotationEnum -> Basis
            then MultiplyPrice(
                        cde.price.SpreadLeg2 -> value,
                        GetPriceNotation(cde.price.SpreadLeg2)
                    ))
        as "72 Spread-Leg 2 (Basis)"

reporting rule SpreadCurrencyOfLeg2 from TransactionReportInstruction: <"Spread currency-Leg 2">
    [regulatoryReference JFSA Trade dataElement "73" field "Spread currency"
        provision "For each Leg of the transaction, where applicable: currency in which the spread is denominated. This data element is only applicable if Spread notation = 1."]
    filter IsAllowableActionForJFSA
    then extract cde.price.SpreadLeg2Currency
    then extract ConvertNonISOToISOCurrency
        as "73 Spread currency-Leg 2"

reporting rule SpreadNotationOfLeg2 from TransactionReportInstruction: <"Spread notation-Leg 2">
    [regulatoryReference JFSA Trade dataElement "74" field "Spread notation"
        provision "For each Leg of the transaction, where applicable: manner in which the spread is expressed."]
    filter IsAllowableActionForJFSA
    then extract GetNotationString(GetSpreadLeg2NotationEnum)
        as "74 Spread notation-Leg 2"

reporting rule GetSpreadLeg2NotationEnum from TransactionReportInstruction: <"Spread notation-Leg 2 Enum">
    [regulatoryReference JFSA Trade dataElement "74" field "Spread notation"
        provision "For each Leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a JFSA function which converts Percentage notation into Decimal."]
    filter IsAllowableActionForJFSA
    then if cde.price.SpreadLeg2NotationEnum = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else cde.price.SpreadLeg2NotationEnum

/*------------------------------------------------ Spread Leg 2 Ends------------------------------------------------*/
/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule StrikePriceMonetary from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference JFSA Trade dataElement "75" field "Strike price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426.Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
    [regulatoryReference JFSA Trade dataElement "75" field "Strike price - Remark"
        provision "In the case of over-the-counter derivatives transactions with a Strike Price schedule, report the Strike Price as of the commencement of the transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if GetStrikePriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.StrikePrice, GetStrikePriceNotationEnum)
        as "75 Strike Price (Monetary)"

reporting rule StrikePriceDecimal from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference JFSA Trade dataElement "75" field "Strike price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426.Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
    [regulatoryReference JFSA Trade dataElement "75" field "Strike price - Remark"
        provision "In the case of over-the-counter derivatives transactions with a Strike Price schedule, report the Strike Price as of the commencement of the transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if GetStrikePriceNotationEnum = PriceNotationEnum -> Decimal
        then MultiplyPrice(cde.price.StrikePrice, GetStrikePriceNotationEnum)
        as "75 Strike Price (Decimal)"

reporting rule StrikePriceCurrencyCurrencyPair from TransactionReportInstruction: <"Strike price currency">
    [regulatoryReference JFSA Trade dataElement "76" field "Strike price currency"
        provision "For equity options, commodity options, and similar products, currency in which the strike price is denominated. For foreign exchange options: Currency pair and order in which the strike price is expressed. It is expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426. Strike price currency/currency pair is only applicable if Strike price notation = 1."]
    [regulatoryReference JFSA Trade dataElement "76" field "Strike price currency" footnote "1"
        provision "Note: For FX [Strike price notation] can only be reported with the value 3 Derived from CDE-Exchange rate basis currency"]
    filter IsAllowableActionForJFSA
    then cde.price.StrikePriceCurrency
        as "76 Strike price currency"

reporting rule StrikePriceNotation from TransactionReportInstruction: <"Strike price notation">
    [regulatoryReference JFSA Trade dataElement "77" field "Strike price notation"
        provision "Manner in which the Strike price is expressed."]
    filter IsAllowableActionForJFSA
    then extract GetNotationString(GetStrikePriceNotationEnum)
        as "77 Strike price notation"

reporting rule GetStrikePriceNotationEnum from TransactionReportInstruction: <"Strike price notation Enum">
    [regulatoryReference JFSA Trade dataElement "77" field "Strike price notation"
        provision "Manner in which the strike price is expressed."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a JFSA function which converts Percentage notation into Decimal."]
    filter IsAllowableActionForJFSA
    then if cde.price.StrikePriceNotationEnum = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else if cde.price.StrikePriceNotationEnum = PriceNotationEnum -> Monetary
                and IsFXOption(ProductForEvent)
        then PriceNotationEnum -> Decimal
        else cde.price.StrikePriceNotationEnum

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule StrikePriceSchedule from TransactionReportInstruction: <"Strike Price Schedule">
    [regulatoryReference JFSA Trade dataElement "78-80" field "Strike Price Schedule"
        provision "Fields 135-137 are repeatable and reportable for options, swaptions and similar products with strike prices varying throughout the life of the transaction. Strike price schedule is only applicable if the strike price varies per schedule. The currency for the varying strike prices in the schedule is reported in Strike price currency data element."]
    [regulatoryReference JFSA Trade dataElement "78-80" field "Strike Price Schedule - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    filter IsAllowableAction
    then extract GetReportableStrikePricePeriod
    then extract
        StrikePriceScheduleReport {
            effectiveDateStrikePrice: EffectiveDateStrikePrice,
            endDateStrikePrice: EndDateStrikePrice,
            strikePriceInEffectOnAssociatedEffectiveDateMonetary: StrikePriceInEffectOnAssociatedEffectiveDateMonetary,
            strikePriceInEffectOnAssociatedEffectiveDateDecimal: StrikePriceInEffectOnAssociatedEffectiveDateDecimal,
            strikePriceNotationInEffectOnAssociatedEffectiveDate: empty
        }
    then sort [ item -> effectiveDateStrikePrice ]

reporting rule EffectiveDateStrikePrice from PriceReportablePeriod: <"Effective date of the strike price">
    [regulatoryReference JFSA Trade dataElement "78" field "Effective date of the strike price"
        provision "Unadjusted effective date of the strike price."]
    [regulatoryReference JFSA Trade dataElement "78" field "Effective date of the strike price - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    cde.price.StrikePriceScheduleEffectiveDate
        as "78 Effective date of the strike price"

reporting rule EndDateStrikePrice from PriceReportablePeriod: <"End date of the strike price">
    [regulatoryReference JFSA Trade dataElement "79" field "End date of the strike price"
        provision "Unadjusted end date of the strike price (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    [regulatoryReference JFSA Trade dataElement "79" field "End date of the strike price - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are not possible with commodities being out of scope."]
    cde.price.StrikePriceScheduleEndDate
        as "79 End date of the strike price"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDateMonetary from PriceReportablePeriod: <"Strike price schedules - Strike price in effect between the unadjusted effective and end date">
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required. (Reporting is not required if Strike Price is not stated.)"]
    cde.price.StrikePriceScheduleAmountFormatMonetary
        as "78/80-$ 80 Strike price in effect between the unadjusted effective and end date (Monetary)"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDateDecimal from PriceReportablePeriod: <"Strike price schedules - Strike price in effect between the unadjusted effective and end date">
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required. (Reporting is not required if Strike Price is not stated.)"]
    cde.price.StrikePriceScheduleAmountFormatDecimal
        as "78/80-$ 80 Strike price in effect between the unadjusted effective and end date (Decimal)"

reporting rule StrikePriceNotationInEffectOnAssociatedEffectiveDate from PriceReportablePeriod: <"Strike price schedules - Strike price in effect between the unadjusted effective and end date">
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    [regulatoryReference JFSA Trade dataElement "80" field "Strike price in effect between the unadjusted effective and end date - Remark"
        provision "Applicable for products where the Strike price will vary throughout the life of transaction. For those products that are not applicable, reporting is not required. (Reporting is not required if Strike Price is not stated.)"]
    extract periodValue -> priceNotation
        as "78/80-$ 80 Strike price in effect between the unadjusted effective and end date (Non Reportable)"

reporting rule OptionPremiumAmount from TransactionReportInstruction: <"Option premium amount">
    [regulatoryReference JFSA Trade dataElement "81" field "Option premium amount"
        provision "For options and swaptions of all asset classes, monetary amount paid by the option buyer. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    filter IsAllowableActionForJFSA
    then cde.price.OptionPremiumAmount
        as "81 Option premium amount"

reporting rule OptionPremiumCurrency from TransactionReportInstruction: <"Option premium currency">
    [regulatoryReference JFSA Trade dataElement "82" field "Option premium currency"
        provision "For options and swaptions of all asset classes, currency in which the option premium amount is denominated. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    filter IsAllowableActionForJFSA
    then cde.price.OptionPremiumCurrency
        as "82 Option premium currency"

reporting rule OptionPremiumPaymentDate from TransactionReportInstruction: <"Option premium payment date">
    [regulatoryReference JFSA Trade dataElement "83" field "Option premium payment date"
        provision "Unadjusted date on which the option premium is paid."]
    [regulatoryReference JFSA Trade dataElement "83" field "Option premium payment date - Remark"
        provision "If option premiums are paid in installments, report the first payment date."]
    filter IsAllowableActionForJFSA
    then cde.price.OptionPremiumPaymentDate
        as "83 Option premium payment date"

reporting rule FirstExerciseDate from TransactionReportInstruction: <"First exercise date">
    [regulatoryReference JFSA Trade dataElement "84" field "First exercise date"
        provision "First unadjusted date during the exercise period in which an option can be exercised. For European-style options, this date is same as the Expiration date. For American-style options, the first possible exercise date is the unadjusted date included in the execution timestamp. For knock-in options, where the first exercise date is not known when a new transaction is reported, the first exercise date is updated as it becomes available. This data element is not applicable if the instrument is not an option or does not embed any optionality"]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then cde.price.FirstExerciseDate
        as "84 First exercise date"

reporting rule ExchangeRate from TransactionReportInstruction: <"Exchange rate">
    [regulatoryReference JFSA Trade dataElement "85" field "Exchange rate"
        provision "Exchange rate between the two different currencies specified in the OTC derivative transaction agreed by the counterparties at the inception of the transaction, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426."]
    filter IsAllowableActionForJFSA
    then cde.price.ExchangeRate
    then extract value
        as "85 Exchange rate"

reporting rule ExchangeRateBasis from TransactionReportInstruction: <"Exchange rate basis">
    [regulatoryReference JFSA Trade dataElement "86" field "Exchange rate basis"
        provision "Currency pair and order in which the exchange rate is denominated, expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426."]
    filter IsAllowableActionForJFSA
    then cde.price.ExchangeRate
    then cde.price.ExchangeRateBasis
        as "86 Exchange rate basis"

reporting rule NotionalLeg1 from TransactionReportInstruction: <"Notional of Leg 1"> //Naming convention made consistent with EMIR
    [regulatoryReference JFSA Trade dataElement "87" field "Notional amount"
        provision "For each leg of the transaction, where applicable:
        - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract.
        - for OTC derivative transactions negotiated in non-monetary amounts
        For OTC derivative transactions with a notional amount schedule, the initial notional amount, agreed by the counterparties at the inception of the transaction, is reported in this data element.
        For OTC foreign exchange options, in addition to this data element, the amounts are reported using the data elements Call amount and Put amount.
        For amendments or lifecycle events, the resulting outstanding notional amount is reported; (steps in notional amount schedules are not considered to be amendments or lifecycle events);
        Where the notional amount is not known when a new transaction is reported, the notional amount is updated as it becomes available."]
    [regulatoryReference JFSA Trade dataElement "87" field "Notional amount - Remark"
        provision "For products denominated in multiple currencies which are not netted (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    [regulatoryReference JFSA Trade dataElement "87" field "Notional amount" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then extract
        // Commodity Option
        if IsCommodityOption(ProductForTrade)
        then cde.quantity.CommodityOptionNotional(
                    tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                )
        // Credit swaption
        else if IsCreditSwaption(ProductForTrade)
        then cde.quantity.CreditNotional(
                    UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                )
        // FX forward and option
        else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
        then (if cde.quantity.FXNotional(FXLeg1(ProductForTrade)) = 0
            then 9999999999999999999999999
            else cde.quantity.FXNotional(FXLeg1(ProductForTrade)))
        // IR Swaption
        else if Qualify_InterestRate_Option_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then cde.quantity.InterestRateNotional(
                    InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                )
        // Equity options
        else if IsEquityOption(ProductForTrade)
        then cde.quantity.EquityOptionNotional(
                    EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout
                )
        // Equity forwards
        else if IsEquityForward(ProductForTrade)
        then cde.quantity.EquityForwardNotional(
                    EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout
                )
        // Equity
        else if IsEquity(ProductForTrade)
        then cde.quantity.PerformanceNotional(
                    EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                )
        // Credit
        else if IsCreditDefaultSwap(ProductForTrade)
        then cde.quantity.CreditNotional(
                    tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                )
        // Commodity fixed/float swaps
        else if Qualify_Commodity_Swap_FixedFloat(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then cde.quantity.CommodityNotional(
                    FixedPriceLeg1(tradableProduct -> product) -> priceQuantity -> quantitySchedule,
                    FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                )
        else if Qualify_Commodity_Swaption(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then cde.quantity.CommodityNotional(
                    FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> priceQuantity -> quantitySchedule,
                    FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                )
        // Commodity Basis
        else if Qualify_Commodity_Swap_Basis(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then (CommodityObservablePriceQuantity(
                tradableProduct -> tradeLot only-element,
                CommodityLeg1(ProductForTrade)
            ) -> quantity
            filter unit -> currency exists
            then extract value
            then only-element)
        // ZCS Known Amount
        else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
        then cde.quantity.InterestRateNotional(
                    InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                )
        // IR Swap
        else if Qualify_AssetClass_InterestRate(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then cde.quantity.InterestRateNotional(InterestRateLeg1(ProductForTrade))
        as "87 Notional Amount 1"

reporting rule NotionalLeg2 from TransactionReportInstruction: <"Notional of Leg 2"> //Naming convention made consistent with EMIR
    [regulatoryReference JFSA Trade dataElement "87" field "For each leg of the transaction, where applicable:
        - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract.
        - for OTC derivative transactions negotiated in non-monetary amounts

        For OTC derivative transactions with a notional amount schedule, the initial notional amount, agreed by the counterparties at the inception of the transaction, is reported in this data element.
        For OTC foreign exchange options, in addition to this data element, the amounts are reported using the data elements Call amount and Put amount.
        For amendments or lifecycle events, the resulting outstanding notional amount is reported; (steps in notional amount schedules are not considered to be amendments or lifecycle events);
        Where the notional amount is not known when a new transaction is reported, the notional amount is updated as it becomes available."]
    [regulatoryReference JFSA Trade dataElement "87" field "Notional amount - Remark"
        provision "For products denominated in multiple currencies which are not netted (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    [regulatoryReference JFSA Trade dataElement "87" field "Notional amount" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then extract trade [
        // Swaption
        ProductForTrade(trade) -> contractualProduct -> economicTerms
            extract
                if Qualify_InterestRate_Option_Swaption
                then cde.quantity.InterestRateNotional(
                            InterestRateLeg2(UnderlierForProduct(ProductForTrade(trade)))
                        )
                // FX Forward and option
                else if IsFXForward(ProductForTrade(trade))
                        or IsFXOption(ProductForTrade(trade))
                then (if cde.quantity.FXNotional(FXLeg2(ProductForTrade(trade))) = 0
                    then 9999999999999999999999999
                    else cde.quantity.FXNotional(FXLeg2(ProductForTrade(trade))))
                // Commodity Fixed/Float Swap
                else if Qualify_Commodity_Swap_FixedFloat
                then cde.quantity.CommodityNotional(
                            CommodityLeg2(ProductForTrade(trade)) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(ProductForTrade(trade)) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swap_Basis(
                            trade -> tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (CommodityObservablePriceQuantity(
                        trade -> tradableProduct -> tradeLot only-element,
                        CommodityLeg2(ProductForTrade(trade))
                    ) -> quantity
                    filter unit -> currency exists
                    then extract value
                    then only-element)
                // IR Swap, CDS, EQS
                else if Qualify_AssetClass_InterestRate(
                            EconomicTermsForProduct(ProductForTrade(trade))
                        )
                        or Qualify_AssetClass_Equity(
                                EconomicTermsForProduct(ProductForTrade(trade))
                            )
                then cde.quantity.InterestRateNotional(
                            InterestRateLeg2(ProductForTrade(trade))
                        )
    ]
        as "87 Notional Amount 2"

reporting rule CallAmount from TransactionReportInstruction: <"Call amount">
    [regulatoryReference JFSA Trade dataElement "88" field "Call amount"
        provision "For foreign exchange options, the monetary amount that the option gives the right to buy."]
    [regulatoryReference JFSA Trade dataElement "88" field "Call amount - Remark"
        provision "This item is limited to currency options for which there are call amounts and put amounts. Call Amount/Put Amount will report the same amount as Notional Amount - Leg1/Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    [regulatoryReference ISDA PeerReviewGroup date "20210120"
        provision "On full termination of a trade the Put Amount and Call Amount should be reported as the prior amount, in line with the Notional field."]
    filter IsAllowableActionForJFSA
    then if IsFXOption(ProductForEvent) then cde.quantity.CallAmount
        as "88 Call amount"

reporting rule PutAmount from TransactionReportInstruction: <"Put amount">
    [regulatoryReference JFSA Trade dataElement "89" field "Put amount"
        provision "For foreign exchange options, the monetary amount that the option gives the right to sell."]
    [regulatoryReference JFSA Trade dataElement "89" field "Put amount - Remark"
        provision "This item is limited to currency options for which there are call amounts and put amounts. Call Amount/Put Amount will report the same amount as Notional Amount - Leg1/Leg2."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    [regulatoryReference ISDA PeerReviewGroup date "20210120"
        provision "On full termination of a trade the Put Amount and Call Amount should be reported as the prior amount, in line with the Notional field."]
    filter IsAllowableActionForJFSA
    then if IsFXOption(ProductForEvent) then cde.quantity.PutAmount
        as "89 Put Amount"

reporting rule NotionalCurrencyOfLeg1 from TransactionReportInstruction: <"Notional currency-Leg 1">
    [regulatoryReference JFSA Trade dataElement "90" field "Notional currency"
        provision "For each Leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    [regulatoryReference JFSA Trade dataElement "90" field "Notional currency - Remark"
        provision "For products denominated in multiple currencies which are not netted (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    filter IsAllowableActionForJFSA
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then extract
        // Commodity Option
        if IsCommodityOption(ProductForTrade)
        then cde.quantity.OptionNotionalCurrency(
                    tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                )
        // Credit swaption
        else if Qualify_CreditDefaultSwaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then cde.quantity.CreditNotionalCurrency(
                    UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                )
        // FX forward and option
        else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
        then cde.quantity.FXNotionalCurrency(FXLeg1(ProductForTrade))
        // IR Swaption
        else if Qualify_InterestRate_Option_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then cde.quantity.InterestRateNotionalCurrency(
                    InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                )
        // Equity options or Interest Rate Debt Option
        // Monetary quantity schedule
        else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
        // Equity options or Interest Rate Debt Option
        // Non-monetary quantity schedule
        else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> unit -> currency
        // Equity forwards
        else if IsEquityForward(ProductForTrade)
        then (if EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
            then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
            else EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> priceSchedule only-element -> unit -> currency)
        // Equity
        else if IsEquity(ProductForTrade)
        then cde.quantity.PerformanceNotionalCurrency(
                    EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                )
        // Credit
        else if IsCreditDefaultSwap(ProductForTrade)
        then cde.quantity.CreditNotionalCurrency(
                    tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                )
        // Commodity fixed/float swaps
        else if Qualify_Commodity_Swap_FixedFloat(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then cde.quantity.CommodityNotionalCurrency(
                    FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                )
        else if Qualify_Commodity_Swaption(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then cde.quantity.CommodityNotionalCurrency(
                    FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                )
        // Commodity Basis
        else if Qualify_Commodity_Swap_Basis(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then (CommodityObservablePriceQuantity(
                tradableProduct -> tradeLot only-element,
                CommodityLeg1(ProductForTrade)
            ) -> quantity
            filter unit -> currency exists
            then extract unit -> currency
            then only-element)
        // ZCS Known Amount
        else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
        then cde.quantity.InterestRateNotionalCurrency(
                    InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                )
        // IR Swap
        else if Qualify_AssetClass_InterestRate(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then cde.quantity.InterestRateNotionalCurrency(InterestRateLeg1(ProductForTrade))
    then extract ConvertNonISOToISOCurrency
        as "90 Notional currency-Leg 1"

reporting rule NotionalCurrencyOfLeg2 from TransactionReportInstruction: <"Notional currency-Leg 2">
    [regulatoryReference JFSA Trade dataElement "90" field "Notional currency"
        provision "For each Leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    [regulatoryReference JFSA Trade dataElement "90" field "Notional currency - Remark"
        provision "For products denominated in multiple currencies which are not netted (i.e. currency swaps that exchange JPY and foreign currency), reporting data must consist of two separate records (receipt and payment)."]
    filter IsAllowableActionForJFSA
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then extract
        // IR Swaption and Credit Swaption
        if Qualify_InterestRate_Option_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then cde.quantity.InterestRateNotionalCurrency(
                    InterestRateLeg2(UnderlierForProduct(ProductForTrade))
                )
        // FX Forward and FX Option
        else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
        then cde.quantity.FXNotionalCurrency(FXLeg2(ProductForTrade))
        // Commodity fixed/float swaps
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FixedPriceLeg1(ProductForTrade) -> fixedPrice -> price -> unit -> currency
        else if Qualify_Commodity_Swap_Basis(
                    tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then (CommodityObservablePriceQuantity(
                tradableProduct -> tradeLot only-element,
                CommodityLeg1(ProductForTrade)
            ) -> quantity
            filter unit -> currency exists
            then extract unit -> currency
            then only-element)
        // IR, Credit and EQS
        else if Qualify_AssetClass_InterestRate(
                    EconomicTermsForProduct(tradableProduct -> product)
                )
                or Qualify_AssetClass_Equity(
                        EconomicTermsForProduct(tradableProduct -> product)
                    )
        then cde.quantity.InterestRateNotionalCurrency(InterestRateLeg2(ProductForTrade))
    then extract ConvertNonISOToISOCurrency
        as "90 Notional currency-Leg 2"

reporting rule CallCurrency from TransactionReportInstruction: <"Call currency">
    [regulatoryReference JFSA Trade dataElement "91" field "Call currency"
        provision "For foreign exchange options, the currency in which the Call amount is denominated."]
    [regulatoryReference JFSA Trade dataElement "91" field "Call currency - Remark"
        provision "If Call Amount and Put Amount are reported, call currency and put currency is expected to be reported for all option transactions."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    filter IsAllowableActionForJFSA
    then if IsFXOption(ProductForEvent) then cde.quantity.CallCurrency
        as "91 Call currency"

reporting rule PutCurrency from TransactionReportInstruction: <"Put currency">
    [regulatoryReference JFSA Trade dataElement "92" field "Put currency"
        provision "For foreign exchange options, the currency in which the Put amount is denominated."]
    [regulatoryReference JFSA Trade dataElement "92" field "Put currency - Remark"
        provision "If Call Amount and Put Amount are reported, call currency and put currency is expected to be reported for all option transactions."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    filter IsAllowableActionForJFSA
    then if IsFXOption(ProductForEvent) then cde.quantity.PutCurrency
        as "92 Put currency"

reporting rule QuantityUnitOfMeasureLeg1 from TransactionReportInstruction: <"Quantity unit of measure-Leg 1">
    [regulatoryReference JFSA Trade dataElement "93" field "Quantity unit of measure"
        provision "For each Leg of the transaction, where applicable: unit of measure in which the Total notional quantity and Notional quantity are expressed."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then CommodityLeg1(ProductForTrade) -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then EconomicTermsForProduct(ProductForTrade) -> payout -> fixedPricePayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsCommodityOption(tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityOption(ProductForTrade)
                and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityForward(ProductForTrade)
                and EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule
        else if EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquity(ProductForTrade)
                and tradableProduct -> tradeLot -> priceQuantity -> quantity -> unit -> financialUnit exists
        then (tradableProduct -> tradeLot only-element -> priceQuantity -> quantity
            then filter unit -> financialUnit exists
            then only-element)
    then extract cde.quantity.QuantityUnitOfMeasure
        as "93 Quantity unit of measure-Leg 1"

reporting rule QuantityUnitOfMeasureLeg2 from TransactionReportInstruction: <"Quantity unit of measure-Leg 2">
    [regulatoryReference JFSA Trade dataElement "93" field "Quantity unit of measure"
        provision "For each Leg of the transaction, where applicable: unit of measure in which the Total notional quantity and Notional quantity are expressed."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract
        if IsCommoditySwap(tradableProduct -> product)
        then CommodityLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
        else if IsEquity(ProductForTrade)
                and InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
    then extract cde.quantity.QuantityUnitOfMeasure
        as "93 Quantity unit of measure-Leg 2"

reporting rule NotionalAmountScheduleLeg1 from TransactionReportInstruction: <"Notional amount schedule-Leg 1">
    [regulatoryReference JFSA Trade dataElement "94-96" field "Notional amount schedule"
        provision "Fields 94-96 are repeatable and shall be populated in the case of derivatives involving notional amount schedules."]
    [regulatoryReference JFSA Trade dataElement "94-96" field "Notional amount schedule - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract GetLeg1ResolvablePriceQuantity -> quantitySchedule
    then filter unit -> currency exists
    then extract datedValue
    then extract notionalAmountPeriod [
        // use value and dates from quantity period
        QuantityReportablePeriod {
            periodValue: notionalAmountPeriod -> value,
            periodEffectiveDate: notionalAmountPeriod -> date,
            periodEndDate: empty
        }
    ]
    then extract
        NotionalAmountScheduleLeg1Report {
            amount: NotionalAmountScheduleLeg1Amount,
            effectiveDate: NotionalAmountScheduleLeg1EffectiveDate
        // endDate: cde.quantity.NotionalAmountScheduleEndDate - Unmodelled. Pls see the rationale below
        }
    then sort [ item -> effectiveDate ]

reporting rule NotionalAmountScheduleLeg2 from TransactionReportInstruction: <"Notional amount schedule-Leg 2">
    [regulatoryReference JFSA Trade dataElement "94-96" field "Notional amount schedule"
        provision "Fields 94-96 are repeatable and shall be populated in the case of derivatives involving notional amount schedules."]
    [regulatoryReference JFSA Trade dataElement "94-96" field "Notional amount schedule - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract GetLeg2ResolvablePriceQuantity -> quantitySchedule -> datedValue
    then extract notionalAmountPeriod [
        // use value and dates from quantity period
        QuantityReportablePeriod {
            periodValue: notionalAmountPeriod -> value,
            periodEffectiveDate: notionalAmountPeriod -> date,
            periodEndDate: empty
        }
    ]
    then extract
        NotionalAmountScheduleLeg2Report {
            amount: NotionalAmountScheduleLeg2Amount,
            effectiveDate: NotionalAmountScheduleLeg2EffectiveDate
        // endDate: cde.quantity.NotionalAmountScheduleEndDate - Unmodelled. Pls see the rationale below
        }
    then sort [ item -> effectiveDate ]

reporting rule NotionalAmountScheduleLeg1Amount from QuantityReportablePeriod: <"Notional amount schedule - Notional amount in effect on associated effective date-Leg 1">
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule:
            - Notional amount which becomes effective on the associated unadjusted effective date.
            The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
            This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary.
        For swaps involving accumulation and amortization of the notional amount:
        The initial notional amount agreed to by the parties at the commencement of the transaction is to be reported as Notional amount.
        In addition, Notional amount schedule etc. should be reported at the time of commencement of transactions.
        In the event of any subsequent changes to the schedule, report the changed notional amount schedule by selecting 'ACTION TYPE' to 'MODI' and 'EVENT TYPE' to 'TRAD'. (There is no need to change the Notional amount schedule, if there is no change from the original schedule)
        The initial notional amount reported at the start of the transaction will remain the same."]
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    cde.quantity.NotionalAmountScheduleAmount
        as "94/96-$ 94 Notional amount in effect on associated effective date-Leg 1"

reporting rule NotionalAmountScheduleLeg2Amount from QuantityReportablePeriod: <"Notional amount schedule - Notional amount in effect on associated effective date-Leg 2">
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule:
            - Notional amount which becomes effective on the associated unadjusted effective date.
            The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
            This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary.
        For swaps involving accumulation and amortization of the notional amount:
        The initial notional amount agreed to by the parties at the commencement of the transaction is to be reported as Notional amount.
        In addition, Notional amount schedule etc. should be reported at the time of commencement of transactions.
        In the event of any subsequent changes to the schedule, report the changed notional amount schedule by selecting 'ACTION TYPE' to 'MODI' and 'EVENT TYPE' to 'TRAD'. (There is no need to change the Notional amount schedule, if there is no change from the original schedule)
        The initial notional amount reported at the start of the transaction will remain the same."]
    [regulatoryReference JFSA Trade dataElement "94" field "Notional amount in effect on associated effective date" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    cde.quantity.NotionalAmountScheduleAmount
        as "94/96-$ 94 Notional amount in effect on associated effective date-Leg 2"

reporting rule NotionalAmountScheduleLeg1EffectiveDate from QuantityReportablePeriod: <"Notional amount schedule - Unadjusted effective date of the notional amount-Leg 1">
    [regulatoryReference JFSA Trade dataElement "95" field "Unadjusted effective date of the notional amount"
        provision "Unadjusted date on which the associated notional amount of leg 1 becomes effective."]
    [regulatoryReference JFSA Trade dataElement "95" field "Unadjusted effective date of the notional amount - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "94/96-$ 95 Unadjusted effective date of the notional amount-Leg 1"

reporting rule NotionalAmountScheduleLeg2EffectiveDate from QuantityReportablePeriod: <"Notional amount schedule - Unadjusted effective date of the notional amount-Leg 2">
    [regulatoryReference JFSA Trade dataElement "95" field "Unadjusted effective date of the notional amount"
        provision "Unadjusted date on which the associated notional amount of leg 2 becomes effective."]
    [regulatoryReference JFSA Trade dataElement "95" field "Unadjusted effective date of the notional amount - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "94/96-$ 95 Unadjusted effective date of the notional amount-Leg 2"

reporting rule NotionalAmountScheduleLeg1EndDate from QuantityReportablePeriod: <"End date of the notional amount of leg 1">
    [regulatoryReference JFSA Trade dataElement "96" field "Unadjusted end date of the notional amount"
        provision "Unadjusted end date of the notional amount (not applicable if the unadjusted end date of a given schedules period is back-to- back with the unadjusted effective date of the subsequent period).
                  The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
                  This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference JFSA Trade dataElement "96" field "Unadjusted end date of the notional amount - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are only possible for commodities, which are out of scope for this jurisdiction."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "94/96-$ 96 End date of the notional amount-Leg 1"

reporting rule NotionalAmountScheduleLeg2EndDate from QuantityReportablePeriod: <"End date of the notional amount of leg 2">
    [regulatoryReference JFSA Trade dataElement "96" field "Unadjusted end date of the notional amount"
        provision "Unadjusted end date of the notional amount (not applicable if the unadjusted end date of a given schedules period is back-to- back with the unadjusted effective date of the subsequent period).
                  The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
                  This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference JFSA Trade dataElement "96" field "Unadjusted end date of the notional amount - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in monetary amounts with a notional amount schedule, and the notional amount is expected vary."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are only possible for commodities, which are out of scope for this jurisdiction."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "94/96-$ 96 End date of the notional amount-Leg 2"

reporting rule TotalNotionalQuantityLeg1 from TransactionReportInstruction: <"Total notional quantity-Leg 1">
    [regulatoryReference JFSA Trade dataElement "97" field "Total notional quantity"
        provision "For each Leg of the transaction, where applicable: aggregate Notional quantity of the underlying asset of leg 1 for the term of the transaction.
            Where the Total notional quantity is not known when a new transaction is reported, the Total notional quantity is updated as it becomes available."]
    [regulatoryReference JFSA Trade dataElement "97" field "Total notional quantity" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    // todo: add coverage for equity swaps
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract
        if IsEquity(ProductForTrade) or IsEquityForward(ProductForTrade)
        then cde.quantity.EquityTotalNotionalQuantity(tradableProduct)
        else if IsCommoditySwapFloatFloat(ProductForTrade)
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg1(ProductForTrade))
        else if IsCommoditySwapFixedFloat(ProductForTrade)
        then cde.quantity.FixedPriceTotalNotionalQuantity(FixedPriceLeg1(ProductForTrade))
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then cde.quantity.CommodityTotalNotionalQuantity(
                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then cde.quantity.FixedPriceTotalNotionalQuantity(
                    FixedPriceLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then cde.quantity.OptionTotalNotionalQuantity(
                    ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                )
        as "97 Total notional quantity-Leg 1"

reporting rule TotalNotionalQuantityLeg2 from TransactionReportInstruction: <"Total notional quantity-Leg 2">
    [regulatoryReference JFSA Trade dataElement "97" field "Total notional quantity"
        provision "For each Leg of the transaction, where applicable: aggregate Notional quantity of the underlying asset of leg 2 for the term of the transaction.
            Where the Total notional quantity is not known when a new transaction is reported, the Total notional quantity is updated as it becomes available."]
    [regulatoryReference JFSA Trade dataElement "97" field "Total notional quantity" footnote "1"
        provision "Note: '9999999999999999999999999' is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    // todo: add coverage for equity swaps
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if IsCommoditySwap
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg2)
        else if IsEquity and InterestRateLeg2 -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then (InterestRateLeg2 -> priceQuantity -> quantitySchedule
            then extract
                if multiplier exists
                then value * multiplier -> value
                else value)
        as "97 Total notional quantity-Leg 2"

reporting rule NotionalQuantityScheduleLeg1 from TransactionReportInstruction: <"Notional Quantity Schedule-Leg 1">
    [regulatoryReference JFSA Trade dataElement "98-100" field "Notional Quantity Schedule"
        provision "Fields 98-100 are repeatable and shall be populated in the case of derivatives involving notional quantity schedules."]
    [regulatoryReference JFSA Trade dataElement "98-100" field "Notional Quantity Schedule - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract GetReportableQuantityPeriodLeg1
    then extract
        NotionalQuantityScheduleLeg1Report {
            effectiveDate: NotionalQuantityScheduleLeg1EffectiveDate,
            endDate: NotionalQuantityScheduleLeg1EndDate,
            value: NotionalQuantityScheduleLeg1Value
        }
    then sort [ item -> effectiveDate ]

reporting rule NotionalQuantityScheduleLeg1EffectiveDate from QuantityReportablePeriod: <"Notional quantity schedules - Unadjusted date on which the associated notional quantity becomes effective of leg 1">
    [regulatoryReference JFSA Trade dataElement "98" field "Notional quantity which becomes effective on the associated unadjusted effective date"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in non-monetary amounts with a Notional quantity schedule.
        Unadjusted date on which the associated notional quantity becomes effective
        The initial notional quantity and associated unadjusted effective and end date are be reported as the first values of the schedule.
        This data element is not applicable to OTC derivative transactions with notional quantities that are condition- or event-dependent.
        The quantity unit of measure for the varying notional quantities in the schedule is reported in Quantity unit of measure."]
    [regulatoryReference JFSA Trade dataElement "98" field "Notional quantity which becomes effective on the associated unadjusted effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    cde.quantity.NotionalQuantityScheduleEffectiveDate
        as "98/100-$ 98 Notional quantity schedules - Unadjusted date on which the associated notional quantity becomes effective of leg 1"

reporting rule NotionalQuantityScheduleLeg1EndDate from QuantityReportablePeriod: <"Notional quantity schedules - Unadjusted end date of the notional quantity of leg 1">
    [regulatoryReference JFSA Trade dataElement "99" field "Notional quantity schedules - Unadjusted end date of the notional quantity of leg 1"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in non-monetary amounts with a Notional quantity schedule.
        Unadjusted end date of the notional quantity
        (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period);
        The initial notional quantity and associated unadjusted effective and end date are be reported as the first values of the schedule.
        This data element is not applicable to OTC derivative transactions with notional quantities that are condition- or event-dependent.
        The quantity unit of measure for the varying notional quantities in the schedule is reported in Quantity unit of measure."]
    [regulatoryReference JFSA Trade dataElement "99" field "Notional quantity schedules - Unadjusted end date of the notional quantity of leg 1 - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are only possible for commodities, which are out of scope for this jurisdiction."]
    cde.quantity.NotionalQuantityScheduleEndDate
        as "98/100-$ 99 Notional quantity schedules - Unadjusted end date of the notional quantity of leg 1"

reporting rule NotionalQuantityScheduleLeg1Value from QuantityReportablePeriod: <"Notional quantity schedules - Notional quantity which becomes effective on the associated unadjusted effective date-Leg 1">
    [regulatoryReference JFSA Trade dataElement "100" field "Notional quantity which becomes effective on the associated unadjusted effective date"
        provision "Notional quantity which becomes effective on the associated unadjusted effective date."]
    [regulatoryReference JFSA Trade dataElement "100" field "Notional quantity which becomes effective on the associated unadjusted effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    cde.quantity.NotionalQuantityScheduleValue
        as "98/100-$ 100 Notional quantity which becomes effective on the associated unadjusted effective date-Leg 1"

reporting rule NotionalQuantityScheduleLeg2 from TransactionReportInstruction: <"Notional Quantity Schedule-Leg 2">
    [regulatoryReference JFSA Trade dataElement "98-100" field "Notional Quantity Schedule"
        provision "Fields 98-100 are repeatable and shall be populated in the case of derivatives involving notional quantity schedules."]
    [regulatoryReference JFSA Trade dataElement "98-100" field "Notional Quantity Schedule - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract GetReportableQuantityPeriodLeg2
    then extract
        NotionalQuantityScheduleLeg2Report {
            effectiveDate: NotionalQuantityScheduleLeg2EffectiveDate,
            endDate: NotionalQuantityScheduleLeg2EndDate,
            value: NotionalQuantityScheduleLeg2Value
        }
    then sort [ item -> effectiveDate ]

reporting rule NotionalQuantityScheduleLeg2EffectiveDate from QuantityReportablePeriod: <"Notional quantity schedules - Unadjusted date on which the associated notional quantity becomes effective of leg 2">
    [regulatoryReference JFSA Trade dataElement "98" field "Notional quantity which becomes effective on the associated unadjusted effective date"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in non-monetary amounts with a Notional quantity schedule.
        Unadjusted date on which the associated notional quantity becomes effective
        The initial notional quantity and associated unadjusted effective and end date are be reported as the first values of the schedule.
        This data element is not applicable to OTC derivative transactions with notional quantities that are condition- or event-dependent.
        The quantity unit of measure for the varying notional quantities in the schedule is reported in Quantity unit of measure."]
    [regulatoryReference JFSA Trade dataElement "98" field "Notional quantity which becomes effective on the associated unadjusted effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    cde.quantity.NotionalQuantityScheduleEffectiveDate
        as "98/100-$ 98 Notional quantity schedules - Unadjusted date on which the associated notional quantity becomes effective of leg 2"

reporting rule NotionalQuantityScheduleLeg2EndDate from QuantityReportablePeriod: <"Notional quantity schedules - Unadjusted end date of the notional quantity of leg 2">
    [regulatoryReference JFSA Trade dataElement "99" field "Notional quantity schedules - Unadjusted end date of the notional quantity of leg 2"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in non-monetary amounts with a Notional quantity schedule.
        Unadjusted end date of the notional quantity
        (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period);
        The initial notional quantity and associated unadjusted effective and end date are be reported as the first values of the schedule.
        This data element is not applicable to OTC derivative transactions with notional quantities that are condition- or event-dependent.
        The quantity unit of measure for the varying notional quantities in the schedule is reported in Quantity unit of measure."]
    [regulatoryReference JFSA Trade dataElement "99" field "Notional quantity schedules - Unadjusted end date of the notional quantity of leg 2 - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    [regulatoryReference ISDA PeerReviewGroup date "20240110"
        provision "End date fields are not required for JFSA since non-contiguous schedules are only possible for commodities, which are out of scope for this jurisdiction."]
    cde.quantity.NotionalQuantityScheduleEndDate
        as "98/100-$ 99 Notional quantity schedules - Unadjusted end date of the notional quantity of leg 2"

reporting rule NotionalQuantityScheduleLeg2Value from QuantityReportablePeriod: <"Notional quantity schedules - Notional quantity which becomes effective on the associated unadjusted effective date-Leg 2">
    [regulatoryReference JFSA Trade dataElement "100" field "Notional quantity which becomes effective on the associated unadjusted effective date"
        provision "Notional quantity which becomes effective on the associated unadjusted effective date."]
    [regulatoryReference JFSA Trade dataElement "100" field "Notional quantity which becomes effective on the associated unadjusted effective date - Remark"
        provision "Reported for over-the-counter derivative transactions negotiated in non-monetary amounts with a notional quantity schedule, and the notional quantity is expected to vary."]
    cde.quantity.NotionalQuantityScheduleValue
        as "98/100-$ 100 Notional quantity which becomes effective on the associated unadjusted effective date-Leg 2"

reporting rule ActionType from TransactionReportInstruction: <"Action Type">
    [regulatoryReference JFSA Trade dataElement "101" field "Action Type"
        provision "Type of action taken on the swap transaction or type of end-of-day reporting.
        Actions may include, but are not limited to, new, modify, correct, error, terminate, revive, transfer out, valuation, and collateral.
        New: An action that reports a new swap transaction. It applies to the first message relating to a new UTI.
        Modify: An action that modifies the state of a previously submitted transaction (e.g., credit event) or changes a term of a previously submitted transaction due to a newly negotiated modification (amendment) or updates previously missing information (e.g., post price swap). It does not include correction of a previous transaction.
        Correct: An action that corrects erroneous data of a previously submitted transaction.
        Error: An action of cancellation of a wrongly submitted entire transaction in case it never came into existence or was not subject to the reporting requirements but was reported erroneously, or a cancellation of duplicate report.
        Terminate: An action that closes an existing transaction because of a new event (e.g., Compression, Novation). This does not apply to transactions that terminate at contractual maturity date.
        Revive: An action that reinstates a swap transaction that was reported as error or terminated by mistake.
        Transfer out: An action that transfers swap transaction from one SDR to another SDR (change of swap data repository).
        Valuation: An update to valuation data. There will be no corresponding Event type.
        Collateral: An update to collateral margin data. There will be no corresponding Event type."]
    [regulatoryReference JFSA Trade dataElement "101" field "Action Type - Remark"
        provision "Status for reporting items such as 'LEI' and 'Confirm' could change during contract period. For those updates which does not involve contractual changes or error corrections, use Action Type: Modify.
        If New, Correct, or Modify occurs on the same day as the valuation for a same transaction, report the correction and valuation separately.
        [Specific example] (Specific example 1) Where an equity option transaction is knocked-out (currently reported as modify with a notional amount of 0)
        Report 'ACTION TYPE' as 'Terminate (TERM)' and 'EVENT TYPE' as 'Early Termination (EART)'.
        (Specific Example 2) Where a customer cancels an equity option transaction (currently reported as cancel) Report 'ACTION TYPE' as 'Terminate (TERM)' and 'EVENT TYPE' as 'Early Termination (EART)'.
        (Specific example 3) Exercise of equity option transactions (previously excluded from reporting) Report 'ACTION TYPE' as 'Terminate (TERM)' 'EVENT TYPE' as 'Exercise (EXER)'.
        In cases where the rights are exercised, it is expectd to be reported as 'Terminate' and 'Exercise'."]
    extract cde.event.ActionType
        as "101 Action type"

reporting rule EventType from TransactionReportInstruction: <"Event Type">
    [regulatoryReference JFSA Trade dataElement "102" field "Event Type"
        provision "Explanation or reason for the action being taken on the swap transaction. Events may include, but are not limited to, trade, novation, compression or risk reduction exercise, early termination, clearing, exercise, allocation, clearing and allocation, credit event, and transfer.
            - Trade: A creation, modification, or termination of a transaction.
            - Novation: A novation legally moves partial or all of the financial risks of a swap from a transferor to a transferee and has the effect of terminating/modifying the original transaction and creating a new transaction to identify the exposure between the transferor/transferee and remaining party.
            - Compression or Risk Reduction Exercise: Compressions and risk reduction exercises generally have the effect of terminating or modifying (i.e., reducing the notional value) a set of existing transactions and of creating a set of new transaction(s). These processes result in largely the same exposure of market risk that existed prior to the event for the counterparty.
            - Early termination: Termination of an existing swap transaction prior to scheduled termination or maturity date.
            - Clearing: Central clearing is a process where a derivatives clearing organization interposes itself between counterparties to contracts, becoming the buyer to every seller and the seller to every buyer. It has the effect of terminating an existing transaction between the buyer and the seller and thereby ensuring the performance of open contracts.
            - Exercise: The process by which a counterparty fully or partially exercises their rights specified in the contract of an option or a swaption.
            - Allocation: The process by which an agent, having facilitated a single swap transaction on behalf of several clients, allocates a portion of the executed swap to the clients.
            - Clearing and Allocation: A simultaneous clearing and allocation event in a derivatives clearing organization.
            - Credit event: An event or trigger that results in the modification of the state of a previously submitted credit derivative transaction. Applies only to credit derivatives.
            - Transfer: The process by which a swap is transferred to another SDR that  has the effect of the closing of the swap transaction at one SDR or opening of the same swap transaction using the same UTI/USI in a different SDR (new)."]
    [regulatoryReference ISDA PeerReviewGroup date "20230124"
        provision "Peer Review firms agreed to represent partial terminations using MODI and ETRM, thus aligning with EMIR, not CFTC."]
    extract reportableEvent [
        if (IsActionTypeCORR = False
                and IsActionTypeEROR = False
                and IsActionTypeREVI = False
                and IsActionTypePRTO = False
                and IsActionTypeVALU = False)
        then extract reportableEvent -> originatingWorkflowStep
            then if IsEventTypePTNG(reportableEvent) or IsActionTypePRTO(reportableEvent)
                then EventTypeEnum -> PTNG to-string
                else if IsEventTypeUPDT(reportableEvent)
                then EventTypeEnum -> UPDT to-string
                else if Qualify_Novation(businessEvent) = True
                        or Qualify_PartialNovation(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Novation
                then EventTypeEnum -> NOVA to-string
                else if Qualify_Allocation(businessEvent) = True
                        or Qualify_Reallocation(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Allocation
                then EventTypeEnum -> ALOC to-string
                else if Qualify_Exercise(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> OptionExercise
                then EventTypeEnum -> EXER to-string
                else if Qualify_ClearedTrade(businessEvent) = True
                        or workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
                        or businessEvent -> intent = EventIntentEnum -> Clearing
                then EventTypeEnum -> CLRG to-string
                else if Qualify_Compression(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Compression
                then EventTypeEnum -> COMP to-string
                else if Qualify_Termination(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> EarlyTerminationProvision
                        or Qualify_PartialTermination(businessEvent)
                then EventTypeEnum -> ETRM to-string
                else if Qualify_CreditEventDetermined(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> CreditEvent
                then EventTypeEnum -> CREV to-string
                else if Qualify_CorporateActionDetermined(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> CorporateActionAdjustment
                then EventTypeEnum -> CORP to-string
                else if Qualify_ContractFormation(businessEvent) = True
                        or Qualify_Increase(businessEvent) = True
                        or Qualify_Renegotiation(businessEvent) = True
                        or Qualify_IndexTransition(businessEvent) = True
                        or Qualify_FullReturn(businessEvent) = True
                        or businessEvent -> instruction -> primitiveInstruction -> quantityChange exists
                        or businessEvent -> instruction -> primitiveInstruction -> transfer exists
                        or businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment
                then EventTypeEnum -> TRAD to-string
    ]
        as "102 Event type"

reporting rule EventIdentifier from TransactionReportInstruction: <"Event identifier">
    [regulatoryReference JFSA Trade dataElement "103" field "Event identifier"
        provision "Unique identifier to link swap transactions resulting from an event may be, but is not limited to, compression, and credit event. The unique identifier may be assigned by the reporting counterparty or a service provider."]
    [regulatoryReference JFSA Trade dataElement "103" field "Event identifier - Remark"
        provision "This element is necessary as Prior UTIs cannot be used for compression and credit events. Any ID assigned by a service provider is expected to be reported. However if the assignment is done by the reporting counterparty, then it is not expected for the assigned ID to be shared between the parties to the transaction."]
    filter IsAllowableActionForJFSA
    then extract cde.event.EventIdentifier
        as "103 Event identifier"

reporting rule EventTimestamp from TransactionReportInstruction: <"Event Timestamp">
    [regulatoryReference JFSA Trade dataElement "104" field "Event Timestamp"
        provision "Date and time of occurrence of the event as determined by the reporting counterparty or a service provider.
        In the case of a clearing event, date and time when the original swap is accepted by the derivative clearing organization (DCO) for clearing and recorded by the DCOs system should be reported in this data element.
        The time element is as specific as technologically practicable."]
    [regulatoryReference JFSA Trade dataElement "104" field "Event Timestamp - Remark"
        provision "System input time, data generation time, and system connection time are to be considered as acceptable values. In addition, if determining the time up to the seconds is impossible due to system restrictions, setting the seconds to '00' shall be acceptable.
        Cancellation report of alpha - transactions by financial institutions do not necessarily have to match the date and time recorded by the central counterparty's system.
        The date and time recorded by the central counterparty's system will be submitted by the central counterparty when they report their  and  transactions."]
    filter IsAllowableActionForJFSA
    then extract cde.event.EventTimestamp
        as "104 Event timestamp"

reporting rule IndexFactor from TransactionReportInstruction: <"Index factor">
    [regulatoryReference JFSA Trade dataElement "105" field "Index factor"
        provision "The index version factor or percent, expressed as a decimal value, that multiplied by the Notional amount yields the notional amount covered by the seller of protection for credit default swap."]
    [regulatoryReference JFSA Trade dataElement "105" field "Index factor - Remark"
        provision "(Example) Gross Notional amount : JPY 1 billion
        Reference : Index comprised of 50 Japanese companies (iTraxx Japan) Notional amount for each company : JPY 20 million each Credit event settlement : <Credit event occur for company #1>
        Company #1 to settle for JPY 20 million
        Gross Notional amount reduced to 980 million yen, contract to be continued
        ->The INDEX Factor will become 98%. (Calculate notional amount after the credit event)
        INDEX Factor will be 100% at the start of the transaction, and will become Version2 notional/Version1 notional when the credit event occurs."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexFactor
        as "105 Index factor"

reporting rule EmbeddedOptionType from TransactionReportInstruction: <"Embedded option type">
    [regulatoryReference JFSA Trade dataElement "106" field "Embedded option type"
        provision "Type of option or optional provision embedded in a contract."]
    [regulatoryReference JFSA Trade dataElement "106" field "Embedded option type - Remark"
        provision "Embedded options are products that combines with other options, such as callable swaps."]
    [regulatoryReference ISDA USComplianceGroup date "20220519"
        provision "The US Compliance WG discussed #106 on May 19 WG call. The alternatives of the hierarchy (and OTHR were discussed (BNP and CS were on and assisted). 2 types of hierarchies were discussed
                - the one raised in Peer WG, and
                - one raised on the US WG call of a chronological (e.g. which came 1st).
            The consensus was that for cases where one option may have multiple provisions applicable, including the example of having both mandatory (MDET) and early termination (OPET) provisions applicable, the WG agreed to use the allowable value OTHR, rather than any hierarchy."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract tradableProduct -> product -> contractualProduct -> economicTerms
    then extract
        if terminationProvision -> extendibleProvision only exists
        then "EXTD"
        else if terminationProvision -> cancelableProvision only exists
        then "CANC"
        else if terminationProvision -> earlyTerminationProvision only exists
                and terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination only exists
        then "OPET"
        else if terminationProvision -> earlyTerminationProvision only exists
                and terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination only exists
        then "MDET"
        else if terminationProvision -> extendibleProvision exists
                or terminationProvision -> cancelableProvision exists
                or terminationProvision -> earlyTerminationProvision exists
        then "OTHR"
        as "106 Embedded option type"

reporting rule UPI from TransactionReportInstruction: <"UPI">
    [regulatoryReference JFSA Trade dataElement "107" field "UPI"
        provision "A unique set of characters that represents a particular OTC derivative."]
    [regulatoryReference JFSA Trade dataElement "107" field "UPI"
        provision "Reporting (including any amendments made on an existing trade), is required from April 7, 2025."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract tradableProduct -> product -> contractualProduct -> productIdentifier
    then filter source = ProductIdTypeEnum -> UPI
    then only-element
    then extract identifier
        as "107 UPI"

reporting rule DeliveryType from TransactionReportInstruction:
    [regulatoryReference JFSA Trade dataElement "108" field "Delivery Type"
        provision "Indicates whether the contract is settled physically or in cash."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract DeliveryTypeForProducts
        as "108 Delivery Type"

reporting rule AssetClass from TransactionReportInstruction: <"Asset Class">
    [regulatoryReference JFSA Trade dataElement "109" field "Asset Class"
        provision "Each reported contract shall be classified according to the asset class it is based on."]
    [regulatoryReference JFSA Trade dataElement "109" field "Asset Class - Remark"
        provision "When the underlying assets of the derivatives are cryptoassets: Select 'OTHR = Other'"]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract ProductForTrade -> contractualProduct -> economicTerms
    then extract
        if Qualify_AssetClass_InterestRate
        then "INTR"
        else if Qualify_AssetClass_Credit
        then "CRDT"
        else if Qualify_AssetClass_Equity
        then "EQUI"
        else if Qualify_AssetClass_ForeignExchange
        then "CURR"
        else "OTHR"
        as "109 Asset Class"

reporting rule UnderlyingIdentificationType from TransactionReportInstruction: <"Underlying identification type">
    [regulatoryReference JFSA Trade dataElement "110" field "Underlying identification type"
        provision "The type of relevant underlying identifier."]
    [regulatoryReference ISDA PeerReviewGroup date "20230426"
        provision "Regarding test samples of Equity baskets with a single index or a single security with an ISIN, the view of Credit Suisse's representative is that those samples are valid because they illustrate an acceptable boundary condition."]
    [regulatoryReference ISDA PeerReviewGroup date "20230426"
        provision "Regarding whether the underlying ISIN will always be used in EMIR reporting, the view of Credit Suisse's representative is that MIFID only accepts ISIN."]
    filter IsAllowableActionForJFSA
    then if GetUnderlyingIdentificationType exists
        then GetUnderlyingIdentificationType
        as "110 Underlying identification type"

reporting rule UnderlyingIdentification from TransactionReportInstruction: <"Underlying identification">
    [regulatoryReference JFSA Trade dataElement "111" field "Underlying identification"
        provision "The direct underlying shall be identified by using a unique identification for this underlying based on its type. For Credit Default Swaps, the ISIN of the reference obligation should be provided."]
    [regulatoryReference JFSA Trade dataElement "111" field "Underlying identification - Remark"
        provision "If the reference asset is an index without ISIN, report the asset under 'Indicator of the underlying index'."]
    filter IsAllowableActionForJFSA
    then extract
        (if IsCreditSwaption(ProductForEvent) or IsIRSwaption(ProductForEvent)
        then UnderlierForProduct(ProductForEvent)
        else ProductForEvent)
    then extract
        // Underlying Identification Type = I for ISIN
        if UnderlierForProduct -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if UnderlierForProduct -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and UnderlierForProduct -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (UnderlierForProduct -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if UnderlierForProduct -> contractualProduct -> productIdentifier exists
                and UnderlierForProduct -> contractualProduct -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        // IR on bond
        else if (EconomicTermsForProduct -> payout -> interestRatePayout -> bondReference -> bond exists and EconomicTermsForProduct -> payout -> interestRatePayout -> bondReference -> bond -> source all <> ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> interestRatePayout -> bondReference -> bond
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        // Underlying Identification Type = X for Index
        else if UnderlierForProduct -> index exists
        then (UnderlierForProduct -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if IsFRA
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId
        // Underlying Identification Type = B
        else if UnderlierForProduct -> basket exists
        then (UnderlierForProduct -> basket -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> basket exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> basket -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
        then ([EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId first, EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexReferenceInformation -> indexId first] only-element)
    then last
        as "111 Underlying identification"

reporting rule UnderlyingIndexIndicator from TransactionReportInstruction: <"Indicator of the underlying index">
    [regulatoryReference JFSA Trade dataElement "112" field "Indicator of the underlying index"
        provision "An indication of the underlying index, where available."]
    [regulatoryReference JFSA Trade dataElement "112" field "Indicator of the underlying index - Remark"
        provision "If the indicator of the underlying index does not exist in the list, report the index using the 'Name of the underlying index'."]
    filter IsAllowableActionForJFSA
    then extract
        (if IsCreditSwaption(ProductForEvent) or IsIRSwaption(ProductForEvent)
        then UnderlierForProduct(ProductForEvent)
        else ProductForEvent)
    then extract
        if contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then UnderlierForProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> index exists
                and UnderlierForProduct -> index -> productIdentifier -> source any = ProductIdTypeEnum -> Name
        then (UnderlierForProduct -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if contractualProduct -> economicTerms -> payout -> performancePayout -> underlier -> index exists
        then (contractualProduct -> economicTerms -> payout -> performancePayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if contractualProduct -> economicTerms -> payout -> commodityPayout -> underlier -> index exists
        then (contractualProduct -> economicTerms -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if IsFRA
        then contractualProduct -> economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex
            first
            to-string
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex
            first
            to-string
    then extract GetIndexIndicatorFromFloatingRate
    then distinct only-element
        as "112 Indicator of the underlying index"

reporting rule NameOfTheUnderlyingIndex from TransactionReportInstruction: <"Name of the underlying index">
    [regulatoryReference JFSA Trade dataElement "113" field "Name of the underlying index"
        provision "The full name of the underlying index as assigned by the index provider."]
    [regulatoryReference JFSA Trade dataElement "113" field "Name of the underlying index - Remark"
        provision "If the indicator of the underlying index does not exist in the list, report the full name of the index here."]
    filter IsAllowableActionForJFSA
    then extract
        (if IsCreditSwaption(ProductForEvent) or IsIRSwaption(ProductForEvent)
        then UnderlierForProduct(ProductForEvent)
        else ProductForEvent)
    then extract
        if contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then UnderlierForProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> index exists
                and UnderlierForProduct -> index -> productIdentifier -> source any = ProductIdTypeEnum -> Name
        then (UnderlierForProduct -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if contractualProduct -> economicTerms -> payout -> performancePayout -> underlier -> index exists
        then (contractualProduct -> economicTerms -> payout -> performancePayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if contractualProduct -> economicTerms -> payout -> commodityPayout -> underlier -> index exists
        then (contractualProduct -> economicTerms -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if IsFRA
        then contractualProduct -> economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName
            first
            to-string
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
        then ([EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName first, EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexReferenceInformation -> indexName first] only-element)
            to-string
    then distinct only-element
        as "113 Name of the underlying index"

reporting rule ReferenceEntity from TransactionReportInstruction: <"Reference entity">
    [regulatoryReference JFSA Trade dataElement "114" field "Reference entity"
        provision "Identification of the underlying reference entity."]
    filter IsAllowableActionForJFSA
    then extract
        if UnderlyingIdentificationType is absent // DTCC_JFSA_BR_0114_01
        then ExtractReferenceEntity
        as "114 Reference entity"

reporting rule IndicatorOfTheFloatingRateOfLeg1 from TransactionReportInstruction: <"Indicator of the floating rate-Leg 1">
    [regulatoryReference JFSA Trade dataElement "115" field "Indicator of the floating rate"
        provision "An indication of the interest rate, where available."]
    [regulatoryReference JFSA Trade dataElement "115" field "Indicator of the floating rate - Remark"
        provision "If the floating rate index does not exist in the list, report the index using the 'Name of the floating rate'."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption
    then extract item -> floatingRateIndex to-string
    then extract GetIndexIndicatorFromFloatingRate
        as "115 Indicator of the floating rate-Leg 1"

reporting rule IndicatorOfTheFloatingRateOfLeg2 from TransactionReportInstruction: <"Indicator of the floating rate-Leg 2">
    [regulatoryReference JFSA Trade dataElement "115" field "Indicator of the floating rate"
        provision "An indication of the interest rate, where available."]
    [regulatoryReference JFSA Trade dataElement "115" field "Indicator of the floating rate - Remark"
        provision "If the floating rate index does not exist in the list, report the index using the 'Name of the floating rate'."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption
    then extract item -> floatingRateIndex to-string
    then extract GetIndexIndicatorFromFloatingRate
        as "115 Indicator of the floating rate-Leg 2"

reporting rule NameOfTheFloatingRateOfLeg1 from TransactionReportInstruction: <"Name of the Floating Rate of Leg 1">
    [regulatoryReference JFSA Trade dataElement "116" field "Name of the Floating Rate of Leg 1"
        provision "The full name of the interest rate as assigned by the index provider."]
    [regulatoryReference JFSA Trade dataElement "116" field "Name of the Floating Rate of Leg 1 - Remark"
        provision "Use this item when the Indicator of the floating rate does not include a floating rate index to be reported."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract GetNameOfTheFloatingRateOfLeg1
        as "116 Name of the Floating Rate of Leg 1"

reporting rule NameOfTheFloatingRateOfLeg2 from TransactionReportInstruction: <"Name of the Floating Rate of Leg 2">
    [regulatoryReference JFSA Trade dataElement "116" field "Name of the Floating Rate of Leg 2"
        provision "The full name of the interest rate as assigned by the index provider."]
    [regulatoryReference JFSA Trade dataElement "116" field "Name of the Floating Rate of Leg 2 - Remark"
        provision "Use this item when the Indicator of the floating rate does not include a floating rate index to be reported."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract GetNameOfTheFloatingRateOfLeg2
        as "116 Name of the Floating Rate of Leg 2"

reporting rule FloatingRateReferencePeriodOfLeg1TimePeriod from TransactionReportInstruction: <"Floating rate reference period - time period-Leg 1">
    [regulatoryReference JFSA Trade dataElement "117" field "Floating rate reference period - time period"
        provision "Time period describing the reference period for the floating rate of Leg 1."]
    [regulatoryReference ISDA PeerReviewGroup date "20231115"
        provision "The codes ADHO and EXPI are not supported on the basis that pertinent business scenarios remain unclear for these values and it has not been possible to elect the relevant logic. Further enhancements will be addressed once clear guidance or examples come forth."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption -> indexTenor -> period
    then extract FloatingReferencePeriod
        as "117 Floating rate reference period - time period-Leg 1"

reporting rule FloatingRateReferencePeriodOfLeg2TimePeriod from TransactionReportInstruction: <"Floating rate reference period - time period-Leg 2">
    [regulatoryReference JFSA Trade dataElement "117" field "Floating rate reference period - time period"
        provision "Time period describing the reference period for the floating rate of Leg 2."]
    [regulatoryReference ISDA PeerReviewGroup date "20231115"
        provision "The codes ADHO and EXPI are not supported on the basis that pertinent business scenarios remain unclear for these values and it has not been possible to elect the relevant logic. Further enhancements will be addressed once clear guidance or examples come forth."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption -> indexTenor -> period
    then extract FloatingReferencePeriod
        as "117 Floating rate reference period - time period-Leg 2"

reporting rule FloatingRateReferencePeriodOfLeg1Multiplier from TransactionReportInstruction: <"Floating rate reference period - multiplier-Leg 1">
    [regulatoryReference JFSA Trade dataElement "118" field "Floating rate reference period - multiplier"
        provision "Multiplier of the time period describing the reference period for the floating rate of Leg 1."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption -> indexTenor -> periodMultiplier
        as "118 Floating rate reference period - multiplier-Leg 1"

reporting rule FloatingRateReferencePeriodOfLeg2Multiplier from TransactionReportInstruction: <"118 Floating rate reference period - multiplier-Leg 2">
    [regulatoryReference JFSA Trade dataElement "118" field "Floating rate reference period - multiplier"
        provision "Multiplier of the time period describing the reference period for the floating rate of Leg 2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption -> indexTenor -> periodMultiplier
        as "118 Floating rate reference period - multiplier-Leg 2"

reporting rule DerivativeBasedOnCryptoAssets from TransactionReportInstruction: <"Derivative based on crypto-assets">
    [regulatoryReference JFSA Trade dataElement "119" field "Derivative based on crypto-assets"
        provision "Indicator whether the derivative is based on crypto-assets."]
    filter IsAllowableActionForJFSA
    then extract
        if reportableInformation -> cryptoBased exists
        then reportableInformation -> cryptoBased
        else False
        as "119 Derivative based on crypto-assets"

reporting rule MaturityDateOfTheUnderlying from TransactionReportInstruction: <"Maturity date of the underlying">
    [regulatoryReference JFSA Trade dataElement "120" field "Maturity date of the underlying"
        provision "In case of swaptions, maturity date of the underlying swap."]
    [regulatoryReference JFSA Trade dataElement "120" field "Maturity date of the underlying - Remark"
        provision "Reported for swaptions only."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if IsIRSwaption or IsCreditSwaption
        then cde.datetime.ExpirationDate(UnderlierForProduct)
        as "120 Maturity date of the underlying"

reporting rule Seniority from TransactionReportInstruction: <"Seniority">
    [regulatoryReference JFSA Trade dataElement "121" field "Seniority"
        provision "Indicates the seniority of the debt security, or debt basket or index underlying a derivative."]
    filter IsAllowableActionForJFSA
    then extract GetSeniority
        as "121 Seniority"

reporting rule Series from TransactionReportInstruction: <"Series">
    [regulatoryReference JFSA Trade dataElement "122" field "Series"
        provision "The series number of the composition of the index if applicable."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexSeries
        as "122 Series"

reporting rule Version from TransactionReportInstruction: <"Version">
    [regulatoryReference JFSA Trade dataElement "123" field "Version"
        provision "A new version of a series is issued if one of the constituents defaults and the index has to be reweighted to account for the new number of total constituents within the index."]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexAnnexVersion
        as "123 Version"

reporting rule CDSIndexAttachmentPoint from TransactionReportInstruction: <"CDS index attachment point">
    [regulatoryReference JFSA Trade dataElement "124" field "CDS index attachment point"
        provision "Defined lower point at which the level of losses in the underlying portfolio reduces the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% will be reduced after 3% of losses in the portfolio have occurred. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    filter IsAllowableActionForJFSA
    then cde.index.CDSIndexAttachmentPoint
        as "124 CDS index attachment point"

reporting rule CDSIndexDetachmentPoint from TransactionReportInstruction: <"CDS index detachment point">
    [regulatoryReference JFSA Trade dataElement "125" field "CDS index detachment point"
        provision "Defined point beyond which losses in the underlying portfolio no longer reduce the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% and a detachment point of 6% will be reduced after there have been 3% of losses in the portfolio. 6% losses in the portfolio deplete the notional of the tranche. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    filter IsAllowableActionForJFSA
    then cde.index.CDSIndexDetachmentPoint
        as "125 CDS index detachment point"

reporting rule CustomBasketCode from TransactionReportInstruction: <"Custom basket code">
    [regulatoryReference JFSA Trade dataElement "126" field "Custom basket code"
        provision "If the derivative transaction is based on a custom basket, unique code assigned by the structurer of the custom basket to link its constituents. This data element is not applicable if no custom basket is involved or no unique code has been assigned to it."]
    [regulatoryReference JFSA Trade dataElement "126" field "Custom basket code - Remark"
        provision "A custom basket should be used for any asset class which refers to multiple indices (i.e. first to default, rainbow options, etc.)."]
    filter IsAllowableActionForJFSA
    then extract cde.basket.CustomBasketCode
        as "126 Custom basket code"

reporting rule BasketConstituents from TransactionReportInstruction: <"Basket's constituents">
    [regulatoryReference JFSA Trade dataElement "127-128" field "Identifier of the basket's constituents"
        provision "Field 127 and 128 are repeatable and shall be populated in case there is a basket with constituents."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract GetBasketConstituentsProductIdentifier
    then extract
        BasketConstituentsReport {
            identifier: IdentifierOfBasketConstituents,
            source: BasketConstituentIdentifierSource
        }

reporting rule IdentifierOfBasketConstituents from ProductIdentifier: <"Identifier of the basket's constituents">
    [regulatoryReference JFSA Trade dataElement "127" field "Identifier of the basket's constituents"
        provision "Underliers that represent the constituents of a custom basket, in line with the underlier ID within the UPI reference data elements, as defined by the CPMI-IOSCO Technical Guidance: Harmonisation of the Unique Product Identifier. This data element is not applicable if no custom basket is involved."]
    extract identifier
        as "127 Identifier of the basket's constituents"

reporting rule BasketConstituentIdentifierSource from ProductIdentifier: <"Basket constituent identifier source">
    [regulatoryReference JFSA Trade dataElement "128" field "Basket constituent identifier source"
        provision "Source of the underliers identifiers that represent the constituents of a custom basket. This data element is not applicable if no custom basket is involved."]
    extract source
        as "128 Basket constituent identifier source"

reporting rule ContractType from TransactionReportInstruction: <"Contract Type">
    [regulatoryReference JFSA Trade dataElement "129" field "Contract Type"
        provision "Each reported contract shall be classified according to its type."]
    [regulatoryReference ISDA PeerReviewGroup date "20230920"
        provision "SPDB and CFDS output values will not be supported in DRR until CDM is able to functionally qualify them as distinct products. The qualification of these products needs to be backed by transaction or reporting samples provided by DRR firms."]
    [regulatoryReference ISDA PeerReviewGroup date "20230920"
        provision "OTHR is populated if none of the possible outputs are a precise fit"]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract
        if IsFRA
        then "FRAS"
        else if Qualify_ForeignExchange_Spot_Forward(contractualProduct -> economicTerms)
                or Qualify_ForeignExchange_NDF(contractualProduct -> economicTerms)
        then "FORW"
        else if IsIRSwaption or IsCreditSwaption
        then "SWPT"
        else if Qualify_InterestRate_CapFloor(EconomicTermsForProduct)
                or EconomicTermsForProduct -> payout -> optionPayout only exists or IsProductETD
        then "OPTN"
        else if Qualify_BaseProduct_IRSwap(contractualProduct -> economicTerms)
                or Qualify_BaseProduct_Inflation(contractualProduct -> economicTerms)
                or Qualify_BaseProduct_CrossCurrency(contractualProduct -> economicTerms)
                or Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(
                        contractualProduct -> economicTerms
                    )
                or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                        contractualProduct -> economicTerms
                    )
                or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(
                        contractualProduct -> economicTerms
                    )
                or Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(
                        contractualProduct -> economicTerms
                    )
                or Qualify_AssetClass_Credit(contractualProduct -> economicTerms)
                or Qualify_BaseProduct_EquitySwap(contractualProduct -> economicTerms)
                or Qualify_Commodity_Swap_FixedFloat(contractualProduct -> economicTerms)
                or Qualify_Commodity_Swap_Basis(contractualProduct -> economicTerms)
                or Qualify_ForeignExchange_Swap(contractualProduct -> economicTerms)
                or contractualProduct -> economicTerms -> payout -> performancePayout only exists
        then "SWAP"
        else if IsProductETD and EconomicTermsForProduct -> payout -> forwardPayout only exists
        then "FUTR"
        else "OTHR"
        as "129 Contract Type"

reporting rule OptionStyle from TransactionReportInstruction: <"Option style">
    [regulatoryReference JFSA Trade dataElement "130" field "Option style"
        provision "Indicates whether the option may be exercised only at a fixed date (European), a series of pre-specified dates (Bermudan) or at any time during the life of the contract (American)."]
    [regulatoryReference JFSA Trade dataElement "130" field "Option style - Remark"
        provision "For Caps and Floors, report 'EURO'."]
    filter IsAllowableActionForJFSA
    then extract TradeForEvent
    then extract tradableProduct -> product
    then extract
        if IsFloor or IsCap
        then "EURO"
        else if IsOption
        then (contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> optionStyle
            extract
                if americanExercise exists
                then "AMER"
                else if europeanExercise exists
                then "EURO"
                else if bermudaExercise exists
                then "BERM")
        as "130 Option style"

reporting rule OptionType from TransactionReportInstruction: <"Option type">
    [regulatoryReference JFSA Trade dataElement "131" field "Option type"
        provision "Indication as to whether the derivative contract is a call (right to purchase a specific underlying asset) or a put (right to sell a specific underlying asset) or whether it cannot be determined whether it is a call or a put at the time of execution of the derivative contract.
			In case of swaptions it shall be:
				- Put, in case of receiver swaption, in which the buyer has the right to enter into a swap as a fixed-rate receiver.
				- Call, in case of payer swaption, in which the buyer has the right to enter into a swap as a fixed-rate payer.
			In case of Caps and Floors it shall be:
				- Put, in case of a Floor.
				- Call, in case of a Cap"]
    filter IsAllowableActionForJFSA
    then extract ProductForEvent
    then extract cde.link.UPIOptionType
        as "131 Option type"

reporting rule PackageIdentifier from TransactionReportInstruction: <"Package identifier">
    [regulatoryReference JFSA Trade dataElement "132" field "Package identifier"
        provision "Identifier (determined by the reporting counterparty) in order to connect two or more transactions that are reported separately by the reporting counterparty, but that are negotiated together as the product of a single economic agreement. Two or more reports pertaining to the same transaction whenever jurisdictional reporting requirement does not allow the transaction to be reported with a single report to TRs. A package may include reportable and non-reportable transactions. This data element is not applicable  if no package is involved, or  to allocations. Where the Package identifier is not known when a new transaction is reported, the Package identifier is updated as it becomes available."]
    [regulatoryReference JFSA Trade dataElement "132" field "Package identifier - Remark"
        provision "It shall be a unique identifier. It is not expected to be shared with the parties involved in the transaction."]
    filter IsAllowableActionForJFSA
    then extract
        if GetPackageInformation exists then GetPackageInformation
    then cde.link.PackageIdentifier
    then only-element
        as "132 Package identifier"

reporting rule PackageTransactionPriceMonetary from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component. This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency, Price notation, Price unit of measure) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.PackageTransactionPrice, PriceNotationEnum -> Monetary)
        as "133 Package Transaction Price (Monetary)"

reporting rule PackageTransactionPriceDecimal from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component. This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency, Price notation, Price unit of measure) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Percentage
                or cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Decimal
        then MultiplyPrice(cde.price.PackageTransactionPrice, PriceNotationEnum -> Decimal)
        as "133 Package Transaction Price (Decimal)"

reporting rule PackageTransactionPriceBasis from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component. This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency, Price notation, Price unit of measure) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    [regulatoryReference JFSA Trade dataElement "133" field "Package transaction price" footnote "1"
        provision "Note: '999999999999999999' (for Monetary values) or '99999999999' (for Decimal) is accepted when the value is not available at the time of reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Basis
        then MultiplyPrice(cde.price.PackageTransactionPrice, PriceNotationEnum -> Basis)
        as "133 Package Transaction Price (Basis)"

reporting rule PackageTransactionPriceCurrency from TransactionReportInstruction: <"Package transaction price currency">
    [regulatoryReference JFSA Trade dataElement "134" field "Package transaction price currency"
        provision "Currency in which the Package transaction price is denominated. This data element is not applicable if no package is involved, or package transaction spread is used, or package transaction price notation = 3"]
    extract cde.price.PackageTransactionPriceCurrency
        as "134 Package transaction price currency"

reporting rule GetPackageTransactionPriceNotationEnum from TransactionReportInstruction: <"Package transaction price notation Enum">
    [regulatoryReference JFSA Trade dataElement "135" field "Package transaction price notation"
        provision "Manner in which the Package transaction price is expressed. This data element is not applicable if no package is involved, or package transaction spread is used"]
    filter IsAllowableActionForJFSA
    then if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else cde.price.PackageTransactionPriceNotationEnum

reporting rule PackageTransactionPriceNotation from TransactionReportInstruction: <"Package transaction price notation">
    [regulatoryReference JFSA Trade dataElement "135" field "Package transaction price notation"
        provision "Manner in which the Package transaction price is expressed. This data element is not applicable if no package is involved, or package transaction spread is used"]
    filter IsAllowableActionForJFSA
    then extract cde.price.PackageTransactionPriceNotation
        as "135 Package Transaction Price Notation"

reporting rule PackageTransactionSpreadMonetary from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference JFSA Trade dataElement "136" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if no package is involved, or Package transaction price is used. Spread and related data elements of the transactions (spread currency, Spread notation) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(
                    cde.price.PackageTransactionSpread,
                    PriceNotationEnum -> Monetary
                )
        as "136 Package transaction spread (Monetary)"

reporting rule PackageTransactionSpreadDecimal from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference JFSA Trade dataElement "136" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if no package is involved, or Package transaction price is used. Spread and related data elements of the transactions (spread currency, Spread notation) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Percentage
                or cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Decimal
        then MultiplyPrice(cde.price.PackageTransactionSpread, PriceNotationEnum -> Decimal)
        as "136 Package transaction spread (Decimal)"

reporting rule PackageTransactionSpreadBasis from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference JFSA Trade dataElement "136" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if no package is involved, or Package transaction price is used. Spread and related data elements of the transactions (spread currency, Spread notation) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableActionForJFSA
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Basis
        then MultiplyPrice(cde.price.PackageTransactionSpread, PriceNotationEnum -> Basis)
        as "136 Package transaction spread (Basis)"

reporting rule PackageTransactionSpreadCurrency from TransactionReportInstruction: <"Package transaction spread currency">
    [regulatoryReference JFSA Trade dataElement "137" field "Package transaction spread currency"
        provision "Currency in which the Package transaction spread is denominated. This data element is not applicable if no package is involved, or Package transaction price is used, or Package transaction spread notation = 3, or = 4"]
    filter IsAllowableActionForJFSA
    then extract cde.price.PackageTransactionSpreadCurrency
        as "137 Package transaction spread currency"

reporting rule GetPackageTransactionSpreadNotationEnum from TransactionReportInstruction: <"Package transaction spread notation Enum">
    [regulatoryReference JFSA Trade dataElement "138" field "Package transaction spread notation"
        provision "Manner in which the Package transaction spread is expressed. This data element is not applicable if no package is involved, or Package transaction price is used."]
    filter IsAllowableActionForJFSA
    then if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else cde.price.PackageTransactionSpreadNotationEnum

reporting rule PackageTransactionSpreadNotation from TransactionReportInstruction: <"Package transaction spread notation">
    [regulatoryReference JFSA Trade dataElement "138" field "Package transaction spread notation"
        provision "Manner in which the Package transaction spread is expressed. This data element is not applicable if no package is involved, or Package transaction price is used."]
    filter IsAllowableActionForJFSA
    then extract cde.price.PackageTransactionSpreadNotation
        as "138 Package transaction spread notation"

reporting rule TechnicalRecordId from TransactionReportInstruction: <"Technical Record Id (ISO)">
    [regulatoryReference JFSA Trade dataElement "[Internal]" field "Technical Record Id (ISO)"
        provision "Unique technical identification of the original data for which the status is provided for the BDR. Not sent to JFSA."]
    extract reportableInformation -> partyInformation -> regimeInformation
    then filter regimeName = RegimeNameEnum -> JFSA
    then extract technicalRecordId
    then distinct only-element
        as "[Internal] Technical Record Id (ISO)"

reporting rule SingleBarrierPriceNotation from TransactionReportInstruction: <"Single barrier price notation">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Single barrier price notation"
        provision "Manner in which the Single barrier price is expressed."]
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Single barrier price notation" footnote "1"
        provision "Note: For FX [Single barrier price notation] can only be reported with the value 3"]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if (EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                        and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut is absent)
                    or (EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn is absent
                        and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists)
            then (if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                        or EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
                then PriceNotationEnum -> Monetary
                else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> levelPercentage exists
                        or EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> levelPercentage exists
                then PriceNotationEnum -> Decimal)
        as "[Not in regulation] Single barrier price notation"

reporting rule LowerBarrierPriceNotation from TransactionReportInstruction: <"Lower barrier price notation">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Lower barrier price notation"
        provision "Manner in which the Lower barrier price is expressed."]
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Lower barrier price notation" footnote "1"
        provision "Note: For FX [Lower barrier price notation] can only be reported with the value 3"]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if (EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists)
            then (if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                        or EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
                then PriceNotationEnum -> Monetary
                else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> levelPercentage exists
                        or EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> levelPercentage exists
                then PriceNotationEnum -> Decimal)
        as "[Not in regulation] Lower barrier price notation"

reporting rule UpperBarrierPriceNotation from TransactionReportInstruction: <"Upper barrier price notation">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Upper barrier price notation"
        provision "Manner in which the Upper barrier price is expressed."]
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Upper barrier price notation" footnote "1"
        provision "Note: For FX [Upper barrier price notation] can only be reported with the value 3"]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if (EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists)
            then (if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                        and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
                then PriceNotationEnum -> Monetary
                else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> levelPercentage exists
                        and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> levelPercentage exists
                then PriceNotationEnum -> Decimal)
        as "[Not in regulation] Upper barrier price notation"

reporting rule SingleBarrierPriceMonetary from TransactionReportInstruction: <"Single barrier price - Monetary">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Single barrier price"
        provision "For a barrier option involving only one barrier level, specifies the predetermined price of an underlier at which the occurrence of a barrier event (e.g. knock-out) is determined."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut is absent
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level only-element
            else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn is absent
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level only-element
        as "[Not in regulation] Single barrier price (monetary)"

reporting rule SingleBarrierPriceDecimal from TransactionReportInstruction: <"Single barrier price - Decimal">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Single barrier price"
        provision "For a barrier option involving only one barrier level, specifies the predetermined price of an underlier at which the occurrence of a barrier event (e.g. knock-out) is determined."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut is absent
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> levelPercentage only-element
            else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn is absent
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> levelPercentage only-element
        as "[Not in regulation] Single barrier price (decimal)"

reporting rule LowerBarrierPriceMonetary from TransactionReportInstruction: <"Lower barrier price - Monetary">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Lower barrier price"
        provision "For a barrier option involving two barrier levels, specifies the lower and upper levels as a predetermined price of an underlier at which the occurrence of a barrier event (such as a knock-out) is determined. Specifies the lower of the two barrier levels as a predetermined price."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> level = Min(
                    knockIn -> trigger -> level,
                    knockOut -> trigger -> level
                )
        then knockIn -> trigger -> level
        else knockOut -> trigger -> level
        as "[Not in regulation] Lower barrier price (monetary)"

reporting rule LowerBarrierPriceDecimal from TransactionReportInstruction: <"Lower barrier price - Decimal">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Lower barrier price"
        provision "For a barrier option involving two barrier levels, specifies the lower and upper levels as a predetermined price of an underlier at which the occurrence of a barrier event (such as a knock-out) is determined. Specifies the lower of the two barrier levels as a predetermined price."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> levelPercentage = Min(
                    knockIn -> trigger -> levelPercentage,
                    knockOut -> trigger -> levelPercentage
                )
        then knockIn -> trigger -> levelPercentage
        else knockOut -> trigger -> levelPercentage
        as "[Not in regulation] Lower barrier price (decimal)"

reporting rule UpperBarrierPriceMonetary from TransactionReportInstruction: <"Upper barrier price - Monetary">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Upper barrier price"
        provision "For a barrier option involving two barrier levels, specifies the lower and upper levels as a predetermined price of an underlier at which the occurrence of a barrier event (such as a knock-out) is determined. Specifies the higher of the two barrier levels as a predetermined price."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> level = Max(
                    knockIn -> trigger -> level,
                    knockOut -> trigger -> level
                )
        then knockIn -> trigger -> level
        else knockOut -> trigger -> level
        as "[Not in regulation] Upper barrier price (monetary)"

reporting rule UpperBarrierPriceDecimal from TransactionReportInstruction: <"Upper barrier price - Decimal">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Upper barrier price"
        provision "For a barrier option involving two barrier levels, specifies the lower and upper levels as a predetermined price of an underlier at which the occurrence of a barrier event (such as a knock-out) is determined. Specifies the higher of the two barrier levels as a predetermined price."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> levelPercentage = Max(
                    knockIn -> trigger -> levelPercentage,
                    knockOut -> trigger -> levelPercentage
                )
        then knockIn -> trigger -> levelPercentage
        else knockOut -> trigger -> levelPercentage
        as "[Not in regulation] Upper barrier price (decimal)"

reporting rule SingleBarrierPriceCurrency from TransactionReportInstruction: <"Single barrier price currency">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Single barrier price currency"
        provision "For equity options, commodity options, and similar products, currency in which the Single Barrier is denominated."]
    [regulatoryReference ISDA PeerReviewGroup date "20240410"
        provision "The modelling of this field is blocked until the CDM Trigger refactoring is available in DRR."]
    [regulatoryReference ISDA APACJFSAPeerReviewGroup date "20240828"
        provision "Modelling and extraction of barrier price currency fields to be revisited when DRR version is updated to use the newer CDM version 6 supporting currency at the trigger level."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
        then if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut is absent
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> featurePayment -> currency only-element
            else if EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn is absent
                    and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
            then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> featurePayment -> currency only-element
    then extract ConvertNonISOToISOCurrency
        as "[Not in regulation] Single barrier price currency"

reporting rule LowerBarrierPriceCurrency from TransactionReportInstruction: <"Lower barrier price currency">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Lower barrier price currency"
        provision "For equity options, commodity options, and similar products, currency in which the Lower Barrier is denominated."]
    [regulatoryReference ISDA PeerReviewGroup date "20240410"
        provision "The modelling of this field is blocked until the CDM Trigger refactoring is available in DRR."]
    [regulatoryReference ISDA APACJFSAPeerReviewGroup date "20240828"
        provision "Modelling and extraction of barrier price currency fields to be revisited when DRR version is updated to use the newer CDM version 6 supporting currency at the trigger level."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> level = Min(
                    knockIn -> trigger -> level,
                    knockOut -> trigger -> level
                )
        then knockIn -> featurePayment -> currency
        else knockOut -> featurePayment -> currency
    then extract ConvertNonISOToISOCurrency
        as "[Not in regulation] Lower barrier price currency"

reporting rule UpperBarrierPriceCurrency from TransactionReportInstruction: <"Upper barrier price currency">
    [regulatoryReference JFSA Trade dataElement "[Not in regulation]" field "Upper barrier price currency"
        provision "For equity options, commodity options, and similar products, currency in which the Upper Barrier is denominated."]
    [regulatoryReference ISDA PeerReviewGroup date "20240410"
        provision "The modelling of this field is blocked until the CDM Trigger refactoring is available in DRR."]
    [regulatoryReference ISDA APACJFSAPeerReviewGroup date "20240828"
        provision "Modelling and extraction of barrier price currency fields to be revisited when DRR version is updated to use the newer CDM version 6 supporting currency at the trigger level."]
    filter IsAllowableAction
    then extract
        if IsOption(ProductForEvent)
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockIn -> trigger -> level exists
                and EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock -> knockOut -> trigger -> level exists
        then EconomicTermsForProduct(ProductForEvent) -> payout -> optionPayout -> feature -> knock only-element
    then if knockIn -> trigger -> level = Max(
                    knockIn -> trigger -> level,
                    knockOut -> trigger -> level
                )
        then knockIn -> featurePayment -> currency
        else knockOut -> featurePayment -> currency
    then extract ConvertNonISOToISOCurrency
        as "[Not in regulation] Upper barrier price currency"

func IsAllowableActionForJFSA:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isAllowableAction boolean (1..1)

    set isAllowableAction:
        IsActionTypeNEWT(reportableEvent)
            or IsActionTypeMODI(reportableEvent)
            or IsActionTypeCORR(reportableEvent)
            or IsActionTypeREVI(reportableEvent)
            or IsActionTypeTERM(reportableEvent)
            or IsActionTypePRTO(reportableEvent)
            or IsActionTypeEROR(reportableEvent)
