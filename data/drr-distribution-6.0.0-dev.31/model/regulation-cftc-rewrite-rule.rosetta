namespace drr.regulation.cftc.rewrite
version "6.0.0-dev.31"

import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*
import cdm.base.*

import cdm.product.qualification.*

import cdm.event.common.*
import cdm.event.workflow.*
import cdm.event.qualification.*

import drr.regulation.common.*
import drr.regulation.common.util.*
import drr.standards.iosco.cde.* as cde
import drr.standards.iso.*

body Authority CFTC <"Commodity Futures Trading Commission (CFTC): The Federal regulatory agency established by the Commodity Futures Trading Act of 1974 to administer the Commodity Exchange Act.">

corpus Regulation "CFTC 17 CFR Parts 45 Version 3.0" Part45 <"Part 45 of the CFTCs regulations specifies the Commissions swap data recordkeeping and reporting requirements, pursuant to section 2(a)(13)(G) of the Commodity Exchange Act (CEA), which states that all swaps, whether cleared or uncleared, must be reported to a Swap Data Repository (SDR)">

corpus Regulation "CFTC 17 CFR Parts 45 Version 3.1" Part45_V3_1 <"Part 45 of the CFTCs regulations specifies the Commissions swap data recordkeeping and reporting requirements, pursuant to section 2(a)(13)(G) of the Commodity Exchange Act (CEA), which states that all swaps, whether cleared or uncleared, must be reported to a Swap Data Repository (SDR).The modifications address 14 data elements for several swap data reporting topics including: clearing, counterparty identification, price, valuation, collateral and margin, and transaction-related data fields.">

corpus Regulation "CFTC 17 CFR Parts 43" Part43 <"Part 43 of the CFTCs regulations specifies the Commissions swap data recordkeeping and reporting requirements, pursuant to section 2(a)(13)(G) of the Commodity Exchange Act (CEA), which states that all swaps, whether cleared or uncleared, must be reported to a Swap Data Repository (SDR)">

corpus Regulation "CFTC 17 CFR Parts 43 Version 3.1" Part43_V3_1 <"Part 43 of the CFTCs regulations specifies the Commissions swap data recordkeeping and reporting requirements, pursuant to section 2(a)(13)(G) of the Commodity Exchange Act (CEA), which states that all swaps, whether cleared or uncleared, must be reported to a Swap Data Repository (SDR).The modifications address 14 data elements for several swap data reporting topics including: clearing, counterparty identification, price, valuation, collateral and margin, and transaction-related data fields.">

report CFTC Part43 in T+1
    from TransactionReportInstruction
    when IsReportableEvent
  	with type CFTCPart43TransactionReport

report CFTC Part45 in T+1
    from TransactionReportInstruction
    when IsReportableEvent
  	with type CFTCPart45TransactionReport

reporting rule Cleared from TransactionReportInstruction: <"Cleared">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "1" field "Cleared"
        provision "Indicator of whether the transaction has been cleared, or is intended to be cleared, by a central counterparty."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "1" field "Cleared" footnote "12"
        provision "Throughout this Technical Specification, references to 'central counterparty' in CDE data elements should be read to mean 'derivatives clearing organizations' and 'exempt derivatives clearing organizations'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "1" field "Cleared" footnote "13"
        provision "Throughout this Technical Specification, references to 'beta and gamma transactions' in CDE data elements should be read to mean 'clearing swaps'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "1" field "Cleared" footnote "14"
        provision "Throughout this Technical Specification, references to 'alpha transactions' in CDE data elements should be read to mean 'original swaps'."]
    cde.settlement.Cleared
        as "01 Cleared"

reporting rule CentralCounterparty from TransactionReportInstruction: <"Central Counterparty">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "2" field "Central Counterparty"
        provision "Identifier of the central counterparty (CCP) that cleared the transaction. This data element is not applicable if the value of the data element 'Cleared' is 'N' (No, not centrally cleared) or 'I' (Intent to clear)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "2" field "Central Counterparty" footnote "15"
        provision " For CFTC jurisdiction, this data element is optional when the value of the data element Cleared is I (Intent to clear)"]
    cde.settlement.CentralCounterparty
        as "02 Central counterparty"

reporting rule ClearingAccountOrigin from TransactionReportInstruction: <"Clearing Account Origin">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "3" field "Clearing Account Origin"
        provision "Indicator of whether the clearing member acted as principal for a house trade or an agent for a customer trade."]
    extract
        if IsCleared(originatingWorkflowStep) = True
        then if Counterparties(TradeForEvent)
                    any = ExtractPartyFromRelatedPartyByRole(
                            reportableInformation -> partyInformation -> relatedParty,
                            PartyRoleEnum -> ClearingFirm
                        )
            then "HOUS"
            else "CLIE"
        as "03 Clearing account origin"

reporting rule ClearingMember from TransactionReportInstruction: <"Clearing Member">
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "4" field "Clearing Member"
        provision "Identifier of the clearing member through which a derivative transaction was cleared at a central counterparty. This data element is applicable to cleared transactions under both the agency clearing model and the principal clearing model.
           	 - In the case of the principal clearing model, the clearing member is identified as clearing member and also as a counterparty in both transactions resulting from clearing:
                (i) in the transaction between the central counterparty and the clearing member; and
                (ii) in the transaction between the clearing member and the counterparty to the original alpha transaction.
           	 - In the case of the agency clearing model, the clearing member is identified as clearing member but not as the counterparty to transactions resulting from clearing. Under this model, the counterparties are the central counterparty and the client.
        	This data element is not applicable if the value of the data element 'Cleared' is 'N' (No, not centrally cleared) or 'I' (Intent to clear)"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "4" field "Clearing Member" footnote "16"
        provision "Reporting counterparties should report 'clearing swaps' according to the agency clearing model."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "4" field "Clearing Member" footnote "17"
        provision " ROC Statement  Individuals Acting in a Business Capacity,
            ROC Statement - Individuals Acting in a Business Capacity (https://www.leiroc.org/publications/gls/lou_20150930-1.pdf)"]
    cde.settlement.ClearingMember
        as "04 Clearing member"

reporting rule ClearingSwapUSIs from TransactionReportInstruction: <"Clearing Swap USIs">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "5" field "Clearing Swap USIs"
        provision "The unique swap identifiers (USI) of each clearing swap that replaces the original swap that was submitted for clearing to the derivatives clearing organization, other than the USI for the swap currently being reported (as 'USI' data element below)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "5" field "Clearing Swap USIs" footnote "18"
        provision "Throughout this Technical Specification, references to 'CFTC USI Data Standard' should refer to the Unique Swap Identifier (USI) Data Standard,
            https://www.cftc.gov/sites/default/files/idc/groups/public/@swaps/documents/dfsubmission/usidatastandards100112.pdf"]
    extract
        if ((IsCleared(originatingWorkflowStep) or (IntendedToClear(originatingWorkflowStep) and IsActionTypeTERM))
                and cde.event.EventType = CLRG)
        then originatingWorkflowStep -> businessEvent
    then extract businessEvent [
        businessEvent -> after -> trade -> tradeIdentifier
            filter
                businessEvent -> instruction -> before -> trade -> tradeIdentifier all <> item
            then filter identifierType = TradeIdentifierTypeEnum -> UniqueSwapIdentifier
            then extract FindLatestAssignedIdentifier
    ]
    then extract
        ClearingSwapUSIsReport {
            identifier: ClearingSwapUSI
        }

reporting rule ClearingSwapUSI from AssignedIdentifier: <"Clearing Swap USI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "5" field "Clearing Swap USIs"
        provision "The unique swap identifiers (USI) of each clearing swap that replaces the original swap that was submitted for clearing to the derivatives clearing organization, other than the USI for the swap currently being reported (as 'USI' data element below)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "5" field "Clearing Swap USIs" footnote "18"
        provision "Throughout this Technical Specification, references to 'CFTC USI Data Standard' should refer to the Unique Swap Identifier (USI) Data Standard,
            https://www.cftc.gov/sites/default/files/idc/groups/public/@swaps/documents/dfsubmission/usidatastandards100112.pdf"]
    extract identifier
        as "05-$ Clearing swap USIs"

reporting rule ClearingSwapUTIs from TransactionReportInstruction: <"Clearing Swap UTIs">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "6" field "Clearing Swap UTIs"
        provision "The unique transaction identifiers (UTI) of each clearing swap that replaces the original swap that was submitted for clearing to the derivatives clearing organization, other than the UTI for the swap currently being reported (as 'UTI' data element below)."]
    extract
        if ((IsCleared(originatingWorkflowStep) or (IntendedToClear(originatingWorkflowStep) and IsActionTypeTERM))
                and cde.event.EventType = CLRG)
        then originatingWorkflowStep -> businessEvent
    then extract businessEvent [
        businessEvent -> after -> trade -> tradeIdentifier
            filter
                businessEvent -> instruction -> before -> trade -> tradeIdentifier all <> item
            then filter
                identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then extract FindLatestAssignedIdentifier
    ]
    then extract
        ClearingSwapUTIsReport {
            identifier: ClearingSwapUTI
        }

reporting rule ClearingSwapUTI from AssignedIdentifier: <"Clearing Swap UTI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "6" field "Clearing Swap UTIs"
        provision "The unique transaction identifiers (UTI) of each clearing swap that replaces the original swap that was submitted for clearing to the derivatives clearing organization, other than the UTI for the swap currently being reported (as 'UTI' data element below)."]
    extract identifier
        as "06-$ Clearing swap UTIs"

reporting rule OriginalSwapUSI from TransactionReportInstruction: <"Original Swap USI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "7" field "Original Swap USI"
        provision "The unique swap identifier (USI) of the original swap submitted for clearing to the derivatives clearing organization that is replaced by clearing swaps."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "7" field "Original Swap USI" footnote "19"
        provision "For transactions where no original swap USI is available or not provided, a value of 'NOTAVAILABLE' can be used."]
    extract
        if (IsCleared(originatingWorkflowStep) = True and IsActionTypeNEWT = True and cde.event.EventType = CLRG)
        then BeforeTradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueSwapIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then last
        as "07 Original swap USI"

reporting rule OriginalSwapUTI from TransactionReportInstruction: <"Original Swap UTI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "8" field "Original Swap UTI"
        provision "The unique transaction identifier (UTI) of the original swap submitted for clearing to the derivatives clearing organization that is replaced by clearing swaps."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "8" field "Original Swap UTI" footnote "20"
        provision "For transactions where no original swap UTI is available or not provided, a value of 'NOTAVAILABLE' can be used."]
    extract
        if (IsCleared(originatingWorkflowStep) = True and IsActionTypeNEWT = True and cde.event.EventType = CLRG)
        then BeforeTradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then last
        as "08 Original swap UTI"

reporting rule OriginalSwapSDRIdentifier from TransactionReportInstruction: <"Original Swap SDR Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "9" field "Original Swap SDR Identifier"
        provision "Identifier of the swap data repository (SDR) to which the original swap was reported."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "9" field "Original Swap SDR Identifier" footnote "21"
        provision " For transactions where no original swap SDR identifier is available or not provided, a value of 'NOTAVAILABLE' can be used."]
    extract
        if ((IsCleared(originatingWorkflowStep) or (IntendedToClear(originatingWorkflowStep) and IsActionTypeTERM))
                and cde.event.EventType = CLRG)
        then ExtractPartyFromRelatedPartyByRole(
                    reportableInformation -> partyInformation -> relatedParty,
                    PartyRoleEnum -> TradeRepository
                )
    then extract PartyLei(partyId)
        as "09 Original swap SDR identifier"

reporting rule ClearingReceiptTimestamp from TransactionReportInstruction: <"Clearing Receipt Timestamp">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "10" field "Clearing Receipt Timestamp"
        provision "The date and time, expressed in UTC, the original swap was received by the derivatives clearing organization (DCO) for clearing and recorded by the DCOs system"]
    extract
        if ((IsCleared(originatingWorkflowStep) or (IntendedToClear(originatingWorkflowStep) and IsActionTypeTERM))
                and cde.event.EventType = CLRG)
        then originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> clearingReceiptDateTime
    then only-element
    then extract dateTime
        as "10 Clearing receipt timestamp"

reporting rule ClearingExceptionsAndExemptionsCounterparty1 from TransactionReportInstruction: <"Clearing Exceptions And Exemptions Counterparty 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "11" field "Clearing Exceptions And Exemptions Counterparty 1"
        provision "Identifies the type of clearing exception or exemption that the Counterparty 1 has elected. All applicable exceptions and exemptions must be selected. The values may be repeated as applicable."]
    filter
        IsCleared(originatingWorkflowStep) = False
            and IntendedToClear(originatingWorkflowStep) = False
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter partyReference = reportInstruction -> reportingSide -> reportingParty
            then filter
                regimeInformation -> clearingException -> clearingException any = True
            then extract regimeInformation
            then flatten
            then filter supervisoryBody = SupervisoryBodyEnum -> CFTC
            then extract clearingException -> clearingExceptionReason
            then flatten
            then extract
                ClearingExceptionReason {
                    exceptionReason: item
                }
    ]
    then extract
        ClearingExceptionsAndExemptionsCounterparty1Report {
            value: ClearingExceptionsAndExemptionsCounterparty1Extraction
        }

reporting rule ClearingExceptionsAndExemptionsCounterparty1Extraction from ClearingExceptionReason: <"Clearing Exceptions And Exemptions Counterparty 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "11" field "Clearing Exceptions And Exemptions Counterparty 1"
        provision "Identifies the type of clearing exception or exemption that the Counterparty 1 has elected. All applicable exceptions and exemptions must be selected. The values may be repeated as applicable."]
    extract ClearingExceptionsAndExemptions(exceptionReason)
        as "11-$ Clearing exceptions and exemptions - Counterparty 1"

reporting rule ClearingExceptionsAndExemptionsCounterparty2 from TransactionReportInstruction: <"Clearing Exceptions And Exemptions Counterparty 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "12" field "Clearing Exceptions And Exemptions Counterparty 2"
        provision "Identifies the type of the clearing exception or exemption that the Counterparty 2 has elected. All applicable exceptions and exemptions must be selected. The values may be repeated as applicable."]
    filter
        IsCleared(originatingWorkflowStep) = False
            and IntendedToClear(originatingWorkflowStep) = False
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
            then filter
                regimeInformation -> clearingException -> clearingException any = True
            then extract regimeInformation
            then flatten
            then filter supervisoryBody = SupervisoryBodyEnum -> CFTC
            then extract clearingException -> clearingExceptionReason
            then flatten
            then extract
                ClearingExceptionReason {
                    exceptionReason: item
                }
    ]
    then extract
        ClearingExceptionsAndExemptionsCounterparty2Report {
            value: ClearingExceptionsAndExemptionsCounterparty2Extraction
        }

reporting rule ClearingExceptionsAndExemptionsCounterparty2Extraction from ClearingExceptionReason: <"Clearing Exceptions And Exemptions Counterparty 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "12" field "Clearing Exceptions And Exemptions Counterparty 2"
        provision "Identifies the type of the clearing exception or exemption that the Counterparty 2 has elected. All applicable exceptions and exemptions must be selected. The values may be repeated as applicable."]
    extract ClearingExceptionsAndExemptions(exceptionReason)
        as "12-$ Clearing exceptions and exemptions - Counterparty 2"

reporting rule Counterparty1 from TransactionReportInstruction: <"Counterparty 1 (reporting counterparty)">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "13" field "Counterparty 1 (reporting counterparty)"
        provision "Identifier of the counterparty to an OTC derivative transaction who is fulfilling its reporting obligation via the report in question. In jurisdictions where both parties must report the transaction, the identifier of Counterparty 1 always identifies the reporting counterparty. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund, and not the fund manager is reported as the counterparty."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "13" field "Counterparty 1" footnote "22"
        provision "Throughout this Technical Specification, references to 'OTC derivatives' in CDE data elements should be read to mean swaps."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "13" field "Counterparty 1" footnote "23"
        provision " ROC Statement  Individuals Acting in a Business Capacity, ROC Statement - Individuals Acting in a Business Capacity."]
    extract PartyLeiAndPersonByRoles(reportingSide -> reportingParty, empty)
        as "13 Counterparty 1"

reporting rule Counterparty2 from TransactionReportInstruction: <"Counterparty 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "14" field "Counterparty 2"
        provision "Identifier of the second counterparty to an OTC derivative transaction. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund, and not the fund manager is reported as the counterparty."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "14" field "Counterparty 2" footnote "24"
        provision "In the case of a swap transaction for pre-allocated block executed by a fund manager on behalf of a fund, the fund manager is reported as the counterparty."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "14" field "Counterparty 2" footnote "25"
        provision "Only one counterparty should be reported. In cases where multiple counterparties are legally responsible as the second counterparty (such as an obligated group, for example), report only one of the counterparties and use the
            same counterparty for all continuation data and lifecycle events."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "14" field "Counterparty 2" footnote "26"
        provision "ROC Statement  Individuals Acting in a Business Capacity, ROC Statement - Individuals Acting in a Business Capacity"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "14" field "Counterparty 2" footnote "27"
        provision "Throughout this Technical Specification, Privacy Law Identifier (PLI) has been added as an allowable value for all Counterparty 2 (#14) associated data elements"]
    extract cde.party.Counterparty2
        as "14 Counterparty 2"

reporting rule Counterparty1Format from TransactionReportInstruction: <"Expected Counterparty 1 Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(reportingSide -> reportingParty)
        as "Counterparty1 Format (non-reportable)"

reporting rule Counterparty2Format from TransactionReportInstruction: <"Expected Counterparty 2 Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(reportingSide -> reportingCounterparty)
        as "Counterparty2 Format (non-reportable)"

reporting rule BuyerIdentifierFormat from TransactionReportInstruction: <"Expected Buyer Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(cde.party.Direction1BuyerParty(TradeForEvent))
        as "BuyerIdentifier Format (non-reportable)"

reporting rule SellerIdentifierFormat from TransactionReportInstruction: <"Expected Seller Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(cde.party.Direction1SellerParty(TradeForEvent))
        as "SellerIdentifier Format (non-reportable)"

reporting rule PayerLeg1IdentifierFormat from TransactionReportInstruction: <"Expected Payer Leg 1 Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(PayerPartyLeg1)
        as "PayerLeg1Identifier Format (non-reportable)"

reporting rule PayerLeg2IdentifierFormat from TransactionReportInstruction: <"Expected Payer Leg 2 Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(PayerPartyLeg2)
        as "PayerLeg2Identifier Format (non-reportable)"

reporting rule ReceiverLeg1IdentifierFormat from TransactionReportInstruction: <"Expected Receiver Leg 1 Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(ReceiverPartyLeg1)
        as "ReceiverLeg1Identifier Format (non-reportable)"

reporting rule ReceiverLeg2IdentifierFormat from TransactionReportInstruction: <"Expected Receiver Leg 2 Identifier Format - LEI, or LEI and Person ID.">
    extract PartyIdentifierFormat(ReceiverPartyLeg2)
        as "ReceiverLeg2Identifier Format (non-reportable)"

reporting rule Counterparty2IdentifierSource from TransactionReportInstruction: <"Counterparty 2 Identifier Source">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "15" field "Counterparty 2 Identifier Source"
        provision "Source used to identify the Counterparty 2."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "15" field "Counterparty 2 Identifier Source" footnote "28"
        provision "Throughout this Technical Specification, for references to 'Privacy Law Identifiers', refer to DMO Letter No. 17-16, http://www.cftc.gov/idc/groups/public/@lrlettergeneral/documents/letter/17-16.pdf"]
    extract reportingSide -> reportingCounterparty
    then extract
        if person exists
                and person -> personId -> identifierType any = PersonIdentifierTypeEnum -> NPID
        then "NPID"
        else if partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
                and person is absent
        then "LEID"
        as "15 Counterparty 2 identifier source"

reporting rule Counterparty1FinancialEntityIndicator from TransactionReportInstruction: <"Counterparty 1 Financial Entity Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "16" field "Counterparty 1 Financial Entity Indicator"
        provision "Indicator of whether Counterparty 1 is a financial entity as defined in CEA  2(h)(7)(C)."]
    extract reportInstruction [
        if IsCleared(reportInstruction -> originatingWorkflowStep) = False
        then reportInstruction -> reportableInformation -> partyInformation
            filter partyReference = reportInstruction -> reportingSide -> reportingParty
            then only-element
            then extract
                if regimeInformation -> cftcPartyInformation -> financialEntity exists
                then True
                else False
    ]
        as "16 Counterparty 1 financial entity indicator"

reporting rule Counterparty2FinancialEntityIndicator from TransactionReportInstruction: <"Counterparty 2 Financial Entity  Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "17" field "Counterparty 2 Financial Entity Indicator"
        provision "Indicator of whether Counterparty 2 is a financial entity as defined in CEA  2(h)(7)(C)."]
    extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
            then only-element
            then extract
                if regimeInformation -> cftcPartyInformation -> financialEntity exists
                then True
                else False
    ]
        as "17 Counterparty 2 financial entity indicator"

reporting rule BuyerIdentifier from TransactionReportInstruction: <"Buyer Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "18" field "Buyer Identifier"
        provision "Identifier of the counterparty that is the buyer, as determined at the time of the transaction.
            A non-exhaustive list of examples of instruments for which this data element could apply are:
                - most forwards and forward-like contracts (except for foreign exchange forwards and foreign exchange non-deliverable forwards)
                - most options and option-like contracts including swaptions, caps and floors
                - credit default swaps (buyer/seller of protection)
                - variance, volatility and correlation swaps
                - contracts for difference and spreadbets.
            This data element is not applicable to instrument types covered by data elements Payer identifier and Receiver identifier"]
    extract cde.party.Direction1BuyerIdentifier
        as "18 Buyer identifier"

reporting rule SellerIdentifier from TransactionReportInstruction: <"Seller Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "19" field "Seller Identifier"
        provision "Identifier of the counterparty that is the seller, as determined at the time of the transaction.
        A non-exhaustive list of examples of instruments for which this data element could apply are:
            - most forwards and forward-like contracts (except for foreign exchange forwards and foreign exchange non-deliverable forwards)
            - most options and option-like contracts including swaptions, caps and floors
            - credit default swaps (buyer/seller of protection)
            - variance, volatility and correlation swaps
            - contracts for difference and spreadbets.
        This data element is not applicable to instrument types covered by data elements Payer identifier and Receiver identifier"]
    extract cde.party.Direction1SellerIdentifier
        as "19 Seller identifier"

reporting rule PayerIdentifierLeg1 from TransactionReportInstruction: <"Payer Identifier Leg1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "20" field "Payer Identifier"
        provision "Identifier of the counterparty of the payer leg as determined at the time of the transaction.
        A non-exhaustive list of examples of instruments for which this data element could apply are:
            - most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps)
            - foreign exchange swaps, forwards, non-deliverable forwards.
        This data element is not applicable to instrument types covered by data elements Buyer identifier and Seller identifier."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "20" field "Payer Identifier" footnote "29"
        provision "For fixed-floating interest rate swaps, the payer is the counterparty paying the fixed rate"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic  - Interest rate FRA  should be reported as payer/receiver."]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Only Credit TRS should be considered as payer/seller but not modelled yet. CR are reported as buyer/seller"]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."]
    extract PartyLeiAndPersonByRoles(PayerPartyLeg1, reportingSide -> reportingParty)
        as "20 Payer identifier - Leg 1"

func PayerPartyLeg1:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        party Party (0..1)

    alias counterpartyRole:
        if IsCommoditySwapFloatFloat(ProductForTrade(TradeForEvent(reportableEvent)))
        then CommodityLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if IsCommoditySwapFixedFloat(ProductForTrade(TradeForEvent(reportableEvent)))
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> fixedPricePayout exists
        then FixedPriceLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if IsFXForward(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXLeg1(ProductForEvent(reportableEvent)) -> payerReceiver -> payer
        else if IsFXSwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXSwapLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if IsEquitySwap(TradableProductForEvent(reportableEvent))
        then ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver -> payer
        else if Qualify_InterestRate_Option_Swaption(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and Qualify_InterestRate_CapFloor(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout is absent
        then InterestRateLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
    set party:
        ExtractCounterpartyByRole(
                TradeForEvent(reportableEvent) -> tradableProduct -> counterparty,
                counterpartyRole
            ) -> partyReference

reporting rule PayerIdentifierLeg2 from TransactionReportInstruction: <"Payer Identifier Leg2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "20" field "Payer Identifier"
        provision "Identifier of the counterparty of the payer leg as determined at the time of the transaction.
        A non-exhaustive list of examples of instruments for which this data element could apply are:
            - most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps)
            - foreign exchange swaps, forwards, non-deliverable forwards.
        This data element is not applicable to instrument types covered by data elements Buyer identifier and Seller identifier."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "20" field "Payer Identifier" footnote "29"
        provision "For fixed-floating interest rate swaps, the payer is the counterparty paying the fixed rate"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic - Interest rate FRA should be reported as payer/receiver."]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Only Credit TRS should be considered as payer/seller but not modelled yet. CR are reported as buyer/seller"]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."]
    extract PartyLeiAndPersonByRoles(PayerPartyLeg2, reportingSide -> reportingParty)
        as "20 Payer identifier - Leg 2"

func PayerPartyLeg2:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        party Party (0..1)

    alias counterpartyRole:
        if IsCommoditySwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then CommodityLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if IsFXForward(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if IsFXSwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXSwapLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
        else if Qualify_InterestRate_Option_Swaption(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and Qualify_InterestRate_CapFloor(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout is absent
        then InterestRateLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> payer
    set party:
        ExtractCounterpartyByRole(
                TradeForEvent(reportableEvent) -> tradableProduct -> counterparty,
                counterpartyRole
            ) -> partyReference

reporting rule ReceiverIdentifierLeg1 from TransactionReportInstruction: <"Receiver Identifier Leg1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "21" field "Receiver Identifier"
        provision "Identifier of the counterparty of the payer leg as determined at the time of the transaction.
        A non-exhaustive list of examples of instruments for which this data element could apply are:
            - most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps)
            - foreign exchange swaps, forwards, non-deliverable forwards.
        This data element is not applicable to instrument types covered by data elements Buyer identifier and Seller identifier."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "21" field "Receiver Identifier" footnote "30"
        provision "For fixed-floating interest rate swaps, the receiver is the counterparty receiving the fixed rate"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic  - Interest rate FRA  should be reported as payer/receiver."]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Only Credit TRS should be considered as payer/seller but not modelled yet. CR are reported as buyer/seller"]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."]
    extract PartyLeiAndPersonByRoles(ReceiverPartyLeg1, reportingSide -> reportingParty)
        as "21 Receiver identifier - Leg 1"

func ReceiverPartyLeg1:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        party Party (0..1)

    alias counterpartyRole:
        if IsCommoditySwapFloatFloat(ProductForTrade(TradeForEvent(reportableEvent)))
        then CommodityLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if IsCommoditySwapFixedFloat(ProductForTrade(TradeForEvent(reportableEvent)))
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> fixedPricePayout exists
        then FixedPriceLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if IsFXForward(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXLeg1(ProductForEvent(reportableEvent)) -> payerReceiver -> receiver
        else if IsFXSwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXSwapLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if IsEquitySwap(TradableProductForEvent(reportableEvent))
        then ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver -> receiver
        else if Qualify_InterestRate_Option_Swaption(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and Qualify_InterestRate_CapFloor(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout is absent
        then InterestRateLeg1(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
    set party:
        ExtractCounterpartyByRole(
                TradeForEvent(reportableEvent) -> tradableProduct -> counterparty,
                counterpartyRole
            ) -> partyReference

reporting rule ReceiverIdentifierLeg2 from TransactionReportInstruction: <"Receiver Identifier Leg2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "21" field "Receiver Identifier"
        provision "Identifier of the counterparty of the payer leg as determined at the time of the transaction.
        A non-exhaustive list of examples of instruments for which this data element could apply are:
            - most swaps and swap-like contracts including interest rate swaps, credit total return swaps, and equity swaps (except for credit default swaps, variance, volatility, and correlation swaps)
            - foreign exchange swaps, forwards, non-deliverable forwards.
        This data element is not applicable to instrument types covered by data elements Buyer identifier and Seller identifier."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "21" field "Receiver Identifier" footnote "30"
        provision "For fixed-floating interest rate swaps, the receiver is the counterparty receiving the fixed rate"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic  - Interest rate FRA  should be reported as payer/receiver."]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Only Credit TRS should be considered as payer/seller but not modelled yet. CR are reported as buyer/seller"]
    [regulatoryReference ISDA PeerReviewGroup date "20220307"
        provision "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."]
    extract PartyLeiAndPersonByRoles(ReceiverPartyLeg2, reportingSide -> reportingParty)
        as "21 Receiver identifier - Leg 2"

func ReceiverPartyLeg2:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        party Party (0..1)

    alias counterpartyRole:
        if IsCommoditySwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then CommodityLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if IsFXForward(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if IsFXSwap(ProductForTrade(TradeForEvent(reportableEvent)))
        then FXSwapLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
        else if Qualify_InterestRate_Option_Swaption(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and Qualify_InterestRate_CapFloor(
                        ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms
                    ) = False
                and ProductForTrade(TradeForEvent(reportableEvent)) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout is absent
        then InterestRateLeg2(ProductForTrade(TradeForEvent(reportableEvent))) -> payerReceiver -> receiver
    set party:
        ExtractCounterpartyByRole(
                TradeForEvent(reportableEvent) -> tradableProduct -> counterparty,
                counterpartyRole
            ) -> partyReference

reporting rule SubmitterIdentifier from TransactionReportInstruction: <"Submitter Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "22" field "Submitter Identifier"
        provision "Identifier of the entity submitting the data to the swap data repository (SDR). The Submitter identifier will be the same as the reporting counterparty or swap execution facility (SEF), unless they use a third-party service provider to submit the data to SDR in which case, report the identifier of the third-party service provider."]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Check whether trade is executed in a SEF first. If it is, SEF is obliged to be the Submitter. Then check for Reporting Party and Data Submitter."]
    extract ExtractReportSubmittingPartyIdentifier(reportingSide)
        as "22 Submitter identifier"

reporting rule Counterparty1FederalEntityIndicator from TransactionReportInstruction: <"Counterparty 1 Federal Entity Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "23" field "Counterparty 2 Federal Entity Indicator"
        provision "Indicator of whether Counterparty 1 is: (1) One of the following entities: a) An entity established pursuant to federal law, including, but not limited to, the following:  i. An agency as defined in 5 U.S.C.  551(1), a federal instrumentality, or a federal authority;  ii. A government corporation (examples: as such term is defined in 5 U.S.C.  103(1) or in 31 U.S.C.  9101);  iii. A government-sponsored enterprise (example: as such term is defined in 2 U.S.C.  622(8)); iv. A federally funded research and development center on the master list referenced in 48 CFR 35.017-6; and v. An executive department listed in 5 U.S.C.  101; or b) An entity chartered pursuant to federal law after formation (example: an organization listed in title 36 of the U.S. Code); or (2)  An entity that was established by, or at the direction of, one or more of the entities listed in dataElement (1), or has an ultimate parent listed in its LEI reference data that is an entity listed in dataElement (1) or in the first part of this dataElement (2). Notwithstanding the foregoing, the Counterparty 1 federal entity indicator data element does not include federally chartered depository institutions."]
    extract reportableEvent [
        reportableEvent -> reportableInformation -> partyInformation
            filter partyReference = reportableEvent -> reportingSide -> reportingParty
            then only-element
            then extract
                if regimeInformation -> cftcPartyInformation -> federalEntity exists
                then True
                else False
    ]
        as "23 Counterparty 1 federal entity indicator"

reporting rule Counterparty2FederalEntityIndicator from TransactionReportInstruction: <"Counterparty 2 Federal Entity Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "24" field "Counterparty 2 Federal Entity Indicator"
        provision "Indicator of whether Counterparty 2 is: (1) One of the following entities: a) An entity established pursuant to federal law, including, but not limited to, the following:  i. An agency as defined in 5 U.S.C.  551(1), a federal instrumentality, or a federal authority;  ii. A government corporation (examples: as such term is defined in 5 U.S.C.  103(1) or in 31 U.S.C.  9101);  iii. A government-sponsored enterprise (example: as such term is defined in 2 U.S.C.  622(8)); iv. A federally funded research and development center on the master list referenced in 48 CFR 35.017-6; and v. An executive department listed in 5 U.S.C.  101; or b) An entity chartered pursuant to federal law after formation (example: an organization listed in title 36 of the U.S. Code); or (2)  An entity that was established by, or at the direction of, one or more of the entities listed in dataElement (1), or has an ultimate parent listed in its LEI reference data that is an entity listed in dataElement (1) or in the first part of this dataElement (2). Notwithstanding the foregoing, the Counterparty 2 federal entity indicator data element does not include federally chartered depository institutions."]
    extract reportableEvent [
        reportableInformation -> partyInformation
            filter partyReference = reportableEvent -> reportingSide -> reportingCounterparty
            then only-element
            then extract
                if regimeInformation -> cftcPartyInformation -> federalEntity exists
                then True
                else False
    ]
        as "24 Counterparty 2 federal entity indicator"

reporting rule CustomBasketIndicator from TransactionReportInstruction: <"Custom Basket Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "25" field "Custom Basket Indicator"
        provision "Indicator of whether the swap transaction is based on a custom basket."]
    [regulatoryReference ISDA USComplianceGroup date "20220429"
        provision "The US Compliance WG agree on this consistent definition for reporting #25 Custom Basket Indicator. The definition can be used for all 5 asset classes. For purposes of reporting Custom Basket Indicator (CFTC #25), market participants generally refer to a trade as being a custom basket if it is tailored for a specific client, either by the client, by the Swap Dealer, or by both, where the weightings, constituents, roll schedules, etc., are agreed bilaterally with the client and are customized for that specific client. Custom baskets can be in any of the 5 asset classes, which is also reflected in CFTCs validation rule for #25."]
    extract ProductForEvent
    then extract
        if contractualProduct -> economicTerms -> payout -> forwardPayout exists
        then contractualProduct -> economicTerms -> payout -> forwardPayout -> underlier -> basket exists
        else if contractualProduct -> economicTerms -> payout -> optionPayout exists
        then contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> basket exists
                or contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        else if contractualProduct -> economicTerms -> payout -> performancePayout exists
        then contractualProduct -> economicTerms -> payout -> performancePayout -> underlier -> basket exists
        else if contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
        then contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        else False
        as "25 Custom basket indicator"

reporting rule ActionType from TransactionReportInstruction: <"Action Type">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "26" field "Action Type"
        provision "Type of action taken on the swap transaction or type of end-of-day reporting. Actions may include, but are not limited to, new, modify, correct, error, terminate, revive, transfer out, valuation, and collateral.
            - New: An action that reports a new swap transaction. It applies to the first message relating to a new USI or UTI.
            - Modify: An action that modifies the state of a previously submitted transaction (e.g., credit event) or changes a term of a previously submitted transaction due to a newly negotiated modification (amendment) or updates previously missing information (e.g., post price swap). It does not include correction of a previous transaction.
            - Correct: An action that corrects erroneous data of a previously submitted transaction.
            - Error: An action of cancellation of a wrongly submitted entire transaction in case it never came into existence or was not subject to part 43/part 45 reporting requirements but was reported erroneously.
            - Terminate: An action that closes an existing transaction because of a new event (e.g., Compression, Novation). This does not apply to transactions that terminate at contractual maturity date.
            - Revive: An action that reinstates a swap transaction that was reported as error or terminated by mistake.
            - Transfer out: An action that transfers swap transaction from one SDR to another SDR (change of swap data repository).
            - Valuation: An update to valuation data. There will be no corresponding Event type.
            - Collateral: An update to collateral margin data. There will be no corresponding Event type. Refer to appendix F for event model sample scenarios"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "26" field "Action Type" footnote "31"
        provision "Only one Action type value is allowed per submission. Multiple Action type values should not be submitted in one transaction report. For example, if a data element needs to be corrected on a previously submitted transaction that is getting terminated, the Correct (CORR) value should be submitted as a separate submission prior to the submission of the Terminate (TERM) transaction."]
    extract
        if IsActionTypeCORR
        then ActionTypeEnum -> CORR to-string
        else if IsActionTypeEROR
        then ActionTypeEnum -> EROR to-string
        else if IsActionTypeREVI
        then ActionTypeEnum -> REVI to-string
        else if IsActionTypePRTO
        then ActionTypeEnum -> PRTO to-string
        else if IsActionTypeVALU
        then ActionTypeEnum -> VALU to-string
        else if IsActionTypeTERM
        then ActionTypeEnum -> TERM to-string
        else if IsActionTypeMODI
        then ActionTypeEnum -> MODI to-string
        else ActionTypeEnum -> NEWT to-string
        as "26 Action type"

reporting rule EventType from TransactionReportInstruction: <"Event Type">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "27" field "Event Type"
        provision "Explanation or reason for the action being taken on the swap transaction. Events may include, but are not limited to, trade, novation, compression or risk reduction exercise, early termination, clearing, exercise, allocation, clearing and allocation, credit event, and transfer.
            - Trade: A creation, modification, or termination of a transaction.
            - Novation: A novation legally moves partial or all of the financial risks of a swap from a transferor to a transferee and has the effect of terminating/modifying the original transaction and creating a new transaction to identify the exposure between the transferor/transferee and remaining party.
            - Compression or Risk Reduction Exercise: Compressions and risk reduction exercises generally have the effect of terminating or modifying (i.e., reducing the notional value) a set of existing transactions and of creating a set of new transaction(s). These processes result in largely the same exposure of market risk that existed prior to the event for the counterparty.
            - Early termination: Termination of an existing swap transaction prior to scheduled termination or maturity date.
            - Clearing: Central clearing is a process where a derivatives clearing organization interposes itself between counterparties to contracts, becoming the buyer to every seller and the seller to every buyer. It has the effect of terminating an existing transaction between the buyer and the seller and thereby ensuring the performance of open contracts.
            - Exercise: The process by which a counterparty fully or partially exercises their rights specified in the contract of an option or a swaption.
            - Allocation: The process by which an agent, having facilitated a single swap transaction on behalf of several clients, allocates a portion of the executed swap to the clients.
            - Clearing and Allocation: A simultaneous clearing and allocation event in a derivatives clearing organization.
            - Credit event: An event or trigger that results in the modification of the state of a previously submitted credit derivative transaction. Applies only to credit derivatives.
            - Transfer: The process by which a swap is transferred to another SDR that  has the effect of the closing of the swap transaction at one SDR or opening of the same swap transaction using the same UTI/USI in a different SDR (new)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "27" field "Event Type" footnote "32"
        provision "Novation  see definition in  45.1(a)"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "27" field "Event Type" footnote "33"
        provision "Allocation  see definition in  45.1(a)"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "27" field "Event Type" footnote "34"
        provision "Transfer  A reporting counterparty may change the swap data repository to which the transaction is reported pursuant to rule  45.10(d)."]
    extract reportableEvent [
        if (IsActionTypeCORR = False
                and IsActionTypeEROR = False
                and IsActionTypeREVI = False
                and IsActionTypePRTO = False
                and IsActionTypeVALU = False)
        then extract reportableEvent -> originatingWorkflowStep
            then if IsEventTypePTNG(reportableEvent) or IsActionTypePRTO(reportableEvent)
                then EventTypeEnum -> PTNG to-string
                else if IsEventTypeUPDT(reportableEvent)
                then EventTypeEnum -> UPDT to-string
                else if Qualify_Novation(businessEvent) = True
                        or Qualify_PartialNovation(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Novation
                then EventTypeEnum -> NOVA to-string
                else if Qualify_Allocation(businessEvent) = True
                        or Qualify_Reallocation(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Allocation
                then EventTypeEnum -> ALOC to-string
                else if Qualify_Exercise(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> OptionExercise
                then EventTypeEnum -> EXER to-string
                else if Qualify_ClearedTrade(businessEvent) = True
                        or workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
                        or businessEvent -> intent = EventIntentEnum -> Clearing
                then EventTypeEnum -> CLRG to-string
                else if Qualify_Compression(businessEvent) = True
                        or businessEvent -> intent = EventIntentEnum -> Compression
                then EventTypeEnum -> COMP to-string
                else if Qualify_Termination(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> EarlyTerminationProvision
                then EventTypeEnum -> ETRM to-string
                else if Qualify_CreditEventDetermined(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> CreditEvent
                then EventTypeEnum -> CREV to-string
                else if Qualify_CorporateActionDetermined(businessEvent)
                        or businessEvent -> intent = EventIntentEnum -> CorporateActionAdjustment
                then EventTypeEnum -> CORP to-string
                else if Qualify_ContractFormation(businessEvent) = True
                        or Qualify_PartialTermination(businessEvent) = True
                        or Qualify_Increase(businessEvent) = True
                        or Qualify_Renegotiation(businessEvent) = True
                        or Qualify_IndexTransition(businessEvent) = True
                        or Qualify_FullReturn(businessEvent) = True
                        or businessEvent -> instruction -> primitiveInstruction -> quantityChange exists
                        or businessEvent -> instruction -> primitiveInstruction -> transfer exists
                        or businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment
                then EventTypeEnum -> TRAD to-string
    ]
        as "27 Event type"

reporting rule AmendmentIndicator from TransactionReportInstruction: <"Amendment Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "28" field "Amendment Indicator"
        provision "Indicator of whether the modification of the swap transaction reflects newly agreed upon term(s) from the previously negotiated terms."]
    extract
        if IsActionTypeMODI = True
        then originatingWorkflowStep -> businessEvent
    then extract
        if Qualify_PartialNovation = True
        then True
        else if intent = EventIntentEnum -> Novation
        then True
        else if Qualify_PartialTermination = True
        then True
        else if intent = EventIntentEnum -> Decrease
        then True
        else if Qualify_Compression = True
        then False
        else if intent = EventIntentEnum -> Compression
        then False
        else if Qualify_Allocation = True
        then False
        else if intent = EventIntentEnum -> Allocation
        then False
        else if Qualify_Increase = True
        then True
        else if intent = EventIntentEnum -> Increase
        then True
        else if Qualify_Exercise = True
        then False
        else if intent = EventIntentEnum -> OptionExercise
        then False
        else if Qualify_CashTransfer = True
        then False
        else if intent = EventIntentEnum -> ContractTermsAmendment
        then True
        else if Qualify_CorporateActionDetermined
        then True
        else if intent = EventIntentEnum -> CorporateActionAdjustment
        then True
        else if Qualify_CreditEventDetermined
        then True
        else if intent = EventIntentEnum -> CreditEvent
        then True
        as "28 Amendment indicator"

reporting rule EventIdentifier from TransactionReportInstruction: <"Event Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "29" field "Event Identifier"
        provision "Unique identifier to link swap transactions resulting from an event may be, but is not limited to, compression, and credit event. The unique identifier may be assigned by the reporting counterparty or a service provider."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "29" field "Event Identifier" footnote "35"
        provision "The identifier which relates to the same event should be unique per event."]
    extract cde.event.EventIdentifier
        as "29 Event identifier"

reporting rule EventTimestamp from TransactionReportInstruction: <"Event Timestamp">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "30" field "Event Timestamp"
        provision "Date and time of occurrence of the event as determined by the reporting counterparty or a service provider. In the case of a clearing event, date and time when the original swap is accepted by the derivative clearing organization (DCO) for clearing and recorded by the DCOs system should be reported in this data element. The time element is as specific as technologically practicable."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "30" field "Event Timestamp" footnote "36"
        provision "In the case of collateral update (Action type = 'MARU'), this is the date for which the information contained in the report is provided. Time portion should be reported as '00:00:00'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "30" field "Event Timestamp" footnote "37"
        provision "Both the date and time portion are required to be reported. If the time portion is not available, report '00:00:00' for the time portion."]
    [regulatoryReference ISDA PeerReviewGroup date "20240117"
        provision "DRR users are expected to use eventCreationDateTime as qualifier to the timestamp they have to report as the Event Timestamp"]
    extract cde.event.EventTimestamp
        as "30 Event timestamp"

reporting rule NotionalAmountLeg1 from TransactionReportInstruction: <"Notional Amount Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "31" field "Notional Amount"
        provision "For each leg of the transaction, where applicable:
                    - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract.
                    - for OTC derivative transactions negotiated in non-monetary amounts, refer to appendix B for converting notional amounts for non-monetary amounts.
                    In addition:
                    - For OTC derivative transactions with a notional amount schedule, the initial notional amount, agreed by the counterparties at the inception of the transaction, is reported in this data element.
                    - For OTC foreign exchange options, in addition to this data element, the amounts are reported using the data elements Call amount and Put amount.
                    - For amendments or lifecycle events, the resulting outstanding notional amount is reported; (steps in notional amount schedules are not considered to be amendments or lifecycle events);
                    - Where the notional amount is not known when a new transaction is reported, the notional amount is updated as it becomes available."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "38"
        provision "Notional amount for CDS should reflect the gross amount and not the net amount after reflecting version incrementing due to a credit event"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "39"
        provision "In the case of a lifecycle event that is a full termination before the swap maturity date, the full terminated value should be reported in the notional data element."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "40"
        provision "'99999999999999999999.99999' is accepted when the value is not available at the time of reporting. 25 numerical characters including decimals."]
    [regulatoryReference ISDA PeerReviewGroup date "20220706"
        provision "Members approved the approach for DRR to calculating Notional amount for Commodities."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20221117"
        provision "For a single-currency ZC IR Swap with a Known Amount, DRR relies on the underlying notional being the same on each leg (i.e. notional(fixed) = notional(float))"]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "DRR rules should not default the field value."]
    extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Commodity Option
                if IsCommodityOption(ProductForTrade)
                then (if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice exists
                    then cde.quantity.CommodityOptionNotional(
                                tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                            )
                    else if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> averagingStrikeFeature exists
                    then (if LastAvailableSpotPrice(
                                reportableEvent -> reportableInformation
                            )
                            exists
                        then cde.quantity.CommodityNotional(
                                    tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule,
                                    LastAvailableSpotPrice(
                                            reportableEvent -> reportableInformation
                                        )
                                )
                        else (tradableProduct -> tradeLot -> priceQuantity only-element -> quantity
                            filter unit -> currency exists
                            then extract value
                            then only-element)))
                // Credit swaption
                else if IsCreditSwaption(ProductForTrade)
                then cde.quantity.CreditNotional(
                            UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // FX forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then (if cde.quantity.FXNotional(FXLeg1(ProductForTrade)) = 0
                    then 99999999999999999999.99999
                    else cde.quantity.FXNotional(FXLeg1(ProductForTrade)))
                // FX Swap
                else if IsFXSwap(ProductForTrade)
                then (if cde.quantity.FXNotional(FXSwapLeg1(ProductForTrade)) = 0
                    then 99999999999999999999.99999
                    else cde.quantity.FXNotional(FXSwapLeg1(ProductForTrade)))
                // IR Swaption
                else if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotional(
                            InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                        )
                // Equity options
                else if IsEquityOption(ProductForTrade)
                then cde.quantity.EquityOptionNotional(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout
                        )
                // Equity forwards
                else if IsEquityForward(ProductForTrade)
                then cde.quantity.EquityForwardNotional(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout
                        )
                // Equity
                else if IsEquity(ProductForTrade)
                then cde.quantity.PerformanceNotional(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                        )
                // Credit
                else if IsCreditDefaultSwap(ProductForTrade)
                then cde.quantity.CreditNotional(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then cde.quantity.CommodityNotional(
                            FixedPriceLeg1(tradableProduct -> product) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_FixedFloat(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then cde.quantity.CommodityNotional(
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_Basis(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then cde.quantity.CommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(
                                        reportableEvent -> reportableInformation
                                    )
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(UnderlierForProduct(ProductForTrade))
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // Commodity Basis
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then cde.quantity.CommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(
                                        reportableEvent -> reportableInformation
                                    )
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // ZCS Known Amount
                else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
                then cde.quantity.InterestRateNotional(
                            InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                        )
                // IR Swap
                else if Qualify_AssetClass_InterestRate(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotional(InterestRateLeg1(ProductForTrade))
    ]
        as "31 Notional amount-Leg 1"

reporting rule NotionalAmountLeg2 from TransactionReportInstruction: <"Notional Amount Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "31" field "Notional Amount"
        provision "For each leg of the transaction, where applicable:
                    - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract.
                    - for OTC derivative transactions negotiated in non-monetary amounts, refer to appendix B for converting notional amounts for non-monetary amounts.
                    In addition:
                    - For OTC derivative transactions with a notional amount schedule, the initial notional amount, agreed by the counterparties at the inception of the transaction, is reported in this data element.
                    - For OTC foreign exchange options, in addition to this data element, the amounts are reported using the data elements Call amount and Put amount.
                    - For amendments or lifecycle events, the resulting outstanding notional amount is reported; (steps in notional amount schedules are not considered to be amendments or lifecycle events);
                    - Where the notional amount is not known when a new transaction is reported, the notional amount is updated as it becomes available."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "38"
        provision "Notional amount for CDS should reflect the gross amount and not the net amount after reflecting version incrementing due to a credit event"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "39"
        provision "In the case of a lifecycle event that is a full termination before the swap maturity date, the full terminated value should be reported in the notional data element."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "31" field "Notional Amount" footnote "40"
        provision "'99999999999999999999.99999' is accepted when the value is not available at the time of reporting. 25 numerical characters including decimals."]
    [regulatoryReference ISDA PeerReviewGroup date "20220706"
        provision "ISDA PeerReviewGroup members approved the approach for DRR to calculating Notional amount for Commodities."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Swaption
                if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotional(
                            InterestRateLeg2(UnderlierForProduct(ProductForTrade))
                        )
                // FX Forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then (if cde.quantity.FXNotional(FXLeg2(ProductForTrade)) = 0
                    then 99999999999999999999.99999
                    else cde.quantity.FXNotional(FXLeg2(ProductForTrade)))
                // FX Swap
                else if IsFXSwap(ProductForTrade)
                then (if cde.quantity.FXNotional(FXSwapLeg2(ProductForTrade)) = 0
                    then 99999999999999999999.99999
                    else cde.quantity.FXNotional(FXSwapLeg2(ProductForTrade)))
                // Commodity Fixed/Float Swap
                else if Qualify_Commodity_Swap_FixedFloat(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then cde.quantity.CommodityNotional(
                            CommodityLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(ProductForTrade) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then cde.quantity.CommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(
                                        reportableEvent -> reportableInformation
                                    )
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // IR Swap, CDS, EQS
                else if Qualify_AssetClass_InterestRate(
                            EconomicTermsForProduct(tradableProduct -> product)
                        )
                        or Qualify_AssetClass_Equity(
                                EconomicTermsForProduct(tradableProduct -> product)
                            )
                then cde.quantity.InterestRateNotional(InterestRateLeg2(ProductForTrade))
    ]
        as "31 Notional amount-Leg 2"

reporting rule NotionalCurrencyLeg1 from TransactionReportInstruction: <"Notional Currency Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "32" field "Notional Currency Leg 1"
        provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Commodity Option
                if IsCommodityOption(ProductForTrade)
                then (if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice exists
                    then cde.quantity.OptionNotionalCurrency(
                                tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                            )
                    else if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> averagingStrikeFeature exists
                    then (if LastAvailableSpotPrice(
                                reportableEvent -> reportableInformation
                            )
                            exists
                        then LastAvailableSpotPrice(
                                    reportableEvent -> reportableInformation
                                ) -> unit -> currency
                        else (tradableProduct -> tradeLot -> priceQuantity only-element -> quantity
                            filter unit -> currency exists
                            then extract unit -> currency
                            then only-element)))
                // Credit swaption
                else if Qualify_CreditDefaultSwaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then cde.quantity.CreditNotionalCurrency(
                            UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // FX forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then cde.quantity.FXNotionalCurrency(FXLeg1(ProductForTrade))
                // FX Swap
                else if IsFXSwap(ProductForTrade)
                then cde.quantity.FXNotionalCurrency(FXSwapLeg1(ProductForTrade))
                // IR Swaption
                else if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotionalCurrency(
                            InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                        )
                // Equity options or Interest Rate Debt Option
                // Monetary quantity schedule
                else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                        and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
                then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
                // Equity options or Interest Rate Debt Option
                // Non-monetary quantity schedule
                else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                        and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
                then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> unit -> currency
                // Equity forwards
                else if IsEquityForward(ProductForTrade)
                then (if EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
                    then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
                    else EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> priceSchedule only-element -> unit -> currency)
                // Equity
                else if IsEquity(ProductForTrade)
                then cde.quantity.PerformanceNotionalCurrency(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                        )
                // Credit
                else if IsCreditDefaultSwap(ProductForTrade)
                then cde.quantity.CreditNotionalCurrency(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then cde.quantity.CommodityNotionalCurrency(
                            FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_FixedFloat(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then cde.quantity.CommodityNotionalCurrency(
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_Basis(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // Commodity Basis
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // ZCS Known Amount
                else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
                then cde.quantity.InterestRateNotionalCurrency(
                            InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                        )
                // IR Swap
                else if Qualify_AssetClass_InterestRate(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotionalCurrency(
                            InterestRateLeg1(ProductForTrade)
                        )
    ]
    then extract ConvertNonISOToISOCurrency
        as "32 Notional currency-Leg 1"

reporting rule NotionalCurrencyLeg2 from TransactionReportInstruction: <"Notional Currency Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "32" field "Notional Currency Leg 2"
        provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // IR Swaption and Credit Swaption
                if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then cde.quantity.InterestRateNotionalCurrency(
                            InterestRateLeg2(UnderlierForProduct(ProductForTrade))
                        )
                // FX Forward and FX Option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then cde.quantity.FXNotionalCurrency(FXLeg2(ProductForTrade))
                // FX Swap
                else if IsFXSwap(ProductForTrade)
                then cde.quantity.FXNotionalCurrency(FXSwapLeg2(ProductForTrade))
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then FixedPriceLeg1(ProductForTrade) -> fixedPrice -> price -> unit -> currency
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                        exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // IR, Credit and EQS
                else if Qualify_AssetClass_InterestRate(
                            EconomicTermsForProduct(tradableProduct -> product)
                        )
                        or Qualify_AssetClass_Equity(
                                EconomicTermsForProduct(tradableProduct -> product)
                            )
                then cde.quantity.InterestRateNotionalCurrency(
                            InterestRateLeg2(ProductForTrade)
                        )
    ]
    then extract ConvertNonISOToISOCurrency
        as "32 Notional currency-Leg 2"

reporting rule NotionalAmountScheduleLeg1 from TransactionReportInstruction: <"Notional Amount Schedule">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "33-35" field "Notional Amount Schedule"
        provision "Fields 33-35 are repeatable and shall be populated in the case of derivatives involving notional amount schedules"]
    [regulatoryReference ISDA PeerReviewGroup date "20211203"
        provision "Model only applicable for back-to-back schedules. Repeatable field 35 (endDate) not applicable and therefore removed"]
    extract TradeForEvent
    then extract GetLeg1ResolvablePriceQuantity -> quantitySchedule
    then filter unit -> currency exists
    then extract datedValue
    then extract notionalAmountPeriod [
        // use value and dates from quantity period
        QuantityReportablePeriod {
            periodValue: notionalAmountPeriod -> value,
            periodEffectiveDate: notionalAmountPeriod -> date,
            periodEndDate: empty
        }
    ]
    then extract
        NotionalAmountScheduleLeg1Report {
            amount: NotionalAmountScheduleLeg1Amount,
            effectiveDate: NotionalAmountScheduleLeg1EffectiveDate
        }

reporting rule NotionalAmountScheduleLeg2 from TransactionReportInstruction: <"Notional Amount Schedule">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "33-35" field "Notional Amount Schedule"
        provision "Fields 33-35 are repeatable and shall be populated in the case of derivatives involving notional amount schedules"]
    [regulatoryReference ISDA PeerReviewGroup date "20211203"
        provision "Model only applicable for back-to-back schedules. Repeatable field 35 (endDate) not applicable and therefore removed"]
    extract TradeForEvent
    then extract GetLeg2ResolvablePriceQuantity -> quantitySchedule
    then filter unit -> currency exists
    then extract datedValue
    then extract notionalAmountPeriod [
        // use value and dates from quantity period
        QuantityReportablePeriod {
            periodValue: notionalAmountPeriod -> value,
            periodEffectiveDate: notionalAmountPeriod -> date,
            periodEndDate: empty
        }
    ]
    then extract
        NotionalAmountScheduleLeg2Report {
            amount: NotionalAmountScheduleLeg2Amount,
            effectiveDate: NotionalAmountScheduleLeg2EffectiveDate
        }

reporting rule NotionalAmountScheduleLeg1Amount from QuantityReportablePeriod: <"Notional amount in effect on associated effective date of leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "33" field "Notional amount in effect on associated effective date of leg 1"
        provision "For each leg of the transaction, where applicable:
                   for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule:
                        - Notional amount which becomes effective on the associated unadjusted effective date.
                   The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
                   This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    cde.quantity.NotionalAmountScheduleAmount
        as "33/35-$ 33 Notional amount leg 1"

reporting rule NotionalAmountScheduleLeg2Amount from QuantityReportablePeriod: <"Notional amount in effect on associated effective date of leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "33" field "Notional amount in effect on associated effective date of leg 2"
        provision "For each leg of the transaction, where applicable:
                   for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule:
                        - Notional amount which becomes effective on the associated unadjusted effective date.
                   The initial notional amount and associated unadjusted effective and end date are reported as the first values of the schedule.
                   This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    cde.quantity.NotionalAmountScheduleAmount
        as "33/35-$ 33 Notional amount leg 2"

reporting rule NotionalAmountScheduleLeg1EffectiveDate from QuantityReportablePeriod: <"Effective date of the notional amount of leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "34" field "Effective date of the notional amount of leg 1"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule: Unadjusted date on which the associated notional amount becomes effective This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "33/35-$ 34 Effective date leg 1"

reporting rule NotionalAmountScheduleLeg2EffectiveDate from QuantityReportablePeriod: <"Effective date of the notional amount of leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "34" field "Effective date of the notional amount of leg 2"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule: Unadjusted date on which the associated notional amount becomes effective This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "33/35-$ 34 Effective date leg 2"

reporting rule NotionalAmountScheduleLeg1EndDate from QuantityReportablePeriod: <"End date of the notional amount of leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "35" field "End date of the notional amount of leg 1"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule: Unadjusted end date of the notional amount (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period). This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference ISDA PeerReviewGroup date "unknown"
        provision "This field only applies to non-contiguous schedules with monetary amounts. Since non-contigous schedules are used only in the commodities context, where monetary amounts are absent, this field will be always left blank."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "33/35-$ 35 End date leg 1"

reporting rule NotionalAmountScheduleLeg2EndDate from QuantityReportablePeriod: <"End date of the notional amount of leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "35" field "End date of the notional amount of leg 2"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions negotiated in monetary amounts with a notional amount schedule: Unadjusted end date of the notional amount (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period). This data element is not applicable to OTC derivative transactions with notional amounts that are condition- or event-dependent. The currency of the varying notional amounts in the schedule is reported in Notional currency."]
    [regulatoryReference ISDA PeerReviewGroup date "unknown"
        provision "This field only applies to non-contiguous schedules with monetary amounts. Since non-contigous schedules are used only in the commodities context, where monetary amounts are absent, this field will be always left blank."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "33/35-$ 35 End date leg 2"

reporting rule CallAmount from TransactionReportInstruction: <"Call Amount">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "36" field "Call Amount"
        provision "For foreign exchange options, the monetary amount that the option gives the right to buy."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "36" field "Call Amount" footnote "41"
        provision "Call amount and the corresponding currency data element are applicable for all asset classes."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    [regulatoryReference ISDA PeerReviewGroup date "20210120"
        provision "On full termination of a trade the Put Amount and Call Amount should be reported as the prior amount, in line with the Notional field."]
    extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then cde.quantity.ExtractCallAmount(item, 99999999999999999999.99999)
        as "36 Call amount"

reporting rule CallCurrency from TransactionReportInstruction: <"Call Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "37" field "Call Currency"
        provision "For foreign exchange options, the currency in which the Call amount is denominated."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    cde.quantity.CallCurrency
        as "37 Call currency"

reporting rule PutAmount from TransactionReportInstruction: <"Put Amount">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "38" field "Put Amount"
        provision "For foreign exchange options, the monetary amount that the option gives the right to sell."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "38" field "Put Amount" footnote "42"
        provision "Put amount and the corresponding currency data element are applicable for all asset classes."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    [regulatoryReference ISDA PeerReviewGroup date "20230120"
        provision "On full termination of a trade the Put Amount and Call Amount should be reported as the prior amount, in line with the Notional field."]
    extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then cde.quantity.ExtractPutAmount(item, 99999999999999999999.99999)
        as "38 Put Amount"

reporting rule PutCurrency from TransactionReportInstruction: <"Put Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "39" field "Put Currency"
        provision "For foreign exchange options, the currency in which the Put amount is denominated."]
    [regulatoryReference ISDA PeerReviewGroup date "20211117"
        provision "Discussed at Peer Review. Group largely in agreement with proposed logic - only open question was around Credit Options which members agreed to take away and revert on at the next peer review."]
    [regulatoryReference ISDA PeerReviewGroup date "20220119"
        provision "Discussed at the DRR Peer Review call. No further input on logic for credit options:
		    - Call, in case of payer option type
		    - Put, in case of receiver option type"]
    cde.quantity.PutCurrency
        as "39 Put currency"

reporting rule NotionalQuantityLeg1 from TransactionReportInstruction: <"Notional Quantity Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "40" field "Notional Quantity"
        provision "For each leg of the swap transaction, where applicable, for swap transactions negotiated in non-monetary amounts with fixed notional quantity for each schedule period (i.e., 50 barrels per month).
                   The frequency is reported in Quantity frequency and the unit of measure is reported in Quantity unit of measure."]
    extract TradeForEvent
    then extract trade [
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then [
                CommodityObservablePriceQuantity(
                        trade -> tradableProduct -> tradeLot only-element,
                        CommodityLeg1(ProductForTrade(trade))
                    )
            ]
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
            filter pq [ pq -> observable is absent ]
        else if Qualify_Commodity_Swaption(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade(trade)) -> contractualProduct -> economicTerms
                    )
        then [
                CommodityObservablePriceQuantity(
                        trade -> tradableProduct -> tradeLot only-element,
                        CommodityLeg1(UnderlierForProduct(ProductForTrade(trade)))
                    )
            ]
        else if Qualify_Commodity_Swaption(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade(trade)) -> contractualProduct -> economicTerms
                    )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
            filter pq [ pq -> observable is absent ]
        else if Qualify_Commodity_Option(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
    ]
    then extract quantity
    then flatten
    then filter frequency exists
    then extract quantitySchedule [
        if quantitySchedule -> value exists
        then quantitySchedule -> value
        else if quantitySchedule -> datedValue exists
                and quantitySchedule -> datedValue -> value distinct count = 1
        then quantitySchedule -> datedValue -> value first
    ]
    then distinct only-element
        as "40 Notional quantity-Leg 1"

reporting rule NotionalQuantityLeg2 from TransactionReportInstruction: <"Notional Quantity Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "40" field "Notional Quantity"
        provision "For each leg of the swap transaction, where applicable, for swap transactions negotiated in non-monetary amounts with fixed notional quantity for each schedule period (i.e., 50 barrels per month).
                   The frequency is reported in Quantity frequency and the unit of measure is reported in Quantity unit of measure."]
    extract TradeForEvent
    then extract trade [
        if IsCommoditySwap(ProductForTrade(trade))
        then CommodityObservablePriceQuantity(
                    trade -> tradableProduct -> tradeLot only-element,
                    CommodityLeg2(ProductForTrade(trade))
                )
    ]
    then extract quantity
    then filter frequency exists
    then extract quantitySchedule [
        if quantitySchedule -> value exists
        then quantitySchedule -> value
        else if quantitySchedule -> datedValue exists
                and quantitySchedule -> datedValue -> value distinct count = 1
        then quantitySchedule -> datedValue -> value first
    ]
    then distinct only-element
        as "40 Notional quantity-Leg 2"

reporting rule QuantityFrequencyLeg1 from TransactionReportInstruction: <"Quantity Frequency Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "41" field "Quantity Frequency"
        provision "The rate at which the quantity is quoted on the swap transaction. e.g., hourly, daily, weekly, monthly"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "41" field "Quantity Frequency" footnote "43"
        provision "To represent quarterly, report [Quantity frequency] = 'MNTH' and [Quantity frequency multiplier] = '3'. For semi-annual, report [Quantity frequency] = 'MNTH' and [Quantity frequency multiplier] = '6'."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220607"
        provision "ONDE use case not supported. It was only found on physical commodities and they are out of scope for CFTC reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20220202"
        provision "The code ADHO is not supported by firms."]
    extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(ProductForTrade)
                                )
                        )
                )
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    CommodityFixedPriceQuantity(tradableProduct -> tradeLot only-element),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(UnderlierForProduct(ProductForTrade))
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriod(
                    CommodityFixedPriceQuantity(tradableProduct -> tradeLot only-element),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    tradableProduct -> tradeLot -> priceQuantity only-element,
                    QuantityFrequencyOrCalculationPeriod(
                            ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout -> observationTerms -> calculationPeriodDates only-element,
                            tradableProduct -> tradeLot -> priceQuantity only-element
                        )
                )
        as "41 Quantity frequency-Leg 1"

reporting rule QuantityFrequencyLeg2 from TransactionReportInstruction: <"Quantity Frequency Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "41" field "Quantity Frequency"
        provision "The rate at which the quantity is quoted on the swap transaction. e.g., hourly, daily, weekly, monthly"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "41" field "Quantity Frequency" footnote "43"
        provision "To represent quarterly, report [Quantity frequency] = 'MNTH' and [Quantity frequency multiplier] = '3'. For semi-annual, report [Quantity frequency] = 'MNTH' and [Quantity frequency multiplier] = '6'."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220607"
        provision "ONDE use case not supported. It was only found on physical commodities and they are out of scope for CFTC reporting."]
    [regulatoryReference ISDA PeerReviewGroup date "20220202"
        provision "The code ADHO is not supported by firms."]
    extract TradeForEvent
    then extract
        if IsCommoditySwap(ProductForTrade)
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg2(ProductForTrade)
                                )
                        )
                )
        as "41 Quantity frequency-Leg 2"

reporting rule QuantityFrequencyMultiplierLeg1 from TransactionReportInstruction: <"Quantity Frequency Multiplier Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "42" field "Quantity Frequency Multiplier"
        provision "The number of time units for the Quantity frequency"]
    extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(ProductForTrade)
                                )
                        )
                )
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout -> observationTerms -> calculationPeriodDates only-element,
                            tradableProduct -> tradeLot -> priceQuantity only-element
                        )
                )
        as "42 Quantity frequency multiplier-Leg 1"

reporting rule QuantityFrequencyMultiplierLeg2 from TransactionReportInstruction: <"Quantity Frequency Multiplier Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "42" field "Quantity Frequency Multiplier"
        provision "The number of time units for the Quantity frequency"]
    extract TradeForEvent
    then extract
        if IsCommoditySwap(ProductForTrade)
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg2(ProductForTrade)
                                )
                        )
                )
        as "42 Quantity frequency multiplier-Leg 2"

reporting rule QuantityUnitOfMeasureLeg1 from TransactionReportInstruction: <"Quantity Unit Of Measure Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "43" field "Quantity Unit Of Measure"
        provision "For each leg of the transaction, where applicable: unit of measure in which the Total notional quantity and Notional quantity are expressed."]
    extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then CommodityLeg1(ProductForTrade) -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then EconomicTermsForProduct(ProductForTrade) -> payout -> fixedPricePayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsCommodityOption(tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityOption(ProductForTrade)
                and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityForward(ProductForTrade)
                and EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule
        else if EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule
    then extract cde.quantity.QuantityUnitOfMeasure
        as "43 Quantity unit of measure-Leg 1"

reporting rule QuantityUnitOfMeasureLeg2 from TransactionReportInstruction: <"Quantity Unit Of Measure Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "43" field "Quantity Unit Of Measure"
        provision "For each leg of the transaction, where applicable: unit of measure in which the Total notional quantity and Notional quantity are expressed."]
    extract TradeForEvent
    then extract
        if IsCommoditySwap(tradableProduct -> product)
        then CommodityLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
        else if IsEquity(ProductForTrade)
                and InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
    then extract cde.quantity.QuantityUnitOfMeasure
        as "43 Quantity unit of measure-Leg 2"

reporting rule TotalNotionalQuantityLeg1 from TransactionReportInstruction: <"Total Notional Quantity Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "44" field "Total Notional Quantity"
        provision "For each leg of the transaction, where applicable: aggregate Notional quantity of the underlying asset for the term of the transaction.
                   Where the Total notional quantity is not known when a new transaction is reported, the Total notional quantity is updated as it becomes available."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "44" field "Total Notional Quantity" footnote "44"
        provision "'99999999999999999999.99999' is accepted when the value is not available. 25 numerical characters including decimals."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    extract TradeForEvent
    then extract
        if IsEquity(ProductForTrade) or IsEquityForward(ProductForTrade)
        then cde.quantity.EquityTotalNotionalQuantity(tradableProduct)
        else if IsCommoditySwapFloatFloat(ProductForTrade)
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg1(ProductForTrade))
        else if IsCommoditySwapFixedFloat(ProductForTrade) = True
        then cde.quantity.FixedPriceTotalNotionalQuantity(FixedPriceLeg1(ProductForTrade))
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then cde.quantity.CommodityTotalNotionalQuantity(
                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then cde.quantity.FixedPriceTotalNotionalQuantity(
                    FixedPriceLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then cde.quantity.OptionTotalNotionalQuantity(
                    ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                )
        as "44 Total notional quantity-Leg 1"

reporting rule TotalNotionalQuantityLeg2 from TransactionReportInstruction: <"Total Notional Quantity Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "44" field "Total Notional Quantity"
        provision "For each leg of the transaction, where applicable: aggregate Notional quantity of the underlying asset for the term of the transaction.
                   Where the Total notional quantity is not known when a new transaction is reported, the Total notional quantity is updated as it becomes available."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "44" field "Total Notional Quantity" footnote "44"
        provision "'99999999999999999999.99999' is accepted when the value is not available. 25 numerical characters including decimals."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    extract TradeForEvent
    then extract
        if IsCommoditySwap(ProductForTrade) = True
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg2(ProductForTrade))
        else if IsEquity(ProductForTrade)
                and InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then (InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
            then extract
                if multiplier exists
                then value * multiplier -> value
                else value)
        as "44 Total notional quantity-Leg 2"

reporting rule PackageIndicator from TransactionReportInstruction: <"Package Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "45" field "Package Indicator"
        provision "Indicator of whether the swap transaction is part of a package transaction."]
    extract GetPackageInformation exists
        as "45 Package Indicator"

reporting rule PackageIdentifier from TransactionReportInstruction: <"Package Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "46" field "Package Identifier"
        provision "Identifier (determined by the reporting counterparty) in order to connect two or more transactions that are reported separately by the reporting counterparty, but that are negotiated together as the product of a single economic agreement. Two or more reports pertaining to the same transaction whenever jurisdictional reporting requirement does not allow the transaction to be reported with a single report to TRs. A package may include reportable and non-reportable transactions. This data element is not applicable  if no package is involved, or  to allocations. Where the Package identifier is not known when a new transaction is reported, the Package identifier is updated as it becomes available."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "46" field "Package Identifier" footnote "45"
        provision "To report a collar, this field should be populated to link the cap and floor legs. To report a straddle, this field should be populated to link the payer swaption and receiver swaption legs."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "46" field "Package Identifier" footnote "46"
        provision "In addition, a 'package transaction' also includes a transaction involving two or more instruments: (1) that is executed between two or more counterparties; (2) that is priced or quoted as one economic transaction with
            simultaneous or near simultaneous execution of all components; (3) where the execution of each component is contingent upon the execution of all other components; (4) where each component is assigned a Unique Swap Identifier (USI) or Unique Transaction Identifier (UTI); and (5) each component is reported separately."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "46" field "Package Identifier" footnote "47"
        provision "'UNKNOWN' is accepted when the value is not available."]
    extract if GetPackageInformation exists then GetPackageInformation
    then cde.link.PackageIdentifier
    then only-element
        as "46 Package Identifier"

reporting rule PackageTransactionPrice from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "47" field "Package Transaction Price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component. This data element is not applicable if no package is involved, or package transaction spread is used Prices and related data elements of the transactions (Price currency, Price notation, Price unit of measure) that represent individual components of the package are reported when available. The Package transaction price may not be known when a new transaction is reported but may be updated later."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "47" field "Package Transaction Price" footnote "48"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "47" field "Package Transaction Price" footnote "49"
        provision "Default value with all 9s, for any of the allowable formats, is accepted when the value is unknown. When [Package transaction price notation] = '1' use '99999.9999999999999' (18 numerical characters including 13 decimal
            places). When [Package transaction price notation] = '3' use '9.9999999999' (11 numerical characters including 10 decimal places)."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    extract
        MultiplyPrice(
                cde.price.PackageTransactionPrice,
                GetPackageTransactionPriceNotationEnum
            )
        as "47 Package Transaction Price"

reporting rule PackageTransactionPriceCurrency from TransactionReportInstruction: <"Package Transaction Price Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "48" field "Package Transaction Price Currency"
        provision "Currency in which the Package transaction price is denominated. This data element is not applicable if no package is involved, or package transaction spread is used, or package transaction price notation = 3"]
    extract cde.price.PackageTransactionPriceCurrency
        as "48 Package Transaction Price Currency"

reporting rule GetPackageTransactionPriceNotationEnum from TransactionReportInstruction: <"Package Transaction Price Notation Enum">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "49" field "Package Transaction Price Notation"
        provision "Manner in which the Package transaction price is expressed. This data element is not applicable if no package is involved, or package transaction spread is used"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "49" field "Package Transaction Price Notation" footnote "50"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "This function returns the business names of notations."]
    if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.PackageTransactionPriceNotationEnum

reporting rule PackageTransactionPriceNotation from TransactionReportInstruction: <"Package Transaction Price Notation">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "49" field "Package Transaction Price Notation"
        provision "Manner in which the Package transaction price is expressed. This data element is not applicable if no package is involved, or package transaction spread is used"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "49" field "Package Transaction Price Notation" footnote "50"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    extract
        if GetPackageInformation exists
        then GetNotationString(GetPackageTransactionPriceNotationEnum)
        as "49 Package Transaction Price Notation"

reporting rule PackageTransactionSpread from TransactionReportInstruction: <"Package Transaction Spread">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "50" field "Package Transaction Spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if no package is involved, or Package transaction price is used. Spread and related data elements of the transactions (spread currency, Spread notation) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "50" field "Package Transaction Spread" footnote "51"
        provision "46 Default value with all 9s, for any of the allowable formats, is accepted when the value is unknown. When [Package transaction price notation] = '1' use '99999.9999999999999' (18 numerical characters including 13 decimal places). When [Package transaction price notation] = '3' use '9.9999999999' (11 numerical characters including 10 decimal places. When [Package transaction spread notation] = '4' use '99999' (5 numerical characters with no decimal place)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "50" field "Package Transaction Spread" footnote "52"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20221005"
        provision "Members agreed DRR rules should not default the field value."]
    extract
        MultiplyPrice(
                cde.price.PackageTransactionSpread,
                GetPackageTransactionSpreadNotationEnum
            )
        as "50 Package Transaction Spread"

reporting rule PackageTransactionSpreadCurrency from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "51" field "Package Transaction Spread Currency"
        provision "Currency in which the Package transaction spread is denominated. This data element is not applicable if no package is involved, or Package transaction price is used, or Package transaction spread notation = 3, or = 4"]
    extract cde.price.PackageTransactionSpreadCurrency
        as "51 Package Transaction Spread Currency"

reporting rule GetPackageTransactionSpreadNotationEnum from TransactionReportInstruction: <"Package Transaction Spread Notation Enum">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "52" field "Package Transaction Spread Notation"
        provision "Manner in which the Package transaction spread is expressed. This data element is not applicable if no package is involved, or Package transaction price is used."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "52" field "Package Transaction Spread Notation" footnote "53"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "This function returns the business names of notations."]
    if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.PackageTransactionSpreadNotationEnum

reporting rule PackageTransactionSpreadNotation from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "52" field "Package Transaction Spread Notation"
        provision "Manner in which the Package transaction spread is expressed. This data element is not applicable if no package is involved, or Package transaction price is used."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "52" field "Package Transaction Spread Notation" footnote "53"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    extract
        if GetPackageInformation exists
        then GetNotationString(GetPackageTransactionSpreadNotationEnum)
        as "52 Package Transaction Spread Notation"

reporting rule FixedRateDayCountConventionLeg1 from TransactionReportInstruction: <"Fixed rate day count convention-leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "53" field "Fixed rate day count convention-leg 1"
        provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
        as "53 Fixed rate day count convention-Leg 1"

reporting rule FixedRateDayCountConventionLeg2 from TransactionReportInstruction: <"Fixed rate day count convention-leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "53" field "Fixed rate day count convention-leg 2"
        provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
        as "53 Fixed rate day count convention-Leg 2"

reporting rule FloatingRateDayCountConventionLeg1 from TransactionReportInstruction: <"Floating rate day count convention-leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "53" field "Floating rate day count convention-leg 1"
        provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "53 Floating rate day count convention-Leg 1"

reporting rule FloatingRateDayCountConventionLeg2 from TransactionReportInstruction: <"Floating rate day count convention-leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "53" field "Floating rate day count convention-leg 2"
        provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "53 Floating rate day count convention-Leg 2"

reporting rule FixingDateLeg1 from TransactionReportInstruction: <"Fixing date-Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "54" field "Fixing date - Leg 1"
        provision "Describes the specific date when a non-deliverable forward as well as various types of FX OTC options such as cash-settled options that will 'fix' against a particular exchange rate, which will be used to compute the ultimate cash settlement"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Only applies to fixing date of an exchange rate as per definition"]
    extract ProductForEvent
    then extract
        // IR
        if InterestRateLeg1 -> settlementTerms exists
        then InterestRateLeg1 -> settlementTerms
        // Option
        else if contractualProduct -> economicTerms -> payout -> optionPayout exists
        then contractualProduct -> economicTerms -> payout -> optionPayout only-element -> settlementTerms
        // Forward
        else if contractualProduct -> economicTerms -> payout -> forwardPayout exists
        then contractualProduct -> economicTerms -> payout -> forwardPayout only-element -> settlementTerms
    then extract
        cashSettlementTerms only-element -> valuationDate -> fxFixingDate -> fxFixingDate -> adjustableDate -> unadjustedDate
        as "54 Fixing date-Leg 1"

reporting rule FixingDateLeg2 from TransactionReportInstruction: <"Fixing date-Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "54" field "Fixing date - Leg 2"
        provision "Describes the specific date when a non-deliverable forward as well as various types of FX OTC options such as cash-settled options that will 'fix' against a particular exchange rate, which will be used to compute the ultimate cash settlement"]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "Only applies to fixing date of an exchange rate as per definition"]
    extract ProductForEvent
    then extract InterestRateLeg2
    then extract settlementTerms
    then extract
        cashSettlementTerms only-element -> valuationDate -> fxFixingDate -> fxFixingDate -> adjustableDate -> unadjustedDate
        as "54 Fixing date-Leg 2"

reporting rule FloatingRateResetFrequencyPeriodLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "55" field "Floating rate reset frequency period-leg 1"
        provision "For each floating leg of the swap transaction, where applicable, time unit associated with the frequency of resets, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "55 Floating rate reset frequency period-Leg 1"

reporting rule FloatingRateResetFrequencyPeriodLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "55" field "Floating rate reset frequency period-leg 2"
        provision "For each floating leg of the swap transaction, where applicable, time unit associated with the frequency of resets, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "55 Floating rate reset frequency period-Leg 2"

reporting rule FloatingRateResetFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "56" field "Floating rate reset frequency period multiplier-leg 1"
        provision "For each floating leg of the swap transaction, where applicable, number of time units (as expressed by the Floating rate reset frequency period) that determines the frequency at which periodic payment dates for reset occur. For example, a transaction with reset payments occurring every two months is represented with a Floating rate reset frequency period of MNTH (monthly) and a Floating rate reset frequency period multiplier of 2. This data element is not applicable if the Floating rate reset frequency period is ADHO. If Floating rate reset frequency period is TERM, then the Floating rate reset frequency period multiplier is 1. If the reset frequency period is intraday, then the Floating rate reset frequency period is DAIL and the Floating rate reset frequency period multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "56 Floating rate reset frequency period multiplier-Leg 1"

reporting rule FloatingRateResetFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "56" field "Floating rate reset frequency period multiplier-leg 2"
        provision "For each floating leg of the swap transaction, where applicable, number of time units (as expressed by the Floating rate reset frequency period) that determines the frequency at which periodic payment dates for reset occur. For example, a transaction with reset payments occurring every two months is represented with a Floating rate reset frequency period of MNTH (monthly) and a Floating rate reset frequency period multiplier of 2. This data element is not applicable if the Floating rate reset frequency period is ADHO. If Floating rate reset frequency period is TERM, then the Floating rate reset frequency period multiplier is 1. If the reset frequency period is intraday, then the Floating rate reset frequency period is DAIL and the Floating rate reset frequency period multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "56 Floating rate reset frequency period multiplier-Leg 2"

reporting rule OtherPayment from TransactionReportInstruction: <"Other Payment">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "57-62" field "Other Payment"
        provision "Fields 57-62 are repeatable"]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    extract transactionReportInstruction [
        TradeStateForEvent
            then extract transferHistory
            then filter IsOtherPayment
            then extract
                OtherPaymentReport {
                    paymentType: OtherPaymentType,
                    amount: OtherPaymentAmount,
                    currency: OtherPaymentCurrency,
                    date: OtherPaymentDate,
                    payer: ExtractOtherPaymentPayer(item, transactionReportInstruction),
                    payerFormat: OtherPaymentPayerFormat,
                    receiver: ExtractOtherPaymentReceiver(
                            item,
                            transactionReportInstruction
                        ),
                    receiverFormat: OtherPaymentReceiverFormat
                }
    ]

reporting rule OtherPaymentType from TransferState: <"Other Payment Type">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "57" field "Other Payment Type"
        provision "Type of Other payment amount. Option premium payment is not included as a payment type as premiums for option are reported using the option premium dedicated data element."]
    [regulatoryReference ISDA USComplianceGroup date "20220719"
        provision "For novation fees: US Working Group agreed that Example 01 Submission 03/04 indicate novation fee is not reported under the rewrite."]
    [regulatoryReference ISDA USComplianceGroup date "20220727"
        provision "For other fees, members expressed that the answer to this question is trade-dependent. After discussion, the WG concluded that each RCP must make its own determination whether other fees such as Amendment Fee, Unclassified Fee, Termination Fee, etc. fit within the definition of one of the 3 Allowable Values of #57, as the RCP would be most familiar with the particular transaction and therefore the particular fee."]
    cde.payment.OtherPaymentType
        as "57/62-$ 57 Other payment type"

reporting rule OtherPaymentAmount from TransferState: <"Other Payment Amount">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "58" field "Other Payment Amount"
        provision "Payment amounts with corresponding payment types to accommodate requirements of transaction descriptions from different asset classes."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "58" field "Other Payment Amount" footnote "54"
        provision "The set of data elements related to other payments (Other payment type [#57], Other payment amount [#58], Other payment currency [#59], Other payment date [#60], Other payment payer [#61], Other payment receiver [#62]) can be reported multiple times in the case of multiple payments."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentAmount
        as "57/62-$ 58 Other payment amount"

reporting rule OtherPaymentCurrency from TransferState: <"Other Payment Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "59" field "Other Payment Currency"
        provision "Currency in which Other payment amount is denominated."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentCurrency
        as "57/62-$ 59 Other payment currency"

reporting rule OtherPaymentDate from TransferState: <"Other Payment Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "60" field "Other Payment Date"
        provision "Unadjusted date on which the Other payment amount is paid."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentDate
        as "57/62-$ 60 Other payment date"

reporting rule OtherPaymentPayer from TransferState: <"Other Payment Payer">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "61" field "Other Payment Payer"
        provision "Identifier of the payer of Other payment amount."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    empty // This rule is implemented within repeating rule OtherPayment.  This rule has been maintained so the regulatoryReference and "as" name can be specified.  DSL change request to allow easier modelling https://github.com/finos/rune-dsl/issues/852 
        as "57/62-$ 61 Other payment payer"

reporting rule OtherPaymentPayerFormat from TransferState: <"Other Payment Payer Format">
    filter IsOtherPayment
    then cde.payment.OtherPaymentPayerFormat
        as "57/62-$ 61 Other payment payer format (non-reportable)"

reporting rule OtherPaymentReceiver from TransferState: <"Other Payment Receiver">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "62" field "Other Payment Receiver"
        provision "Identifier of the receiver of Other payment amount."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220331" // RBC
        provision "Need to evaluate whether step-in / step-out novations should be included as part of any OtherPayment type"]
    filter IsOtherPayment
    then cde.payment.OtherPaymentReceiver
        as "57/62-$ 62 Other payment receiver"

reporting rule OtherPaymentReceiverFormat from TransferState: <"Other Payment Receiver Format">
    filter IsOtherPayment
    then cde.payment.OtherPaymentReceiverFormat
        as "57/62-$ 62 Other payment receiver format (non-reportable)"

reporting rule FixedRatePaymentFrequencyPeriodLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "63" field "Payment Frequency Period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "55"
        provision "To represent quarterly payment, report [Payment frequency period] = 'MNTH' and [Payment frequency period multiplier] = '3'. For semi-annual payment, report [Payment frequency period] = 'MNTH' and [Payment frequency period multiplier] = '6'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "56"
        provision "Throughout this Technical Specification, for the allowable value 'EXPI' in frequency period related data elements, two different descriptions 'Payment at term' and 'End of term' are being used which in essence has the same meaning and represents the frequency/rate of payment/quantity."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "63 Fixed rate payment frequency period-Leg 1"

reporting rule FixedRatePaymentFrequencyPeriodLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "63" field "Payment Frequency Period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "55"
        provision "To represent quarterly payment, report [Payment frequency period] = 'MNTH' and [Payment frequency period multiplier] = '3'. For semi-annual payment, report [Payment frequency period] = 'MNTH' and [Payment frequency
            period multiplier] = '6'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "56"
        provision "Throughout this Technical Specification, for the allowable value 'EXPI' in frequency period related data elements, two different descriptions 'Payment at term' and 'End of term' are being used which in essence has the
            same meaning and represents the frequency/rate of payment/quantity."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "63 Fixed rate payment frequency period-Leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "63" field "Payment Frequency Period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "55"
        provision "To represent quarterly payment, report [Payment frequency period] = 'MNTH' and [Payment frequency period multiplier] = '3'. For semi-annual payment, report [Payment frequency period] = 'MNTH' and [Payment frequency
            period multiplier] = '6'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "56"
        provision "Throughout this Technical Specification, for the allowable value 'EXPI' in frequency period related data elements, two different descriptions 'Payment at term' and 'End of term' are being used which in essence has the
            same meaning and represents the frequency/rate of payment/quantity."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "63 Floating rate payment frequency period-Leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "63" field "Payment Frequency Period"
        provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, e.g., day, week, month, year or term of the stream."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "55"
        provision "To represent quarterly payment, report [Payment frequency period] = 'MNTH' and [Payment frequency period multiplier] = '3'. For semi-annual payment, report [Payment frequency period] = 'MNTH' and [Payment frequency
            period multiplier] = '6'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "63" field "Payment Frequency Period" footnote "56"
        provision "Throughout this Technical Specification, for the allowable value 'EXPI' in frequency period related data elements, two different descriptions 'Payment at term' and 'End of term' are being used which in essence has the
            same meaning and represents the frequency/rate of payment/quantity."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriod
        as "63 Floating rate payment frequency period-Leg 2"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "64" field "Payment Frequency Period Multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is TERM, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "64 Fixed rate payment frequency period multiplier-Leg 1"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "64" field "Payment Frequency Period Multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is TERM, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "64 Fixed rate payment frequency period multiplier-Leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "64" field "Payment Frequency Period Multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is TERM, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "64 Floating rate payment frequency period multiplier-Leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "64" field "Payment Frequency Period Multiplier"
        provision "For each leg of the transaction, where applicable: number of time units (as expressed by the Payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a Payment frequency period of MNTH (monthly) and a Payment frequency period multiplier of 2.This data element is not applicable if the Payment frequency period is ADHO. If Payment frequency period is TERM, then the Payment frequency period multiplier is 1. If the Payment frequency is intraday, then the Payment frequency period is DAIL and the Payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20211123"
        provision "fixed income/fixed rates not applied to FX products"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then cde.payment.PaymentFrequencyPeriodMultiplier
        as "64 Floating rate payment frequency period multiplier-Leg 2"

reporting rule ExchangeRateLeg1 from TransactionReportInstruction: <"Exchange Rate Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "65" field "Exchange Rate-Leg 1"
        provision "Exchange rate between the two different currencies specified in the OTC derivative transaction agreed by the counterparties at the inception of the transaction, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "65" field "Exchange Rate-Leg 1" footnote "57"
        provision "For FX, forward exchange rate would be reported in this data element."]
    cde.price.ExchangeRate then extract value
        as "65 Exchange rate-Leg 1"

reporting rule ExchangeRateBasis from TransactionReportInstruction: <"Exchange Rate Basis">
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "66" field "Exchange Rate Basis"
        provision "Currency pair and order in which the exchange rate is denominated, expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426."]
    cde.price.ExchangeRate then cde.price.ExchangeRateBasis
        as "66 Exchange rate basis"

reporting rule FixedRateLeg1 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "67" field "Fixed Rate 1"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed leg(s)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "67" field "Fixed Rate 1" footnote "58"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract cde.price.InterestRateFixedRate(InterestRateLeg1)
        as "67 Fixed rate-Leg 1"

reporting rule FixedRateLeg2 from TransactionReportInstruction:
    [regulatoryReference CFTC Part45 appendix "1" dataElement "67" field "Fixed Rate 2"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed leg(s)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "67" field "Fixed Rate 2" footnote "54"
        provision "The allowable values are restricted based on CFTCs jurisdictional requirements."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    extract ProductForEvent
    then extract cde.price.InterestRateFixedRate(InterestRateLeg2)
        as "67 Fixed rate-Leg 2"

reporting rule PostPricedSwapIndicator from TransactionReportInstruction: <"Post-priced swap indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "68" field "Post-priced Swap Indicator"
        provision "Indicator of whether the swap transaction satisfies the definition of 'post-priced swap' in  43.2(a) of the Commission's regulations."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "68" field "Post-priced Swap Indicator" footnote "59"
        provision "For transactions where the swap price is not known at the time to execution, those unknown swap price-related fields can be reported as blank until such time that the price is known."]
    extract reportableInformation -> partyInformation -> regimeInformation
    then filter supervisoryBody = SupervisoryBodyEnum -> CFTC
    then only-element
    then if postPricedIndicator exists
        then postPricedIndicator
        else False
        as "68 Post-priced swap indicator"

reporting rule Price from TransactionReportInstruction: <"Price">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "69" field "Price"
        provision "Price specified in the OTC derivative transaction. It does not include fees, taxes or commissions.
        For commodity fixed/float swaps and similar products with periodic payments, this data element refers to the fixed price of the fixed leg(s).
        For commodity and equity forwards and similar products, this data element refers to the forward price of the underlying or reference asset.
        For equity swaps, portfolios swaps, and similar products, this data element refers to the initial price of the underlying or reference asset.
        For contracts for difference and similar products, this data element refers to the initial price of the underlier.
        This data element is not applicable to:
            - Interest rate swaps and forward rate agreements, as it is understood that the information included in the data elements Fixed rate and Spread may be interpreted as the price of the transaction.
            - Interest rate options and interest rate swaptions, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Commodity basis swaps and the floating leg of commodity fixed/float swaps, as it is understood that the information included in the data element Spread may be interpreted as the price of the transaction.
            - Foreign exchange swaps, forwards and options, as it is understood that the information included in the data elements Exchange rate, Strike price, and Option premium may be interpreted as the price of the transaction.
            - Equity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Credit default swaps and credit total return swaps, as it is understood that the information included in the data elements Fixed rate, Spread and Upfront payment (Other payment type: Upfront payment) may be interpreted as the price of the transaction.
            - Commodity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction. Where the price is not known when a new transaction is reported, the price is updated as it becomes available.
        For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "69" field "Price" footnote "60"
        provision "While Price (#69) captures the prices at which counterparties negotiate contracts, market prices are reflected in the valuation amounts."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "69" field "Price" footnote "61"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    filter
        Qualify_AssetClass_Commodity(EconomicTermsForProduct(ProductForEvent))
            or Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForEvent))
            or IsFixedFloatZeroCouponSwapKnownAmount(ProductForEvent)
    then extract MultiplyPrice(cde.price.Price, GetPriceNotationEnum)
        as "69 Price"

reporting rule PriceCurrency from TransactionReportInstruction: <"Price Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "70" field "Price currency"
        provision "Currency in which the price is denominated. Price currency is only applicable if Price notation = 1."]
    filter
        Qualify_AssetClass_Commodity(EconomicTermsForProduct(ProductForEvent))
            or Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForEvent))
            or IsFixedFloatZeroCouponSwapKnownAmount(ProductForEvent)
    then extract cde.price.PriceCurrency
    then extract ConvertNonISOToISOCurrency
        as "70 Price currency"

reporting rule PriceNotation from TransactionReportInstruction: <"Price Notation">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "71" field "Price Notation"
        provision "Manner in which the price is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "71" field "Price Notation" footnote "62"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    filter
        Qualify_AssetClass_Commodity(EconomicTermsForProduct(ProductForEvent))
            or Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForEvent))
            or IsFixedFloatZeroCouponSwapKnownAmount(ProductForEvent)
    then extract GetNotationString(GetPriceNotationEnum)
        as "71 Price notation"

reporting rule PriceUnitOfMeasure from TransactionReportInstruction: <"Price Unit Of Measure">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "72" field "Price Unit Of Measure"
        provision "Unit of measure in which the price is expressed."]
    cde.price.PriceUnitOfMeasure
        as "72 Price unit of measure"

/*------------------------------------------------ Spread Leg 1 Starts------------------------------------------------*/
reporting rule SpreadLeg1 from TransactionReportInstruction: <"SpreadLeg1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "73" field "Spread-Leg1"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
                - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
                - difference between the reference prices of the two floating leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "73" field "Spread-Leg1" footnote "63"
        provision "For equity swaps, portfolio swaps, and contract for difference (CFDs), report the weighted overall spread for the basket instead of individual legs."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "73" field "Spread-Leg1" footnote "64"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract MultiplyPrice(cde.price.SpreadLeg1 -> value, GetSpreadLeg1NotationEnum)
        as "73 Spread-Leg 1"

reporting rule GetSpreadLeg1NotationEnum from TransactionReportInstruction: <"Spread Notation Leg 1 Enum">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "75" field "Spread Notation Leg 1"
        provision "For each leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "75" field "Spread Notation Leg 1" footnote "65"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a CFTC specific function which converts Percentage notation into Decimal."]
    if cde.price.SpreadLeg1NotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.SpreadLeg1NotationEnum

reporting rule SpreadNotationLeg1 from TransactionReportInstruction: <"Spread Notation Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "75" field "Spread Notation Leg 1"
        provision "For each leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "75" field "Spread Notation Leg 1" footnote "65"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract GetNotationString(GetSpreadLeg1NotationEnum)
        as "75 Spread notation-Leg 1"

reporting rule SpreadCurrencyLeg1 from TransactionReportInstruction: <"Spread currency Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "74" field "Spread currency-Leg1"
        provision "For each leg of the transaction, where applicable: currency in which the spread is denominated. This data element is only applicable if Spread notation = 1."]
    extract cde.price.SpreadLeg1Currency
    then extract ConvertNonISOToISOCurrency
        as "74 Spread currency-Leg 1"

/*------------------------------------------------  Spread Leg 1 Ends ------------------------------------------------*/
/*------------------------------------------------ Spread Leg 2 Starts------------------------------------------------*/
reporting rule SpreadLeg2 from TransactionReportInstruction: <"SpreadLeg2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "73" field "Spread-Leg2"
        provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (e.g., interest rate fixed/float swaps, interest rate basis swaps, commodity swaps),
            - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; or
            - difference between the reference prices of the two floating leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "73" field "Spread-Leg2" footnote "63"
        provision "For equity swaps, portfolio swaps, and contract for difference (CFDs), report the weighted overall spread for the basket instead of individual legs."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "73" field "Spread-Leg2" footnote "64"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract MultiplyPrice(cde.price.SpreadLeg2 -> value, GetSpreadLeg2NotationEnum)
        as "73 Spread-Leg 2"

reporting rule GetSpreadLeg2NotationEnum from TransactionReportInstruction: <"Spread Notation Leg 2 Enum">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "75" field "Spread Notation Leg 2"
        provision "For each leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "75" field "Spread Notation Leg 2" footnote "65"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a CFTC specific function which converts Percentage notation into Decimal."]
    if cde.price.SpreadLeg2NotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.SpreadLeg2NotationEnum

reporting rule SpreadNotationLeg2 from TransactionReportInstruction: <"Spread Notation Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "75" field "Spread Notation Leg 2"
        provision "For each leg of the transaction, where applicable: manner in which the spread is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "75" field "Spread Notation Leg 2" footnote "65"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract GetNotationString(GetSpreadLeg2NotationEnum)
        as "75 Spread notation-Leg 2"

reporting rule SpreadCurrencyLeg2 from TransactionReportInstruction: <"Spread currency Leg2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "74" field "Spread currency-Leg2"
        provision "For each leg of the transaction, where applicable: currency in which the spread is denominated. This data element is only applicable if Spread notation = 1."]
    extract cde.price.SpreadLeg2Currency
    then extract ConvertNonISOToISOCurrency
        as "74 Spread currency-Leg 2"

/*------------------------------------------------ Spread Leg 2 Ends------------------------------------------------*/
reporting rule StrikePrice from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "76" field "Strike Price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426. Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products, the volatility strike price is reported in this data element"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "76" field "Spread Notation Leg 2" footnote "66"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract MultiplyPrice(cde.price.StrikePrice, GetStrikePriceNotationEnum)
        as "76 Strike Price"

reporting rule StrikePriceCurrency from TransactionReportInstruction: <"Strike Price Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "77" field "Strike Price Currency"
        provision "For equity options, commodity options, and similar products, currency in which the strike price is denominated. For foreign exchange options: Currency pair and order in which the strike price is expressed. It is expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426. Strike price currency/currency pair is only applicable if Strike price notation = 1."]
    cde.price.StrikePriceCurrency
        as "77 Strike Price Currency"

reporting rule GetStrikePriceNotationEnum from TransactionReportInstruction: <"Strike Price Notation Enum">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "78" field "Strike Price Notation"
        provision "Manner in which the strike price is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "78" field "Strike Price Notation" footnote "67"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    [regulatoryReference ISDA PeerReviewGroup date "20230621"
        provision "This is a CFTC specific function which converts Percentage notation into Decimal."]
    if cde.price.StrikePriceNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else cde.price.StrikePriceNotationEnum

reporting rule StrikePriceNotation from TransactionReportInstruction: <"Strike Price Notation">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "78" field "Strike Price Notation"
        provision "Manner in which the strike price is expressed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "78" field "Strike Price Notation" footnote "67"
        provision "The allowable values are restricted based on CFTC's jurisdictional requirements."]
    extract GetNotationString(GetStrikePriceNotationEnum)
        as "78 Strike Price notation"

reporting rule OptionPremiumAmount from TransactionReportInstruction: <"Option Premium Amount">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "79" field "Option Premium Amount"
        provision "For options and swaptions of all asset classes, monetary amount paid by the option buyer. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    cde.price.OptionPremiumAmount
        as "79 Option Premium Amount"

reporting rule OptionPremiumCurrency from TransactionReportInstruction: <"Option Premium Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "80" field "Option Premium Currency"
        provision "For options and swaptions of all asset classes, currency in which the option premium amount is denominated. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    cde.price.OptionPremiumCurrency
        as "80 Option Premium Currency"

reporting rule OptionPremiumPaymentDate from TransactionReportInstruction: <"Option Premium Payment Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "81" field "Option Premium Payment Date"
        provision "Unadjusted date on which the option premium is paid."]
    cde.price.OptionPremiumPaymentDate
        as "81 Option Premium Payment Date"

reporting rule FirstExerciseDate from TransactionReportInstruction: <"First Exercise Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "82" field "First Exercise Date"
        provision "First unadjusted date during the exercise period in which an option can be exercised.
				   For European-style options, this date is same as the Expiration date. For American-style options, the first possible exercise date is the unadjusted date included in the Execution timestamp.
				   For knock-in options, where the first exercise date is not known when a new transaction is reported, the first exercise date is updated as it becomes available.
				   This data element is not applicable if the instrument is not an option or does not embed any optionality"]
    extract TradeForEvent
    then cde.price.FirstExerciseDate
        as "82 First exercise date"

reporting rule CDSIndexAttachmentPoint from TransactionReportInstruction: <"CDS Index Attachment Point">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "83" field "CDS Index Attachment Point"
        provision "Defined lower point at which the level of losses in the underlying portfolio reduces the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% will be reduced after 3% of losses in the portfolio have occurred. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    cde.index.CDSIndexAttachmentPoint
        as "83 CDS Index Attachment Point"

reporting rule CDSIndexDetachmentPoint from TransactionReportInstruction: <"CDS Index Detachment Point">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "84" field "CDS Index Detachment Point"
        provision "Defined point beyond which losses in the underlying portfolio no longer reduce the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% and a detachment point of 6% will be reduced after there have been 3% of losses in the portfolio. 6% losses in the portfolio deplete the notional of the tranche. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    cde.index.CDSIndexDetachmentPoint
        as "84 CDS Index Detachment Point"

reporting rule IndexFactor from TransactionReportInstruction: <"Index Factor">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "85" field "Index Factor"
        provision "The index version factor or percent, expressed as a decimal value, that multiplied by the Notional amount yields the notional amount covered by the seller of protection for credit default swap."]
    extract TradeForEvent
    then filter IsCreditDefaultSwapIndex
    then extract
        tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexFactor
        as "85 Index factor"

reporting rule EmbeddedOptionType from TransactionReportInstruction: <"Embedded Option Type">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "86" field "Embedded Option Type"
        provision "Type of option or optional provision embedded in a contract."]
    [regulatoryReference ISDA USComplianceGroup date "20220519"
        provision "The US Compliance WG discussed #86 on May 19 WG call. The alternatives of the hierarchy (and OTHR were discussed (BNP and CS were on and assisted). 2 types of hierarchies were discussed
                - the one raised in Peer WG, and
                - one raised on the US WG call of a chronological (e.g. which came 1st).
            The consensus was that for cases where one option may have multiple provisions applicable, including the example of having both mandatory (MDET) and early termination (OPET) provisions applicable, the WG agreed to use the allowable value OTHR, rather than any hierarchy."]
    extract TradeForEvent
    then extract tradableProduct -> product -> contractualProduct -> economicTerms
    then extract
        if terminationProvision -> extendibleProvision only exists
        then "EXTD"
        else if terminationProvision -> cancelableProvision only exists
        then "CANC"
        else if terminationProvision -> earlyTerminationProvision only exists
                and terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination only exists
        then "OPET"
        else if terminationProvision -> earlyTerminationProvision only exists
                and terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination only exists
        then "MDET"
        else if terminationProvision -> extendibleProvision exists
                or terminationProvision -> cancelableProvision exists
                or terminationProvision -> earlyTerminationProvision exists
        then "OTHR"
        as "86 Embedded Option Type"

reporting rule UniqueProductIdentifier from TransactionReportInstruction: <"Unique Product Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "87" field "Unique Product Identifier"
        provision "A unique set of characters that represents a particular OTC derivative. The Commission will designate a UPI pursuant to part 45.7.
				   Note: A Unique product identifier short name (D4), defined as, 'When the Commission designates a UPI pursuant to part 45, a humanly readable description made available by the UPI issuer corresponding to the UPI'."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "87" field "Unique Product Identifier" footnote "68"
        provision "Until the Commission designates a UPI pursuant to part 45, continue reporting product data elements according to the internal product identifier or product description used by the swap data repository to which the swap is reported. When the Commission designates a UPI pursuant to part 45, report the UPI."]
    extract TradeForEvent
    then extract tradableProduct -> product -> contractualProduct -> productIdentifier
    then filter source = ProductIdTypeEnum -> UPI
    then only-element
    then extract identifier
        as "87 Unique product identifier"

reporting rule FinalContractualSettlementDate from TransactionReportInstruction: <"Final Contractual Settlement Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "88" field "Final Contractual Settlement Date"
        provision "Unadjusted date as per the contract, by which all transfer of cash or assets should take place and the counterparties should no longer have any outstanding obligations to each other under that contract. For products that may not have a final contractual settlement date (eg American options), this data element reflects the date by which the transfer of cash or asset would take place if termination were to occur on the expiration date."]
    extract cde.settlement.FinalContractualSettlementDate
        as "88 Final Contractual Settlement Date"

reporting rule SettlementCurrencyLeg1 from TransactionReportInstruction: <"Settlement Currency Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "89" field "Settlement Currency"
        provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of each leg. This data element is not applicable for physically settled products (eg physically settled swaptions)."]
    [regulatoryReference ISDA PeerReviewGroup date "unknown"
        provision "In the case where settlement currency is not provided, model does not infer cash vs. physical settlement based on the product and then extract the notional currency as settlement currency. The conclusion at Peer Review was that firms should fill out the settlement currency field if it is reportable and DRR should not infer it from the notional."]
    extract ProductForEvent
    then extract SettlementTermsLeg1
    then cde.settlement.SettlementCurrency
        as "89 Settlement Currency Leg 1"

reporting rule SettlementCurrencyLeg2 from TransactionReportInstruction: <"Settlement Currency Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "89" field "Settlement Currency"
        provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of each leg. This data element is not applicable for physically settled products (eg physically settled swaptions)."]
    [regulatoryReference ISDA PeerReviewGroup date "unknown"
        provision "In the case where settlement currency is not provided, model does not infer cash vs. physical settlement based on the product and then extract the notional currency as settlement currency. The conclusion at Peer Review was that firms should fill out the settlement currency field if it is reportable and DRR should not infer it from the notional."]
    extract ProductForEvent
    then extract SettlementTermsLeg2
    then cde.settlement.SettlementCurrency
        as "89 Settlement Currency Leg 2"

reporting rule SettlementLocationLeg1 from TransactionReportInstruction: <"Settlement Location Leg 1">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "90" field "Settlement Location Leg 1"
        provision "Place of settlement of the transaction as stipulated in the contract. This data element is only applicable for transactions that involve an offshore currency (i.e. a currency which is not included in the ISO 4217 currency list, for example CNH)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "90" field "Settlement Location Leg 1" footnote "69"
        provision "CFTC requires ISO country code to be reported using two-letter code (alpha-2)."]
    extract cde.settlement.SettlementLocationLeg1
        as "90 Settlement Location- Leg 1"

reporting rule SettlementLocationLeg2 from TransactionReportInstruction: <"Settlement Location Leg 2">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "90" field "Settlement Location Leg 2"
        provision "Place of settlement of the transaction as stipulated in the contract. This data element is only applicable for transactions that involve an offshore currency (i.e. a currency which is not included in the ISO 4217 currency list, for example CNH)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "90" field "Settlement Location Leg 2" footnote "69"
        provision "CFTC requires ISO country code to be reported using two-letter code (alpha-2)."]
    extract cde.settlement.SettlementLocationLeg2
        as "90 Settlement Location- Leg 2"

reporting rule AllocationIndicator from TransactionReportInstruction: <"Allocation Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "91" field "Allocation Indicator"
        provision "Indicator of whether the swap transaction is intended to be allocated, will not be allocated, or is a post allocation transaction."]
    extract
        if Qualify_Allocation(originatingWorkflowStep -> businessEvent)
        then "POST"
        else if originatingWorkflowStep -> nextEvent -> intent = EventIntentEnum -> Allocation
        then "PREA"
        else "UNAL"
        as "91 Allocation Indicator"

reporting rule NonStandardizedTermIndicator from TransactionReportInstruction: <"Non-standardized Term Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "92" field "Non-standardized Term Indicator"
        provision "Indicator of whether the swap transaction has one or more additional term(s) or provision(s), other than those disseminated to the public pursuant to part 43, that materially affect(s) the price of the swap transaction."]
    extract
        if IsCleared(originatingWorkflowStep) = False
                and originatingWorkflowStep -> nextEvent -> intent <> EventIntentEnum -> Clearing
        then TradeForEvent
    then extract ProductForTrade
    then extract
        if contractualProduct -> economicTerms -> nonStandardisedTerms exists
        then contractualProduct -> economicTerms -> nonStandardisedTerms
        else False
        as "92 Non-standardized Term Indicator"

reporting rule BlockTradeElectionIndicator from TransactionReportInstruction: <"Block Trade Election Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "93" field "Block Trade Election Indicator"
        provision "Indicator of whether an election has been made to report the swap transaction as a block transaction by the reporting counterparty or as calculated by either the swap data repository acting on behalf of the reporting counterparty or by using a third party."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220420" // ICE
        provision "If blockTradeIndicator is not present then report as false"]
    extract
        if reportableInformation -> largeSizeTrade exists
        then reportableInformation -> largeSizeTrade
        else False
        as "93 Block Trade Election Indicator"

reporting rule EffectiveDate from TransactionReportInstruction: <"Effective Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "94" field "Effective Date"
        provision "Unadjusted date at which obligations under the OTC derivative transaction come into effect, as included in the confirmation."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "94" field "Effective Date" footnote "70"
        provision "For commodities swaps, report the pricing start date."]
    [regulatoryReference ISDA PeerReviewGroup date "20230120"
        provision "For options the obligations under the OTC Derivative Transaction come into effect on the Trade Date. A fall back should be added to CDE Effective Date which handles effective date in this way when no specific effective date is specified."]
    cde.datetime.EffectiveDate
        as "94 Effective Date"

reporting rule ExpirationDate from TransactionReportInstruction: <"ExpirationDate">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "95" field "Expiration date"
        provision "Unadjusted date at which obligations under the OTC derivative transaction stop being effective, as included in the confirmation. Early termination does not affect this data element."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "95" field "Expiration Date" footnote "71"
        provision "For commodities swaps, report the pricing end date."]
    extract ProductForEvent
    then extract cde.datetime.ExpirationDate
        as "95 Expiration date"

reporting rule ExecutionTimestamp from TransactionReportInstruction: <"Execution Timestamp">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "96" field "Execution Timestamp"
        provision "Date and time a transaction was originally executed, resulting in the generation of a new UTI. This data element remains unchanged throughout the life of the UTI."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "96" field "Execution Timestamp" footnote "72"
        provision "For clearing swaps, the execution timestamp is the date and time when the DCO accepts the original swap."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "96" field "Execution Timestamp" footnote "73"
        provision "Both the date and time portion are required to be reported."]
    cde.datetime.ExecutionTimestamp
        as "96 Execution Timestamp"

reporting rule ReportingTimestamp from TransactionReportInstruction: <"Reporting Timestamp">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "97" field "Reporting Timestamp"
        provision "Date and time of the submission of the report to the trade repository"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "97" field "Reporting Timestamp" footnote "74"
        provision "Reporting timestamp (#97) is recorded and reported by the submitter."]
    cde.datetime.ReportingTimestamp
        as "97 Reporting timestamp"

reporting rule PlatformIdentifier from TransactionReportInstruction: <"Platform Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "98" field "Platform Identifier"
        provision "Identifier of the trading facility (e.g., exchange, multilateral trading facility, swap execution facility) on which the transaction was executed."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "98" field "Platform Identifier" footnote "75"
        provision "Where the Segment MIC does not exist, use the Operating MIC."]
    [regulatoryReference ISDA ISDAWorkingGroup date "20220328" // Credit Suisse
        provision "Headline would be
            - that it would need to be a CDM field on the input (containing an ISO 10383 MIC)
            - Reporting Logic would need to include reference data for Authorised platforms in all jurisdictions
            - Products Listed on US SEFs > no source identified

        This is because you could have a scenario where a transaction would
            - Report a MIC for EMIR but XXXX for CFTC
            - Report a MIC for MiFID but XOFF for CFTC"]
    cde.settlement.PlatformIdentifier
        as "98 Platform Identifier"

reporting rule PrimeBrokerageTransactionIndicator from TransactionReportInstruction: <"Prime brokerage transaction indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "99" field "Prime brokerage transaction indicator"
        provision "Indicator of whether the swap transaction satisfies the definition of 'mirror swap' or 'trigger swap' in para 43.2(a) of the Commissions regulations."]
    [regulatoryReference ISDA PeerReviewGroup date "20220325"
        provision "The modeling approach is to determine based on one of the two counterparts being identified as Prime Broker"]
    filter IsCleared(originatingWorkflowStep) = False
    then extract PrimeBrokerageTransactionIndicatorFunc
        as "99 Prime brokerage transaction indicator"

func PrimeBrokerageTransactionIndicatorFunc:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        indicator boolean (0..1)
    alias primeBrokerExists:
        ExtractPartyFromRelatedPartyByRole(
                reportableEvent -> reportableInformation -> partyInformation -> relatedParty,
                PartyRoleEnum -> PrimeBroker
            )
            exists
    alias executingBrokerPartyInfo:
        reportableEvent -> reportableInformation -> partyInformation
            filter
                partyReference = ExtractPartyFromRelatedPartyByRole(
                        relatedParty,
                        PartyRoleEnum -> ExecutingBroker
                    )
    alias executingBrokerIsUSPerson:
        executingBrokerPartyInfo -> regimeInformation -> cftcPartyInformation -> isUSPerson
    set indicator: primeBrokerExists and executingBrokerIsUSPerson

reporting rule PriorUSI from TransactionReportInstruction: <"Prior USI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "100" field "Prior USI"
        provision "Unique swap identifier (USI) assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (e.g., in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (e.g., in clearing or if a transaction is split into several different transactions), This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (e.g., in the case of a compression)."]
    extract
        if TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False
        then BeforeTradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueSwapIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then last
        as "100 Prior USI"

reporting rule PriorUTI from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "101" field "Prior UTI"
        provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (e.g., in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (e.g., in clearing or if a transaction is split into several different transactions). This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (e.g., in the case of a compression)."]
    extract
        if TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False
        then cde.link.PriorUTI
        else (extract reportableInformation -> transactionInformation
        then filter
            regimeName = RegimeNameEnum -> DoddFrankAct
                and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
        then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
        then flatten
        then distinct
        then only-element)
        as "101 Prior UTI"

reporting rule UniqueSwapIdentifier from TransactionReportInstruction: <"Unique Swap Identifier (USI)">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "102" field "Unique Swap Identifier (USI)"
        provision "The USI is a unique identifier assigned to all swap transactions which identifies the transaction (the swap and its counterparties) uniquely throughout its duration. It consists of a namespace and a transaction identifier."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "102" field "Unique Swap Identifier (USI)" footnote "76"
        provision "Throughout this Technical Specification, references to 'CFTC USI Data Standard' should refer to the USI Data Standard, https://www.cftc.gov/sites/default/files/idc/groups/public/@swaps/documents/dfsubmission/usidatastandards100112.pdf"]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Rule does not model UTI > USI priority defined in CFTC specification."]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Firms do expect to report USI/UTI in both formats: as a single identifier field as well as using Issuer + identifier. The functional model needs to handle both scenarios."]
    extract TradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueSwapIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then only-element
        as "102 Unique Swap Identifier (USI)"

reporting rule UniqueTransactionIdentifier from TransactionReportInstruction: <"Unique Transaction Identifier (UTI)">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "103" field "Unique Transaction Identifier (UTI)"
        provision "A unique identifier assigned to all swap transactions which identifies the swap uniquely throughout its lifecycle and used for all recordkeeping and all swap data reporting pursuant to para 45.5. A UTI is comprised of the LEI of the generating entity and a unique alphanumeric code."]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Rule does not model UTI > USI priority defined in CFTC specification."]
    [regulatoryReference ISDA PeerReviewGroup date "20220309"
        provision "Firms do expect to report USI/UTI in both formats: as a single identifier field as well as using Issuer + identifier. The functional model needs to handle both scenarios."]
    extract TradeForEvent
    then extract tradeIdentifier
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
    then only-element
    then extract assignedIdentifier -> identifier
    then only-element
        as "103 Unique Transaction Identifier (UTI)"

reporting rule Jurisdiction from TransactionReportInstruction: <"Jurisdiction">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "104" field "Jurisdiction Indicator"
        provision "The jurisdiction(s) that is requiring the reporting of the swap transaction."]
    extract
        if reportableInformation -> partyInformation -> regimeInformation -> supervisoryBody any = SupervisoryBodyEnum -> CFTC
                and reportableInformation -> partyInformation -> regimeInformation -> supervisoryBody any = SupervisoryBodyEnum -> SEC
        then "MIXX"
        else if reportableInformation -> partyInformation -> regimeInformation -> supervisoryBody any = SupervisoryBodyEnum -> SEC
        then "SECH"
        else if reportableInformation -> partyInformation -> regimeInformation -> supervisoryBody any = SupervisoryBodyEnum -> CFTC
        then "CFTC"
        as "104 Jurisdiction"

reporting rule NewSDRIdentifier from TransactionReportInstruction: <"New SDR Identifier">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "105" field "New SDR Identifier"
        provision "Identifier of the new swap data repository where the swap transaction is transferred to."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "105 New SDR Identifier"

reporting rule NextFloatingReferenceResetDate from TransactionReportInstruction: <"Next Floating Reference Reset Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "106" field "Next Floating Reference Reset Date"
        provision "The nearest date in the future that the floating reference resets on."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "106 Next Floating Reference Reset Date"

reporting rule LastFloatingReferenceValue from TransactionReportInstruction: <"Last Floating Reference Value">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "107" field "Last Floating Reference Value"
        provision "The most recent sampling of the value of the floating reference for to determine cash flow. Ties to Last floating reference reset date data element."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "107 Last Floating Reference Value"

reporting rule LastFloatingReferenceResetDate from TransactionReportInstruction: <"Last Floating Reference Reset Date">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "108" field "Last floating reference reset date"
        provision "The date of the most recent sampling of the floating reference to determine cash flow. Ties to Last floating reference value data element."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "108 Last Floating Reference Reset Date"

reporting rule Delta from TransactionReportInstruction: <"Delta">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "109" field "Delta"
        provision "The ratio of the absolute change in price of an OTC derivative transaction to the change in price of the underlier, at the time a new transaction is reported or when a change in the notional amount is reported."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "109" field "Delta" footnote "77"
        provision "Delta must be reported daily regardless of whether there is a change in the value since the last reporting."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "109 Delta"

reporting rule ValuationAmount from TransactionReportInstruction: <"Valuation Amount">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "110" field "Valuation Amount"
        provision "Current value of the outstanding contract. Valuation amount is expressed as the exit cost of the contract or components of the contract, i.e., the price that would be received to sell the contract (in the market in an orderly transaction at the valuation date)."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "110" field "Valuation Amount" footnote "78"
        provision "Valuation amount must be reported daily regardless of whether there is a change in the value since the last reporting."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "110 Valuation Amount"

reporting rule ValuationCurrency from TransactionReportInstruction: <"Valuation Currency">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "111" field "Valuation Currency"
        provision "Currency in which the valuation amount is denominated."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "111 Valuation Currency"

reporting rule ValuationMethod from TransactionReportInstruction: <"Valuation Method">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "112" field "Valuation Method"
        provision "Source and method used for the valuation of the transaction by the reporting counterparty. If at least one valuation input is used that is classified as mark-to-model in appendix D, then the whole valuation is classified as mark-to-model. If only inputs are used that are classified as mark-to-market in appendix D, then the whole valuation is classified as mark-to-market."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "112 Valuation Method"

reporting rule ValuationTimestamp from TransactionReportInstruction: <"Valuation Timestamp">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "113" field "Valuation Timestamp"
        provision "Date and time of the last valuation marked to market, provided by the central counterparty (CCP) or calculated using the current or last available market price of the inputs. If for example a currency exchange rate is the basis for a transactions valuation, then the valuation timestamp reflects the moment in time that exchange rate was current."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "113" field "Valuation Timestamp" footnote "79"
        provision "Reported by the derivatives clearing organization (DCO) for cleared swaps and by the swap dealer for uncleared swaps"]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "113" field "Valuation Timestamp" footnote "80"
        provision "The timestamp portion is not required to be represented for Valuation timestamp. The format must be reported as YYYY-MM-DD."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "113 Valuation Timestamp"

reporting rule AffiliatedCounterpartyForMarginAndCapitalIndicator from TransactionReportInstruction: <"Affiliated Counterparty For Margin And Capital Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "114" field "Affiliated Counterparty For Margin And Capital Indicator"
        provision "Indicator of whether the current counterparty is deemed an affiliate for U.S. margin and capital rules (as per para 23.159)."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "114 Affiliated Counterparty For Margin And Capital Indicator"

reporting rule CollateralisationCategory from TransactionReportInstruction: <"Collateralisation Category">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "115" field "Collateralisation Category"
        provision "Indicator of whether a collateral agreement (or collateral agreements) between the counterparties exists (uncollateralised/partially collateralised/one-way collateralised/fully collateralised). This data element is provided for each transaction or each portfolio, depending on whether the collateralisation is performed at the transaction or portfolio level, and is applicable to both cleared and uncleared transactions."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "115 Collateralisation Category"

reporting rule InitialMarginCollateralPortfolioCode from TransactionReportInstruction: <"Initial Margin Collateral Portfolio Code">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "116" field "Initial Margin Collateral Portfolio Code"
        provision "If collateral is reported on a portfolio basis, a unique code assigned by the reporting counterparty to the portfolio that tracks the aggregate initial margin of a set of open swap transactions. This data element is not applicable if the collateralisation was performed on a transaction level basis, or if there is no collateral agreement, or if no collateral is posted or received. The portfolio code is required for both collateral reporting and valuation reporting in order to link the 2 data sets."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "116" field "Initial Margin Collateral Portfolio Code" footnote "81"
        provision "If collateralization was performed on a transaction level basis, 'TRANSACTION-LEVEL' is accepted."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "116" field "Initial Margin Collateral Portfolio Code" footnote "82"
        provision " The M in the Part 43/45 Asset Class column is for collateral and valuation reporting only."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "116 Initial Margin Collateral Portfolio Code"

reporting rule PortfolioContainingNonReportableComponentIndicator from TransactionReportInstruction: <"Portfolio Containing Non-Reportable Component Indicator">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "117" field "Portfolio Containing Non Reportable Component Indicator"
        provision "If collateral is reported on a portfolio basis, indicator of whether the collateral portfolio includes swap transactions exempt from reporting."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "117 Portfolio Containing Non Reportable Component Indicator"

reporting rule InitialMarginPostedByTheReportingCounterpartyPostHaircut from TransactionReportInstruction: <"Initial Margin Posted By The Reporting Counterparty Post Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "118" field "Initial Margin Posted By The Reporting Counterparty Post Haircut"
        provision "Monetary value of initial margin that has been posted by the reporting counterparty, including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. If the collateralisation is performed at portfolio level, the initial margin posted relates to the whole portfolio; if the collateralisation is performed for single transactions, the initial margin posted relates to such single transaction. This refers to the total current value of the initial margin after application of the haircut (if applicable), rather than to its daily change. The data element refers both to uncleared and centrally cleared transactions. For centrally cleared transactions, the data element does not include default fund contributions, nor collateral posted against liquidity provisions to the central counterparty, i.e., committed credit lines. If the initial margin posted is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "118 Initial Margin Posted By The Reporting Counterparty Post Haircut"

reporting rule InitialMarginPostedByTheReportingCounterpartyPreHaircut from TransactionReportInstruction: <"Initial Margin Posted By The Reporting Counterparty Pre Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "119" field "Initial Margin Posted By The Reporting Counterparty Pre Haircut"
        provision "Monetary value of initial margin that has been posted by the reporting counterparty, including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. If the collateralisation is performed at portfolio level, the initial margin posted relates to the whole portfolio; if the collateralisation is performed for single transactions, the initial margin posted relates to such single transaction. This refers to the total current value of the initial margin, rather than to its daily change. The data element refers both to uncleared and centrally cleared transactions. For centrally cleared transactions, the data element does not include default fund contributions, nor collateral posted against liquidity provisions to the central counterparty, i.e., committed credit lines. If the initial margin posted is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "119 Initial Margin Posted By The Reporting Counterparty Pre Haircut"

reporting rule CurrencyOfInitialMarginPosted from TransactionReportInstruction: <"Currency Of Initial Margin Posted">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "120" field "Currency Of Initial Margin Posted"
        provision "Currency in which the initial margin posted is denominated. If the initial margin posted is denominated in more than one currency, this data element reflects one of those currencies into which the reporting counterparty has chosen to convert all the values of posted initial margins."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "120" field "Currency Of Initial Margin Posted" footnote "79"
        provision "For portfolio with multiple currencies, it must be converted in to a single currency chosen by the reporting counterparty and reported."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "120 Currency Of Initial Margin Posted"

reporting rule InitialMarginCollectedByTheReportingCounterpartyPostHaircut from TransactionReportInstruction: <"Initial Margin Collected By The Reporting Counterparty Post Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "121" field "Initial Margin Collected By The Reporting Counterparty Post Haircut"
        provision "Monetary value of initial margin that has been collected by the reporting counterparty, including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. If the collateralisation is performed at portfolio level, the initial margin collected relates to the whole portfolio; if the collateralisation is performed for single transactions, the initial margin collected relates to such single transaction. This refers to the total current value of the initial margin after application of the haircut (if applicable), rather than to its daily change. The data element refers both to uncleared and centrally cleared transactions. For centrally cleared transactions, the data element does not include collateral collected by the central counterparty as part of its investment activity. If the initial margin collected is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "121 Initial Margin Collected By The Reporting Counterparty Post Haircut"

reporting rule InitialMarginCollectedByTheReportingCounterpartyPreHaircut from TransactionReportInstruction: <"Initial Margin Collected By The Reporting Counterparty Pre Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "122" field "Initial Margin Collected By The Reporting Counterparty Pre Haircut"
        provision "Monetary value of initial margin that has been collected by the reporting counterparty, including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. If the collateralisation is performed at portfolio level, the initial margin collected relates to the whole portfolio; if the collateralisation is performed for single transactions, the initial margin collected relates to such single transaction. This refers to the total current value of the initial margin, rather than to its daily change. The data element refers both to uncleared and centrally cleared transactions. For centrally cleared transactions, the data element does not include collateral collected by the central counterparty as part of its investment activity. If the initial margin collected is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "122 Initial Margin Collected By The Reporting Counterparty Pre Haircut"

reporting rule CurrencyOfInitialMarginCollected from TransactionReportInstruction: <"Currency Of Initial Margin Collected">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "123" field "Currency Of Initial Margin Collected"
        provision "Currency in which the initial margin collected is denominated. If the initial margin collected is denominated in more than one currency, this data element reflects one of those currencies into which the reporting counterparty has chosen to convert all the values of collected initial margins."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "123" field "Currency Of Initial Margin Collected" footnote "84"
        provision "For portfolio with multiple currencies, it must be converted in to a single currency chosen by the reporting counterparty and reported."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "123 Currency Of Initial Margin Collected"

reporting rule VariationMarginCollateralPortfolioCode from TransactionReportInstruction: <"Variation Margin Collateral Portfolio Code">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "124" field "Variation Margin Collateral Portfolio Code"
        provision "If collateral is reported on a portfolio basis, a unique code assigned by the reporting counterparty to the portfolio that tracks the aggregate variation margin related to a set of open swap transactions. This data element is not applicable if the collateralisation was performed on a transaction level basis, or if there is no collateral agreement, or if no collateral is posted or received. The portfolio code is required for both collateral reporting and valuation reporting in order to link the 2 data sets."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "124" field "Variation Margin Collateral Portfolio Code" footnote "85"
        provision "If collateralization was performed on a transaction level basis, 'TRANSACTION-LEVEL' is accepted."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "124" field "Variation Margin Collateral Portfolio Code" footnote "86"
        provision "The 'M' in the 'Part 43/45 Asset Class' column is for collateral and valuation reporting only."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "124 Variation Margin Collateral Portfolio Code"

reporting rule VariationMarginPostedByTheReportingCounterpartyPreHaircut from TransactionReportInstruction: <"Variation Margin Posted By The Reporting Counterparty Pre Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "125" field "Variation Margin Posted By The Reporting Counterparty Pre Haircut"
        provision "Monetary value of the variation margin posted by the reporting counterparty (including the cash-settled one), and including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. Contingent variation margin is not included. If the collateralisation is performed at portfolio level, the variation margin posted relates to the whole portfolio; if the collateralisation is performed for single transactions, the variation margin posted relates to such single transaction. This data element refers to the total current value of the variation margin, cumulated since the first reporting of variation margins posted for the portfolio/transaction. If the variation margin posted is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "125" field "Variation Margin Posted By The Reporting Counterparty Pre Haircut" footnote "87"
        provision "This data element must be reported daily regardless of whether there is a change in the value since the last reporting."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "125 Variation Margin Posted By The Reporting Counterparty Pre Haircut"

reporting rule CurrencyOfVariationMarginPosted from TransactionReportInstruction: <"Currency Of Variation Margin Posted">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "126" field "Currency Of Variation Margin Posted"
        provision "Currency in which the variation margin posted is denominated. If the variation margin posted is denominated in more than one currency, this data element reflects one of those currencies into which the reporting counterparty has chosen to convert all the values of posted variation margins."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "126 Currency Of Variation Margin Posted"

reporting rule VariationMarginCollectedByTheReportingCounterpartyPreHaircut from TransactionReportInstruction: <"Variation Margin Collected By The Reporting Counterparty Pre Haircut">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "127" field "Variation Margin Collected By The Reporting Counterparty Pre Haircut"
        provision "Monetary value of the variation margin collected by the reporting counterparty (including the cash-settled one), and including any margin that is in transit and pending settlement unless inclusion of such margin is not allowed under the jurisdictional requirements. Contingent variation margin is not included. If the collateralisation is performed at portfolio level, the variation margin collected relates to the whole portfolio; if the collateralisation is performed for single transactions, the variation margin collected relates to such single transaction. This refers to the total current value of the variation margin, cumulated since the first reporting of collected variation margins for the portfolio/ transaction. If the variation margin collected is denominated in more than one currency, those amounts are converted into a single currency chosen by the reporting counterparty and reported as one total value."]
    [regulatoryReference CFTC Part45_V3_1 appendix "1" dataElement "127" field "Variation Margin Collected By The Reporting Counterparty Pre Haircut" footnote "88"
        provision "This data element must be reported daily regardless of whether there is a change in the value since the last reporting."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "127 Variation Margin Collected By The Reporting Counterparty Pre Haircut"

reporting rule CurrencyOfVariationMarginCollected from TransactionReportInstruction: <"Currency Of Variation Margin Collected">
    [regulatoryReference CFTC Part45 appendix "1" dataElement "128" field "Currency Of Variation Margin Collected"
        provision "Currency in which the variation margin collected is denominated. If the variation margin collected is denominated in more than one currency, this data element reflects one of those currencies into which the reporting counterparty has chosen to convert all the values of collected variation margins."]
    [regulatoryReference ISDA USComplianceGroup date "20220802"
        provision "Not returning anything until it gets modelled"]
    extract "Not Modelled"
        as "128 Currency Of Variation Margin Collected"

func ValidatePartyIdentifierFormat:
    inputs:
        partyIdentifier string (0..1)
        format PartyIdentifierFormatEnum (1..1)
    output:
        validOrEmpty boolean (1..1)

    set validOrEmpty:
        if partyIdentifier is absent
        then True
        else if format = PartyIdentifierFormatEnum -> Lei
        then StringLength(partyIdentifier) = 20
        else if format = PartyIdentifierFormatEnum -> LeiAndPerson
        then StringLength(partyIdentifier) > 20 and StringLength(partyIdentifier) <= 72
        else False
