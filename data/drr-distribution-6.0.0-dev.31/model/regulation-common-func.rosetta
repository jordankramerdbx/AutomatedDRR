namespace drr.regulation.common
version "6.0.0-dev.31"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*

import cdm.observable.asset.*

import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*
import cdm.product.template.*

import cdm.event.common.*
import cdm.event.workflow.*
import cdm.event.position.*
import cdm.event.qualification.*

import drr.regulation.common.util.*
import drr.regulation.esma.*
import drr.regulation.esma.emir.*
import drr.regulation.fca.ukemir.*
import drr.standards.iosco.cde.* as cde
import drr.standards.iso.*

segment rationale
segment rationale_author
segment structured_provision

segment article
segment whereas
segment annex
segment table
segment section
segment field
segment paragraph
segment question
segment dataElement
segment appendix
segment footnote
segment date
segment validationRule
segment part
segment definitions

body Organisation ISO <"The International Organization for Standardization is an international standard-setting body composed of representatives from various national standards organizations. Founded on 23 February 1947, the organization promotes worldwide proprietary, industrial, and commercial standards. ">

corpus ReportingStandard "ISO 20022" ISO_20022 <"ISO 20022 is a multi part International Standard prepared by ISO Technical Committee TC68 Financial Services.">

corpus BestPractice "24Apr2024" EMIRReportingBestPractice <"The EMIR Reporting Best Practices cover 238 data points across 203 reporting fields, including both over-the-counter and exchange-traded derivatives, and were developed to improve the accuracy and efficiency of trade reporting and to reduce compliance costs. The best practices are available to all market participants to access and implement.  The EMIR Reporting Best Practices is a cross-trade association initiative developed jointly by the European Fund and Asset Management Association (EFAMA), European Venues and Intermediaries Association (EVIA), Futures Industry Association (FIA), German Investment Funds Association (BVI), Global Foreign Exchange Division (GFXD), International Swaps and Derivatives Association, Inc. (ISDA) and Investment Association (IA).">

corpus WorkingGroup "ISDA DRR Technical Execution Working Group" TechnicalExecutionGroup <"Working Group comprised of firms who determine the approach to modeling DRR and contribute to the development of DRR via test packs, coding and/or reviewing what has been modeled in line with DRR SteerCO-determined roadmap, scope & priorities.">

corpus WorkingGroup "ISDA EMIR/CFTC Digital Regulatory Reporting Peer Review" PeerReviewGroup <"Industry group which works collaboratively to mutualize representation of amended CFTC and EMIR transaction reporting requirements in Digital Regulatory Reporting (DRR) - a digitized, single standard set of open-source machine-executable code using the Common Domain Model (CDM).">

corpus WorkingGroup "ISDA APAC/JFSA Digital Regulatory Reporting Peer Review" APACJFSAPeerReviewGroup <"Industry group which works collaboratively to mutualize representation of amended Asia-Pacific and JFSA transaction reporting requirements in Digital Regulatory Reporting (DRR) - a digitized, single standard set of open-source machine-executable code using the Common Domain Model (CDM).">

corpus WorkingGroup "ISDA Data and Reporting EMEA Working Group" EMEADataAndReporting <"This is the primary ISDA data and reporting industry working group dedicated to issues pertaining to data and reporting in Europe, Middle East and Africa. It deals with requirements under a number of regulatory regimes, including MiFID II/MiFIR, and EMIR, amongst other national and regional regimes. The group spearheads the resolution of compliance and implementation issues through coordinated industry discussions and regulatory advocacy.">

corpus WorkingGroup "US Compliance Working Group" USComplianceGroup <"This is an ISDA US Working Group.">

corpus WorkingGroup "ISDA Working Group" ISDAWorkingGroup <"This is an ISDA Working Group.">

// Utility Rules
func TradeStateForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTradeState TradeState (0..1)
    set reportableTradeState:
        if reportableEvent -> reportableTrade exists
        then reportableEvent -> reportableTrade
        else reportableEvent -> originatingWorkflowStep -> businessEvent -> after only-element

func TradeForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTrade Trade (0..1)
    set reportableTrade: TradeStateForEvent(reportableEvent) -> trade

func BeforeTradeForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTrade Trade (0..1)
    alias businessEvent: reportableEvent -> originatingWorkflowStep -> businessEvent
    alias afterTradeUTI:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then extract item -> assignedIdentifier -> identifier
            then flatten
            then only-element
    set reportableTrade:
        if Qualify_Compression(businessEvent) = True
        then BeforeTradeByUTI(reportableEvent, afterTradeUTI)
        else businessEvent -> instruction -> before -> trade only-element

func ProductForTrade: <"Extracts the product from a trade.">
    inputs:
        trade Trade (1..1)
    output:
        product Product (0..1)
    set product: trade -> tradableProduct -> product

func Counterparties: <"Extracts the two counterparties from a trade.">
    inputs:
        trade Trade (1..1)
    output:
        counterparties Party (0..2)
    add counterparties: trade -> tradableProduct -> counterparty -> partyReference

func EconomicTermsForProduct: <"Extracts the economic terms from a product.">
    inputs:
        product Product (1..1)
    output:
        economicTerms EconomicTerms (0..1)
    set economicTerms:
        if product -> contractualProduct -> economicTerms exists
        then product -> contractualProduct -> economicTerms
        else if IsProductETD(product) and product -> security -> economicTerms exists
        then product -> security -> economicTerms

func IsProductWithUnderlier:
    inputs:
        product Product (1..1)
    output:
        productWithUnderlier boolean (1..1)
    alias payout: EconomicTermsForProduct(product) -> payout
    set productWithUnderlier:
        payout -> optionPayout exists or payout -> forwardPayout exists

func UnderlierForProduct: <"Extracts the underlier product.">
    inputs:
        product Product (1..1)
    output:
        underlierProduct Product (0..1)
    set underlierProduct:
        if EconomicTermsForProduct(product) -> payout -> optionPayout exists
        then EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> underlier
        else if EconomicTermsForProduct(product) -> payout -> forwardPayout exists
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier

func PositionStateForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePositionState CounterpartyPositionState (0..1)
    set reportablePositionState:
        if reportableEvent -> reportablePosition exists
        then reportableEvent -> reportablePosition
        else reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after only-element

func PositionForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePosition CounterpartyPosition (0..1)
    set reportablePosition: PositionStateForEvent(reportableEvent) -> counterpartyPosition

func TradableProductForEvent: <"Extracts the tradableProduct from a reportableEvent.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        tradableProduct TradableProduct (0..1)
    set tradableProduct:
        if TradeForEvent(reportableEvent) exists
        then TradeForEvent(reportableEvent) -> tradableProduct
        else if PositionForEvent(reportableEvent) exists
        then PositionForEvent(reportableEvent) -> positionBase

func ProductForPosition:
    inputs:
        position CounterpartyPosition (0..1)
    output:
        product Product (0..1)
    set product: position -> positionBase -> product

func ProductForEvent: <"Extracts the product from a reportableEvent.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        product Product (0..1)
    set product:
        if TradeForEvent(reportableEvent) exists
        then ProductForTrade(TradeForEvent(reportableEvent))
        else if PositionForEvent(reportableEvent) exists
        then ProductForPosition(PositionForEvent(reportableEvent))

func SingleTradeLot: <"Extracts a single trade lot from a trade, or returns null if the trade lot attribute is not unique.">
    inputs:
        trade Trade (1..1)
    output:
        singleTradeLot TradeLot (0..1)
    set singleTradeLot: trade -> tradableProduct -> tradeLot only-element

func IsFixedInterestRate: <"Returns true if Price has priceType of InterestRate, with no spreadType specified.">
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> priceType = PriceTypeEnum -> InterestRate
            and price -> arithmeticOperator is absent

func IsInterestRateSpread: <"Returns true if Price has priceType of InterestRate, and a spreadType of Spread.">
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> priceType = PriceTypeEnum -> InterestRate
            and price -> arithmeticOperator = ArithmeticOperationEnum -> Add

func Contract_Price: <"Price">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        prices PriceSchedule (0..*)
    alias trade: TradeForEvent(reportableEvent)
    alias position: PositionForEvent(reportableEvent)
    add prices:
        if trade exists
        then SingleTradeLot(trade) -> priceQuantity -> price
        else if position exists
        then (position -> positionBase -> tradeLot only-element) -> priceQuantity -> price

func Contract_StrikePrice: <"Strike Price">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        prices PriceSchedule (0..*)
    alias tradableProduct: TradableProductForEvent(reportableEvent)
    alias product: ProductForEvent(reportableEvent)
    add prices:
        if IsIRSwaption(product) or IsCreditSwaption(product)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> price
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product)) = True
        then FixedPriceLeg1(UnderlierForProduct(product)) -> fixedPrice -> price
        else if IsOption(product)
                and EconomicTermsForProduct(product) -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice exists
        then EconomicTermsForProduct(product) -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice
        else if IsOption(product)
                and EconomicTermsForProduct(product) -> payout -> optionPayout -> exerciseTerms -> strike -> strikeReference exists
        then EconomicTermsForProduct(product) -> payout -> optionPayout -> exerciseTerms -> strike -> strikeReference -> rateSchedule -> price
        else if IsCap(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule -> price
        else if IsFloor(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule -> price
        else if IsVarianceSwap(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> returnTerms -> varianceReturnTerms -> volatilityStrikePrice
        else if IsVolatilitySwap(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> returnTerms -> volatilityReturnTerms -> volatilityStrikePrice
        else if IsEquitySwap(tradableProduct)
        then tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> Variance
                    or item -> priceType = PriceTypeEnum -> Volatility

func Contract_Price_Monetary: <"Monetary Price">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        prices PriceSchedule (0..*)

    alias tradableProduct: TradableProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(tradableProduct -> product)

    add prices:
        if // Equity Swaps
            IsEquitySwap(tradableProduct)
        then (if economicTerms -> payout -> performancePayout only-element -> returnTerms -> priceReturnTerms -> valuationPriceInitial exists
            then economicTerms -> payout -> performancePayout only-element -> returnTerms -> priceReturnTerms -> valuationPriceInitial
            else (tradableProduct -> tradeLot -> priceQuantity -> price
                filter
                    item -> priceType = PriceTypeEnum -> AssetPrice
                        or item -> priceType = PriceTypeEnum -> CashPrice))
        else if ( // Equity Forwards
            Qualify_BaseProduct_EquityForward(economicTerms)
                // Bond Swaps
                or IsTotalReturnSwapDebtUnderlier(tradableProduct -> product)
                    // Bond Forwards
                or Qualify_InterestRate_Forward_Debt(economicTerms))
        then tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
        else if economicTerms -> payout -> forwardPayout exists
                and (economicTerms -> payout -> forwardPayout only-element -> underlier -> index -> productTaxonomy only-element -> primaryAssetClass = AssetClassEnum -> Equity
                    or economicTerms -> payout -> forwardPayout only-element -> underlier -> security -> productTaxonomy only-element -> primaryAssetClass = AssetClassEnum -> Equity
                    or economicTerms -> payout -> forwardPayout only-element -> underlier -> basket -> productTaxonomy only-element -> primaryAssetClass = AssetClassEnum -> Equity)
        then economicTerms -> payout -> forwardPayout only-element -> priceQuantity -> priceSchedule
        // Futures ETD
        else if (economicTerms -> payout -> forwardPayout only exists
                and IsProductETD(tradableProduct -> product))
        then tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> ExchangeRate
        // Commodity Swaps
        else if IsCommoditySwapFixedFloat(tradableProduct -> product)
        then FixedPriceLeg1(ProductForEvent(reportableEvent)) -> fixedPrice -> price
        // Commodity Forwards
        else if IsCommodityForward(tradableProduct -> product)
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> fixedPricePayout only-element -> fixedPrice -> price

func Package_Contract_Price_Monetary: <"Package Monetary Price">
    inputs:
        trade Trade (1..1)
    output:
        prices PriceSchedule (0..*)
    add prices:
        // Equity Swaps
        if IsEquitySwap(trade -> tradableProduct)
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> InterestRate
        // Equity Forwards
        else if Qualify_BaseProduct_EquityForward(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> InterestRate
        // Bond Swaps
        else if IsTotalReturnSwapDebtUnderlier(ProductForTrade(trade))
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
        // Bond Forwards
        else if Qualify_InterestRate_Forward_Debt(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> InterestRate
        // Commodity Swaps
        else if IsCommoditySwap(trade -> tradableProduct -> product)
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> InterestRate
        // Interest Swaps
        else if Qualify_AssetClass_InterestRate(
                    EconomicTermsForProduct(ProductForTrade(trade))
                ) = True
        then trade -> tradableProduct -> tradeLot -> priceQuantity -> price
            filter
                item -> priceType = PriceTypeEnum -> AssetPrice
                    or item -> priceType = PriceTypeEnum -> CashPrice
                    or item -> priceType = PriceTypeEnum -> InterestRate

func IsEquitySwap:
    inputs:
        tradableProduct TradableProduct (1..1)
    output:
        result boolean (1..1)
    set result: IsEquitySwapProduct(tradableProduct -> product) = True

func IsEquitySwapProduct:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_BaseProduct_EquitySwap(EconomicTermsForProduct(product)) = True

func IsCommoditySwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product)) = True
            or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product)) = True

func IsCommoditySwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swaption(EconomicTermsForProduct(product)) = True

func IsCommodityForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Forward(EconomicTermsForProduct(product)) = True

func IsCommodityFixedPriceForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsCommodityForward(product) = True
            and EconomicTermsForProduct(product) -> payout -> fixedPricePayout exists

func IsCommodityFloatingPriceForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsCommodityForward(product) = True
            and EconomicTermsForProduct(product) -> payout -> commodityPayout exists

func RateOption:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        rateOption FloatingRateOption (0..1)
    set rateOption:
        if interestRatePayout -> rateSpecification -> floatingRate exists
        then interestRatePayout -> rateSpecification -> floatingRate -> rateOption
        else if interestRatePayout -> rateSpecification -> inflationRate exists
        then interestRatePayout -> rateSpecification -> inflationRate -> rateOption

//DRR Product Qualification -> Input Type is "Product"
func IsProductOTC: <"True if the product is and OTC under contractualProduct element">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: product -> contractualProduct exists

func IsProductETD: <"True if the product is and ETD under security element">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        product -> security exists
            and product -> security -> securityType = SecurityTypeEnum -> ListedDerivative

func IsInflationRateBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_BaseProduct_Inflation(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False
            and Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True

func IsInterestRateCrossCurrency:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = True

func IsInterestRateCrossCurrencyBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = True

func IsInterestRateFixedFloatSingleCurrency:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_FixedFloat(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateFixedFixed:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_FixedFixed(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateReturnSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    set result:
        if EconomicTermsForProduct(product) -> payout -> interestRatePayout count = 1
                and EconomicTermsForProduct(product) -> payout -> performancePayout count = 1
        then (EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> floatingRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> fixedRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> inflationRate exists)

func InterestRateReturnSwap:
    inputs:
        product Product (1..1)
    output:
        interestRatePayout InterestRatePayout (1..1)

    set interestRatePayout:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func IsGenericIRS:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: EconomicTermsForProduct(product) -> payout -> interestRatePayout count = 2

func IsOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: EconomicTermsForProduct(product) -> payout -> optionPayout exists

func IsCommoditySwapFloatFloat: //FloatFloat
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product)) = True

func IsCommoditySwapFixedFloat:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product)) = True

func IsIRSwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product)) = True

func IsCapFloor:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True

func IsFXForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> foreignExchange count = 1
            and IsProductETD(product) = False

func IsFXOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> optionPayout -> underlier -> foreignExchange exists

func IsFXPerformance:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> performancePayout -> observationTerms -> observable -> currencyPair exists

func IsFXSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product))
            or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product))

func IsFXProduct:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: IsFXForward(product) or IsFXOption(product) or IsFXSwap(product)

func IsEquity: //@TODO: should this also include equity forwards?
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_UnderlierProduct_Equity(
                    EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier
                ) = True
            or Qualify_UnderlierProduct_Equity(
                    EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> underlier
                ) = True

func IsEquityForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_UnderlierProduct_Equity(
                EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier
            )

func IsCreditSwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_CreditDefaultSwaption(EconomicTermsForProduct(product)) = True

func IsCommodityProduct:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_AssetClass_Commodity(EconomicTermsForProduct(product)) = True
            or IsSingleCommodityPayoutProduct(product) = True

func IsCreditDefaultSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_AssetClass_Credit(EconomicTermsForProduct(product)) = True

func IsCreditDefaultSwapIndex:
    inputs:
        trade Trade (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_CreditDefaultSwap_Index(EconomicTermsForProduct(ProductForTrade(trade))) = True
            or Qualify_CreditDefaultSwap_IndexTranche(
                    EconomicTermsForProduct(ProductForTrade(trade))
                ) = True

func IsCreditDefaultSwapBasket:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_CreditDefaultSwap_Basket(EconomicTermsForProduct(product)) = True

func IsPutOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsOption(product)
            and (EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Put
                or EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Receiver)

func IsCallOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsOption(product)
            and (EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Call
                or EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Payer)

func IsCap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True
            and EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule exists

func IsFloor:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True
            and EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule exists

func IsCommodityOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Option(EconomicTermsForProduct(product)) = True

func IsEquityOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquityOption_PriceReturnBasicPerformance_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquityOption_PriceReturnBasicPerformance_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquityOption_PriceReturnBasicPerformance_Basket(
                    EconomicTermsForProduct(product)
                ) = True

func IsInterestRateDebtOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_Option_DebtOption(EconomicTermsForProduct(product)) = True

func IsVarianceSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnVariance_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVariance_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVariance_Basket(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDispersion(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_ForeignExchange_ParameterReturnVariance(
                    EconomicTermsForProduct(product)
                ) = True

func IsVolatilitySwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnVolatility_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVolatility_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVolatility_Basket(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_ForeignExchange_ParameterReturnVolatility(
                    EconomicTermsForProduct(product)
                ) = True

func IsDividendSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnDividend_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDividend_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDividend_Basket(
                    EconomicTermsForProduct(product)
                ) = True

func IsFixedFloatZeroCouponSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon(EconomicTermsForProduct(product)) = True
            or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                    EconomicTermsForProduct(product)
                ) = True

func IsFixedFloatZeroCouponSwapKnownAmount:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    set result:
        IsFixedFloatZeroCouponSwap(product) = True
            and InterestRateLeg1ZeroCouponSwapKnownAmount(product) exists

//End product qualification logic
//Utility - Interest rate leg ordering
//Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0
//EMIR best practice positioned in regulation-common as it is used across global jurisdictions
func IsTotalReturnSwapDebtUnderlier:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    alias performanceUnderlier:
        product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> underlier

    set result:
        (product -> contractualProduct -> economicTerms -> payout -> interestRatePayout, product -> contractualProduct -> economicTerms -> payout -> performancePayout) only exists
            and if performanceUnderlier exists
                then performanceUnderlier -> loan exists
                        or performanceUnderlier -> security -> securityType = SecurityTypeEnum -> Debt

func ProductOrUnderlierProduct:
    inputs:
        product Product (1..1)
    output:
        productOrUnderlierProduct Product (1..1)
    set productOrUnderlierProduct:
        if IsProductWithUnderlier(product)
        then UnderlierForProduct(product)
        else product

func InterestRateLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    [regulatoryReference ISDA EMIRReportingBestPractice date "20221117"
        provision "For a single-currency ZC IR Swap with a Known Amount, DRR relies on the underlying notional being the same on each leg (i.e. notional(fixed) = notional(float))"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        if IsFixedFloatZeroCouponSwapKnownAmount(product)
        then InterestRateLeg1ZeroCouponSwapKnownAmount(product)
        else if IsInterestRateFixedFloatSingleCurrency(product)
        then InterestRateLeg1FixedFloatSingleCurrency(product)
        else if IsInterestRateCrossCurrency(product)
        then InterestRateLeg1CrossCurrency(product)
        else if IsInterestRateFixedFixed(product)
        then InterestRateLeg1FixedFixed(product)
        else if IsInterestRateBasis(product)
        then InterestRateLeg1Basis(product)
        else if IsCapFloor(product)
        then InterestRateLeg1CapFloor(product)
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element
        else if IsInterestRateReturnSwap(product)
        then (if EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> contractualProduct exists
            then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element
            else if EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security exists
            then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security -> economicTerms -> payout -> interestRatePayout only-element)

func InterestRateLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    set interestRateLeg2:
        if IsInterestRateFixedFloatSingleCurrency(product)
                or IsFixedFloatZeroCouponSwapKnownAmount(product)
        then InterestRateLeg2FixedFloatSingleCurrency(product)
        else if IsInterestRateCrossCurrency(product)
        then InterestRateLeg2CrossCurrency(product)
        else if IsInterestRateFixedFixed(product)
        then InterestRateLeg2FixedFixed(product)
        else if IsInterestRateBasis(product)
        then InterestRateLeg2Basis(product)
        else if IsTotalReturnSwapDebtUnderlier(product)
        then InterestRateReturnSwap(product)
        else if IsEquity(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func InterestRateLeg1CrossCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> priceQuantity -> quantitySchedule exists
        then interestRatePayouts
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]
        else if interestRatePayouts -> priceQuantity -> quantityReference exists
        then interestRatePayouts
            min [
                item -> priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
            ]

func InterestRateLeg2CrossCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> priceQuantity -> quantitySchedule exists
        then interestRatePayouts
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]
        else if interestRatePayouts -> priceQuantity -> quantityReference exists
        then interestRatePayouts
            max [
                item -> priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
            ]

func InterestRateLeg1FixedFloatSingleCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter item -> rateSpecification -> fixedRate exists
            then only-element

func InterestRateLeg2FixedFloatSingleCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    set interestRateLeg2:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter
                item -> rateSpecification -> floatingRate exists
                    or item -> rateSpecification -> inflationRate exists
            then only-element

func InterestRateLeg1ZeroCouponSwapKnownAmount:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter item -> priceQuantity exists and item -> rateSpecification is absent
            then only-element

func InterestRateLeg1FixedFixed:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> rateSpecification -> fixedRate distinct count = 1
        then interestRatePayouts min [ CalculationPeriodToDays(item) ]
        else if interestRatePayouts -> rateSpecification -> fixedRate distinct count > 1
        then interestRatePayouts
            max [ item -> rateSpecification -> fixedRate -> rateSchedule -> price -> value ]

func InterestRateLeg2FixedFixed:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> rateSpecification -> fixedRate distinct count = 1
        then interestRatePayouts max [ CalculationPeriodToDays(item) ]
        else if interestRatePayouts -> rateSpecification -> fixedRate distinct count > 1
        then interestRatePayouts
            min [ item -> rateSpecification -> fixedRate -> rateSchedule -> price -> value ]

func InterestRateLeg1CapFloor:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func InterestRateLeg1Basis:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
                distinct
                count > 1
        then interestRatePayouts
            max [
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
            ]
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule
                distinct
                count = 1
        then (interestRatePayouts
            filter
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value exists
            then only-element)
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule is absent
        then interestRatePayouts min [ ResetFrequencyPeriodToDays(item) ]

func InterestRateLeg2Basis:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
                distinct
                count > 1
        then interestRatePayouts
            min [
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
            ]
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule
                distinct
                count = 1
        then (interestRatePayouts
            filter
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value is absent
            then only-element)
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule is absent
        then interestRatePayouts max [ ResetFrequencyPeriodToDays(item) ]

func ResetFrequencyPeriod:
    inputs:
        resetFrequency ResetFrequency (1..1)
    output:
        period string (0..1)
    set period:
        if resetFrequency -> period = PeriodExtendedEnum -> D
        then "DAIL"
        else if resetFrequency -> period = PeriodExtendedEnum -> W
        then "WEEK"
        else if resetFrequency -> period = PeriodExtendedEnum -> M
        then "MNTH"
        else if resetFrequency -> period = PeriodExtendedEnum -> Y
        then "YEAR"
        else if resetFrequency -> period = PeriodExtendedEnum -> T
        then "EXPI"

func ResetFrequencyPeriodToDays:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        result int (1..1)
    alias resetDates: interestRatePayout -> resetDates
    set result:
        PeriodCalculation(
                resetDates -> resetFrequency -> period,
                resetDates -> resetFrequency -> periodMultiplier,
                resetDates -> calculationPeriodDatesReference -> effectiveDate -> adjustableDate -> unadjustedDate,
                resetDates -> calculationPeriodDatesReference -> terminationDate -> adjustableDate -> unadjustedDate
            )

func CalculationPeriodToDays:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        result int (1..1)
    alias calculationPeriodDates: interestRatePayout -> calculationPeriodDates
    set result:
        PeriodCalculation(
                calculationPeriodDates -> calculationPeriodFrequency -> period,
                calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier,
                calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
                calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate
            )

func CalculationPeriodToDaysCommodities:
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        result int (1..1)
    alias calculationPeriodDates: commodityPayout -> calculationPeriodDates
    set result:
        PeriodCalculation(
                calculationPeriodDates -> calculationPeriodFrequency -> period,
                calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier,
                calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
                calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate
            )

func PeriodCalculation:
    inputs:
        period PeriodExtendedEnum (1..1)
        periodMultiplier int (1..1)
        effectiveDate date (1..1)
        terminationDate date (1..1)
    output:
        result int (1..1)
    set result:
        if period = PeriodExtendedEnum -> D
        then periodMultiplier
        else if period = PeriodExtendedEnum -> W
        then periodMultiplier * 7
        else if period = PeriodExtendedEnum -> M
        then periodMultiplier * 30
        else if period = PeriodExtendedEnum -> Y
        then periodMultiplier * 365
        else if period = PeriodExtendedEnum -> T or period = PeriodExtendedEnum -> C
        then periodMultiplier * DateDifference(effectiveDate, terminationDate)

func GetCommodityKey:
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        key string (0..1)

func CommodityLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        commodityLeg1 CommodityPayout (0..1)
    alias commodityPayouts: EconomicTermsForProduct(product) -> payout -> commodityPayout
    set commodityLeg1:
        if IsCommoditySwapFloatFloat(product)
        then CommodityCommodityLeg1(commodityPayouts) // moved to separate func due to nested if/else code gen issue
        else if IsCommodityFloatingPriceForward(product)
        then commodityPayouts only-element

func CommodityCommodityLeg1:
    inputs:
        commodityPayouts CommodityPayout (0..*)
    output:
        commodityLeg1 CommodityPayout (0..1)

    set commodityLeg1:
        if (commodityPayouts
            extract GetCommodityKey(item)
            then exists)
        then commodityPayouts min [ GetCommodityKey(item) ]
        else if commodityPayouts -> priceQuantity -> resolvedQuantity -> value
                distinct
                count = 1
        then commodityPayouts min [ CalculationPeriodToDaysCommodities(item) ]
        else commodityPayouts max [ item -> priceQuantity -> quantitySchedule -> value ]

func CommodityLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        commodityLeg2 CommodityPayout (0..1)
    alias commodityPayouts: EconomicTermsForProduct(product) -> payout -> commodityPayout
    set commodityLeg2:
        if IsCommoditySwapFloatFloat(product)
        then CommodityCommodityLeg2(commodityPayouts) // moved to separate func due to nested if/else code gen issue
        else if IsCommoditySwapFixedFloat(product)
        then commodityPayouts only-element

func CommodityCommodityLeg2:
    inputs:
        commodityPayouts CommodityPayout (0..*)
    output:
        commodityLeg2 CommodityPayout (0..1)
    set commodityLeg2:
        if (commodityPayouts
            extract GetCommodityKey(item)
            then exists)
        then commodityPayouts max [ GetCommodityKey(item) ]
        else if commodityPayouts -> priceQuantity -> resolvedQuantity -> value
                distinct
                count = 1
        then commodityPayouts max [ CalculationPeriodToDaysCommodities(item) ]
        else commodityPayouts min [ item -> priceQuantity -> quantitySchedule -> value ]

func FixedPriceLeg1:
    inputs:
        product Product (1..1)
    output:
        fixedPrice FixedPricePayout (0..1)

    set fixedPrice:
        if IsCommoditySwapFixedFloat(product) or IsCommodityFixedPriceForward(product)
        then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element

func FXLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        fxLeg1 Cashflow (0..1)
    set fxLeg1:
        if IsFXForward(product) or IsFXOption(product)
        then [UnderlierForProduct(product) -> foreignExchange -> exchangedCurrency1, UnderlierForProduct(
                    product
                ) -> foreignExchange -> exchangedCurrency2]
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        fxLeg2 Cashflow (0..1)
    set fxLeg2:
        if IsFXForward(product) or IsFXOption(product)
        then [UnderlierForProduct(product) -> foreignExchange -> exchangedCurrency1, UnderlierForProduct(
                    product
                ) -> foreignExchange -> exchangedCurrency2]
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXNearLeg:
    inputs:
        product Product (1..1)
    output:
        nearLegPayout ForwardPayout (0..1)
    alias forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout
    set nearLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> settlementTerms -> settlementDate -> valueDate exists
        then forwardPayout min [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then forwardPayout
            min [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]

func FXFarLeg:
    inputs:
        product Product (1..1)
    output:
        nearLegPayout ForwardPayout (0..1)
    alias forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout
    set nearLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> settlementTerms -> settlementDate -> valueDate exists
        then forwardPayout max [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then forwardPayout
            max [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]

func FXSwapLeg1:
    inputs:
        product Product (1..1)
    output:
        fxLeg1 Cashflow (0..1)
    alias farLeg: FXFarLeg(product)
    set fxLeg1:
        [farLeg -> underlier -> foreignExchange -> exchangedCurrency1, farLeg -> underlier -> foreignExchange -> exchangedCurrency2]
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXSwapLeg2:
    inputs:
        product Product (1..1)
    output:
        fxLeg2 Cashflow (0..1)
    alias farLeg: FXFarLeg(product)
    set fxLeg2:
        [farLeg -> underlier -> foreignExchange -> exchangedCurrency1, farLeg -> underlier -> foreignExchange -> exchangedCurrency2]
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func CommodityQuantity: <"Commodity Notional Quantity">
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        quantity number (0..1)
    set quantity:
        if commodityPayout -> priceQuantity -> quantitySchedule -> value exists
        then commodityPayout -> priceQuantity -> quantitySchedule -> value

func CommodityFixedPriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
    output:
        fixedLegPriceQuantity PriceQuantity (0..1)
    set fixedLegPriceQuantity:
        tradeLot -> priceQuantity
            filter item -> observable is absent
            then only-element

func QuantityFrequencyOrCalculationPeriod:
    inputs:
        calculationPeriodDates CalculationPeriodDates (1..1)
        priceQuantity PriceQuantity (1..1)
    output:
        frequency Frequency (0..1)
    alias quantity:
        priceQuantity -> quantity
            filter item -> value exists or item -> datedValue -> value distinct count = 1
    set frequency:
        if quantity -> frequency -> period only-element <> PeriodExtendedEnum -> C
        then quantity -> frequency only-element
        else if quantity -> frequency -> period only-element = PeriodExtendedEnum -> C
        then calculationPeriodDates -> calculationPeriodFrequency

func FrequencyPeriod:
    inputs:
        priceQuantity PriceQuantity (1..1)
        frequency Frequency (0..1)
    output:
        period string (0..1)
    alias quantity:
        priceQuantity -> quantity
            filter
                item -> frequency exists
                    and (item -> value exists or item -> datedValue -> value distinct count = 1)
    set period:
        if frequency -> period = PeriodExtendedEnum -> D
        then "DAIL"
        else if frequency -> period = PeriodExtendedEnum -> W
        then "WEEK"
        else if frequency -> period = PeriodExtendedEnum -> M
        then "MNTH"
        else if frequency -> period = PeriodExtendedEnum -> Y
        then "YEAR"
        else if frequency -> period = PeriodExtendedEnum -> T
        then "EXPI"
        else if frequency -> period = PeriodExtendedEnum -> H
        then "HOUL"
        else if frequency is absent and quantity exists
        then "ADHO"

func FrequencyPeriodMultiplier:
    inputs:
        frequency Frequency (1..1)
    output:
        periodMultiplier int (0..1)
    set periodMultiplier: frequency -> periodMultiplier

func CommodityFrequencyMultiplier: <"Commodity Quantity Frequency Multiplier">
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        periodMultiplier int (0..1)
    set periodMultiplier:
        if commodityPayout -> priceQuantity -> quantitySchedule exists
        then commodityPayout -> priceQuantity -> quantitySchedule -> frequency -> periodMultiplier

func PartyLei: <"Returns a single Party LEI from a list of party identifiers">
    inputs:
        partyIdentifier PartyIdentifier (1..*)
    output:
        partyLei string (0..1)
    set partyLei:
        partyIdentifier
            filter identifierType = PartyIdentifierTypeEnum -> LEI
            then identifier distinct only-element

func PartyLeiAndPersonByRoles: <"Returns a concatenated Party LEI and Person Id, or a Party LEI, from a PartyInformation.">
    inputs:
        party Party (0..1)
        reportingParty Party (0..1)
    output:
        partyPersonLei string (0..1)

    alias partyLei:
        if party -> partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
        then PartyLei(party -> partyId)

    alias partyPersonId: // Returns a Person Id from a Party
        party
            filter [
                personRole -> role // role is multi-cardinality
                    extract r [ PartyIdentifierNaturalPersonRoles contains r ]
                any = True
            ]
            then extract person -> personId -> identifier
            then only-element

    alias reportingPartyLei:
        if reportingParty -> partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
        then PartyLei(reportingParty -> partyId)

    set partyPersonLei:
        if partyPersonId exists
        then (if reportingPartyLei exists then reportingPartyLei + partyPersonId else partyLei + partyPersonId)
        else partyLei

func PartyIdentifierFormat: <"Returns a Person Id from a Party.">
    inputs:
        party Party (1..1)
    output:
        partyIdentifierFormat PartyIdentifierFormatEnum (1..1)

    alias personId:
        party
            filter [
                personRole -> role // role is multi-cardinality
                    extract r [ PartyIdentifierNaturalPersonRoles contains r ]
                any = True
            ]
            then extract person -> personId -> identifier
            then only-element
    set partyIdentifierFormat:
        if personId exists
        then PartyIdentifierFormatEnum -> LeiAndPerson
        else PartyIdentifierFormatEnum -> Lei

func PartyIdentifierNaturalPersonRoles:
    output:
        roles NaturalPersonRoleEnum (0..*)
    add roles: [NaturalPersonRoleEnum -> Buyer, NaturalPersonRoleEnum -> Seller]

func FilterPartyInformationBySupervisoryBody:
    inputs:
        partyInformation PartyInformation (1..*)
        jurisdiction SupervisoryBodyEnum (1..1)
    output:
        filteredPartyInformation PartyInformation (1..*)
    add filteredPartyInformation:
        partyInformation
            filter item -> regimeInformation -> supervisoryBody any = jurisdiction

func ExtractOtherPaymentPayer:
    inputs:
        transferState TransferState (0..1)
        transactionReportInstruction TransactionReportInstruction (0..1)
    output:
        partyPersonLei string (0..1)
    set partyPersonLei:
        PartyLeiAndPersonByRoles(
                transferState -> transfer -> payerReceiver -> payerPartyReference,
                transactionReportInstruction -> reportingSide -> reportingParty
            )

func ExtractOtherPaymentReceiver:
    inputs:
        transferState TransferState (0..1)
        transactionReportInstruction TransactionReportInstruction (0..1)
    output:
        partyPersonLei string (0..1)
    set partyPersonLei:
        PartyLeiAndPersonByRoles(
                transferState -> transfer -> payerReceiver -> receiverPartyReference,
                transactionReportInstruction -> reportingSide -> reportingParty
            )

func ExtractPartyResponsibleForReporting: <"Extracts the reporting party for a supervisory body (e.g. CFTC).">
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        partyResponsibleForReporting Party (0..1)

    set partyResponsibleForReporting:
        if reportingSide -> partyResponsibleForReporting exists
        then reportingSide -> partyResponsibleForReporting
        else reportingSide -> reportingParty

func ExtractPartyResponsibleForReportingIdentifier:
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        identifier string (0..1)

    set identifier:
        ExtractPartyResponsibleForReporting(reportingSide) extract PartyLei(partyId)

func ExtractReportSubmittingParty: <"Extracts the reporting party for a supervisory body (e.g. CFTC).">
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        reportSubmittingParty Party (0..1)

    alias reportSubmittingPartyFromReportingSide: reportingSide -> reportSubmittingParty

    set reportSubmittingParty:
        if reportingSide -> reportSubmittingParty exists
        then reportingSide -> reportSubmittingParty
        else reportingSide -> reportingParty

func ExtractReportSubmittingPartyIdentifier:
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        identifier string (0..1)

    set identifier: ExtractReportSubmittingParty(reportingSide) extract PartyLei(partyId)

func ExtractPartyFromRelatedPartyByRole:
    inputs:
        relatedParties RelatedParty (0..*)
        partyRole PartyRoleEnum (1..1)
    output:
        party Party (0..1)

    set party:
        FilterRelatedPartyByRole(relatedParties, partyRole) -> partyReference
            distinct
            only-element

func SettlementTermsLeg1:
    inputs:
        product Product (1..1)
    output:
        settlementTerms SettlementTerms (0..1)

    alias economicTerms: EconomicTermsForProduct(product)

    set settlementTerms:
        // Interest Rates + Credit
        if InterestRateLeg1(product) -> settlementTerms exists
        then InterestRateLeg1(product) -> settlementTerms // to be adapted to take economicTerms if possible
            // Credit
        else if economicTerms -> payout -> creditDefaultPayout -> settlementTerms exists
        then economicTerms -> payout -> creditDefaultPayout -> settlementTerms
        // Equities
        else if economicTerms -> payout -> performancePayout -> settlementTerms exists
        then economicTerms -> payout -> performancePayout only-element -> settlementTerms
        // FX Swaps
        else if IsFXSwap(product)
        then FXFarLeg(product) -> settlementTerms
        // Commodities   //functions to be adapted to take economicTerms if possible
        else if IsCommoditySwapFloatFloat(product)
        then CommodityLeg1(product) -> settlementTerms
        else if IsSingleCommodityPayoutProduct(product)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> settlementTerms
        else if IsCommoditySwapFixedFloat(product)
        then FixedPriceLeg1(product) -> settlementTerms
        else if IsCommodityFixedPriceForward(product) = True
        then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element -> settlementTerms
        else if IsCommodityFloatingPriceForward(product) = True
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> settlementTerms
        // Options
        else if economicTerms -> payout -> optionPayout -> settlementTerms exists
        then economicTerms -> payout -> optionPayout only-element -> settlementTerms
        // Forwards
        else if economicTerms -> payout -> forwardPayout only-element -> settlementTerms exists
        then economicTerms -> payout -> forwardPayout only-element -> settlementTerms

func SettlementTermsLeg2:
    inputs:
        product Product (1..1)
    output:
        settlementTerms SettlementTerms (0..1)
    set settlementTerms:
        // Interest Rates + Equity
        if InterestRateLeg2(product) -> settlementTerms exists
        then InterestRateLeg2(product) -> settlementTerms
        // FX Swaps
        else if IsFXSwap(product)
        then FXNearLeg(product) -> settlementTerms
        // Commodities
        else if IsCommoditySwap(product)
        then CommodityLeg2(product) -> settlementTerms
        else if IsCommodityForward(product)
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> settlementTerms
        // Equities
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> settlementTerms exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> settlementTerms

func IsCleared: <"Qualifies a transaction that has been cleared by a CCP.">
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        originatingWorkflowStep -> workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
            or (( // Trade already cleared in a previous WorkflowStep
                originatingWorkflowStep -> timestamp -> qualification any = EventTimestampQualificationEnum -> clearingDateTime
                        // There's an ongoing clearing process - CDM-native
                    or Qualify_ClearedTrade(originatingWorkflowStep -> businessEvent) = True
                        // There's an ongoing clearing process - ingested event
                    or originatingWorkflowStep -> businessEvent -> intent = Clearing)
                        // The Trade is not intended to clear (alpha TERM discarded)
                and IntendedToClear(originatingWorkflowStep) = False)

func IsCompressed:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_Compression(originatingWorkflowStep -> businessEvent) = True
            or originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> Compression

func IsPortfolioRebalancing:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_PortfolioRebalancing(originatingWorkflowStep -> businessEvent) = True
            or originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> PortfolioRebalancing

func IsPriceMonetary:
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> unit -> currency exists
            and (price -> perUnitOf -> currency is absent // Hence not a rate
                or price -> perUnitOf -> currency <> price -> unit -> currency // Hence a currency Pair
                )

func IsOtherPayment:
    inputs:
        transferState TransferState (1..1)
    output:
        result boolean (1..1)
    alias transferExpression: transferState -> transfer -> transferExpression
    set result:
        transferExpression -> priceTransfer = FeeTypeEnum -> Upfront
            or transferExpression -> priceTransfer = FeeTypeEnum -> Termination
            or transferExpression -> priceTransfer = FeeTypeEnum -> PartialTermination
            or transferExpression -> scheduledTransfer -> transferType = ScheduledTransferEnum -> PrincipalPayment

func MaxTerminationDate:
    inputs:
        date1 AdjustableDate (0..1)
        date2 AdjustableDate (0..1)
    output:
        date date (0..1)

    set date:
        if AdjustableDateResolution(date1) > AdjustableDateResolution(date2)
        then AdjustableDateResolution(date1)
        else AdjustableDateResolution(date2)

func CapacityUnitToISO20022UnitOfMeasure:
    inputs:
        capacityUnit CapacityUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if capacityUnit = CapacityUnitEnum -> ALW
        then "ALOW"
        else if capacityUnit = CapacityUnitEnum -> BBL
        then "BARL"
        else if capacityUnit = CapacityUnitEnum -> BCF
        then "BCUF"
        else if capacityUnit = CapacityUnitEnum -> BDFT
        then "BDFT"
        else if capacityUnit = CapacityUnitEnum -> GBBSH
        then "BUSL"
        else if capacityUnit = CapacityUnitEnum -> GBBTU
        then "BRTU"
        else if capacityUnit = CapacityUnitEnum -> CBM
        then "CBME"
        else if capacityUnit = CapacityUnitEnum -> CER
        then "CEER"
        else if capacityUnit = CapacityUnitEnum -> CRT
        then "CLRT"
        else if capacityUnit = CapacityUnitEnum -> DAG
        then "----"
        else if capacityUnit = CapacityUnitEnum -> DAY
        then "DAYS"
        else if capacityUnit = CapacityUnitEnum -> DMTU
        then "DMET"
        else if capacityUnit = CapacityUnitEnum -> ENVCRD
        then "ENVC"
        else if capacityUnit = CapacityUnitEnum -> ENVOFST
        then "ENVO"
        else if capacityUnit = CapacityUnitEnum -> FEU
        then "----"
        else if capacityUnit = CapacityUnitEnum -> G
        then "GRAM"
        else if capacityUnit = CapacityUnitEnum -> GBCWT
        then "HUWG"
        else if capacityUnit = CapacityUnitEnum -> GBGAL
        then "GBGA"
        else if capacityUnit = CapacityUnitEnum -> GBT
        then "GBTN"
        else if capacityUnit = CapacityUnitEnum -> GJ
        then "GGJL"
        else if capacityUnit = CapacityUnitEnum -> GW
        then "----"
        else if capacityUnit = CapacityUnitEnum -> GWH
        then "GWHO"
        else if capacityUnit = CapacityUnitEnum -> HL
        then "----"
        else if capacityUnit = CapacityUnitEnum -> J
        then "JOUL"
        else if capacityUnit = CapacityUnitEnum -> KG
        then "KILO"
        else if capacityUnit = CapacityUnitEnum -> KL
        then ""
        else if capacityUnit = CapacityUnitEnum -> KW
        then "----"
        else if capacityUnit = CapacityUnitEnum -> KWD
        then "KWDC"
        else if capacityUnit = CapacityUnitEnum -> KWH
        then "KWHO"
        else if capacityUnit = CapacityUnitEnum -> KWH
        then "KWHC"
        else if capacityUnit = CapacityUnitEnum -> KWMIN
        then "KMOC"
        else if capacityUnit = CapacityUnitEnum -> KWM
        then "KWMC"
        else if capacityUnit = CapacityUnitEnum -> KWY
        then "KWYC"
        else if capacityUnit = CapacityUnitEnum -> L
        then "LITR"
        else if capacityUnit = CapacityUnitEnum -> LB
        then "PUND"
        else if capacityUnit = CapacityUnitEnum -> MB
        then "---"
        else if capacityUnit = CapacityUnitEnum -> MBF
        then "---"
        else if capacityUnit = CapacityUnitEnum -> MJ
        then "---"
        else if capacityUnit = CapacityUnitEnum -> MMBF
        then "---"
        else if capacityUnit = CapacityUnitEnum -> MMBBL
        then "MIBA"
        else if capacityUnit = CapacityUnitEnum -> USMMBTU
        then "MBTU"
        else if capacityUnit = CapacityUnitEnum -> MSF
        then "----"
        else if capacityUnit = CapacityUnitEnum -> MT
        then "TONE"
        else if capacityUnit = CapacityUnitEnum -> MW
        then "----"
        else if capacityUnit = CapacityUnitEnum -> MWD
        then "MWDC"
        else if capacityUnit = CapacityUnitEnum -> MWH
        then "MWHO"
        else if capacityUnit = CapacityUnitEnum -> MWH
        then "MWHC"
        else if capacityUnit = CapacityUnitEnum -> MWM
        then "MMOC"
        else if capacityUnit = CapacityUnitEnum -> MWMIN
        then "MWMC"
        else if capacityUnit = CapacityUnitEnum -> MWY
        then "MWYC"
        else if capacityUnit = CapacityUnitEnum -> OZT
        then "OZTR"
        else if capacityUnit = CapacityUnitEnum -> TEU
        then "----"
        else if capacityUnit = CapacityUnitEnum -> USTHM
        then "THMS"
        else if capacityUnit = CapacityUnitEnum -> USCWT
        then "UCWT"
        else if capacityUnit = CapacityUnitEnum -> USGAL
        then "USGA"
        else if capacityUnit = CapacityUnitEnum -> UST
        then "USTN"

func WeatherUnitToISO20022UnitOfMeasure:
    inputs:
        weatherUnit WeatherUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if weatherUnit = WeatherUnitEnum -> CDD
        then "CDDA"
        else if weatherUnit = WeatherUnitEnum -> CPD
        then "CPDA"
        else if weatherUnit = WeatherUnitEnum -> HDD
        then "HDDA"

func FinancialUnitToISO20022UnitOfMeasure:
    inputs:
        financialUnit FinancialUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if financialUnit = FinancialUnitEnum -> Contract
        then "LOTS"
        else if financialUnit = FinancialUnitEnum -> ContractualProduct
        then "ACCY"
        else if financialUnit = FinancialUnitEnum -> IndexUnit
        then "IPNT"
        else if financialUnit = FinancialUnitEnum -> LogNormalVolatility
        then "----"
        else if financialUnit = FinancialUnitEnum -> Share
        then "SHAS"
        else if financialUnit = FinancialUnitEnum -> ValuePerDay
        then "----"
        else if financialUnit = FinancialUnitEnum -> ValuePerPercent
        then "----"

func ExtractTradeCounterparty:
    inputs:
        reportableEvent ReportableEvent (1..1)
        role CounterpartyRoleEnum (1..1)
    output:
        counterparty Counterparty (0..1)

    alias counterparties: TradeForEvent(reportableEvent) -> tradableProduct -> counterparty

    set counterparty: ExtractCounterpartyByRole(counterparties, role)

func ClearingExceptionsAndExemptions:
    inputs:
        clearingExceptionReason ClearingExceptionReasonEnum (1..1)
    output:
        result string (1..1)
    set result:
        if clearingExceptionReason = ClearingExceptionReasonEnum -> End_User
        then "ENDU"
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Inter_Affiliate
        then "AFFL"
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> SmallBank
        then "SMBK"
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Cooperative
        then "COOP"
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> NoActionLetter
        then "NOAL"
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Exception
        then "OTHR"

// TH Revision: should values AgentAffiliate and TreasuryAffiliate be reported as a) OTHR, b) AFFL, c) Not reported.
// In case a) line
// if clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "OTHR"
// should be replaced by:
// if clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> AgentAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> TreasuryAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "OTHR"
// In case b) line
// if clearingExceptionReason = ClearingExceptionReasonEnum -> InterAffiliate then "AFFL" else
// should be replaced by:
// if clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> InterAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> TreasuryAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "AFFL" else
// In case c), nothing needs to be changed.
func IsActionTypeTERM:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeTerm boolean (1..1)
    set isActionTypeTerm:
        if (QuantityDecreasedToZero(
                        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before,
                        reportableEvent -> originatingWorkflowStep -> businessEvent -> after
                    ) = True
                or (reportableEvent -> reportableTrade -> state exists and reportableEvent -> reportableTrade -> state -> positionState = PositionStatusEnum -> Closed)
                or (reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after -> state -> positionState only-element = PositionStatusEnum -> Closed)) // TODO to be revisted once counterpartyPositionBusinessEvent supports more than one after state
        then True
        else False

func IntendedToClear:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        isIntendedToClear boolean (1..1)
    set isIntendedToClear:
        if originatingWorkflowStep -> nextEvent -> intent = EventIntentEnum -> Clearing
        then True
        else False

func IsActionTypeMODI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result boolean (1..1)

    alias primitiveInstruction:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction
    alias beforeTradeState:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before only-element
    alias closedTradeStates:
        FilterClosedTradeStates(
                reportableEvent -> originatingWorkflowStep -> businessEvent -> after
            )
    alias openTradeStates:
        FilterOpenTradeStates(
                reportableEvent -> originatingWorkflowStep -> businessEvent -> after
            )
    alias prevUTI:
        BeforeTradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then only-element
            then extract item -> assignedIdentifier -> identifier
    alias currUTI:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then only-element
            then extract item -> assignedIdentifier -> identifier
    alias product: ProductForTrade(TradeForEvent(reportableEvent))

    set result:
        if IsProductETD(product) = False
                and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent is absent
        then if (reportableEvent -> originatingWorkflowStep -> action <> ActionEnum -> Correct
                    and reportableEvent -> originatingWorkflowStep -> action <> ActionEnum -> Cancel
                    and IsActionTypeTERM(reportableEvent) = False)
            then if reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment
                then True
                else if (reportableEvent -> reportableTrade exists
                        and beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference <> reportableEvent -> reportableTrade -> trade -> tradableProduct -> counterparty -> partyReference)
                then False
                else if (Qualify_Exercise(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            ) = True
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionExercise
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionalExtension
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionalCancellation
                        or Qualify_CorporateActionDetermined(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> CorporateActionAdjustment
                        or Qualify_CreditEventDetermined(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> CreditEvent)
                then if prevUTI = currUTI then True else False
                else if QuantityDecreased(beforeTradeState, openTradeStates) = True
                then True
                else if QuantityDecreased(
                            beforeTradeState,
                            [reportableEvent -> reportableTrade]
                        ) = True
                then True
                else if Qualify_Increase(
                            reportableEvent -> originatingWorkflowStep -> businessEvent
                        )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> Increase
                then True
                else if (primitiveInstruction -> termsChange exists or primitiveInstruction -> transfer exists)
                then True
                else if reportableEvent -> reportableInformation -> reportableAction = ReportableActionEnum -> Update
                then True
                else False
            else False
        else False

func IsActionTypeNEWT:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeNewt boolean (1..1)
    set isActionTypeNewt:
        IsActionTypeTERM(reportableEvent) = False
            and IsActionTypeMODI(reportableEvent) = False
            and IsActionTypePositionMODI(reportableEvent) = False
            and IsActionTypePOSC(reportableEvent) = False
            and (reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
                or reportableEvent -> originatingWorkflowStep -> action is absent)

func IsActionTypeCORR:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeCorr boolean (1..1)

    alias workflowStepAction: reportableEvent -> originatingWorkflowStep -> action
    alias reportingAction: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeCorr:
        (reportingAction exists and reportingAction = ReportableActionEnum -> Correct)
            or (workflowStepAction = ActionEnum -> Correct)

func IsActionTypeVALU:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeValu boolean (1..1)
    set isActionTypeValu:
        Qualify_ValuationUpdate(reportableEvent -> originatingWorkflowStep -> businessEvent)

func IsActionTypeEROR:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeEror boolean (1..1)

    alias workflowStepAction: reportableEvent -> originatingWorkflowStep -> action
    alias reportingAction: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeEror:
        (reportingAction exists and reportingAction = ReportableActionEnum -> Error)
            or (workflowStepAction = ActionEnum -> Cancel)

func IsActionTypeREVI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeRevi boolean (1..1)
    alias action: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeRevi: action exists and action = ReportableActionEnum -> Revive

func IsEventTypeUPDT: <"The qualification of the Update event as an upgrade of an outstanding transaction performed in order to ensure its conformity with the amended reporting requirements.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isEventTypeUpdt boolean (1..1)
    alias event: reportableEvent -> reportableInformation -> reportableAction
    set isEventTypeUpdt: event exists and event = ReportableActionEnum -> Update

func IsActionTypePRTO: <"The qualification of the Transfer Out action that transfers swap transaction from one SDR to another SOR (change of swap data repository).">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePrto boolean (1..1)
    alias action: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypePrto: action exists and action = ReportableActionEnum -> TransferOut

func IsEventTypePTNG: <"The qualification of the Transfer In event by which a swap is transferred to another SDR that has the effect of the closing of the suap transaction at one 50 or opening of the same swap transaction using the same UTI/USI in a different SDR (new).">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isEventTypePtng boolean (1..1)
    alias event: reportableEvent -> reportableInformation -> reportableAction
    set isEventTypePtng: event exists and event = ReportableActionEnum -> TransferIn

func IsActionTypePOSC:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePosc boolean (1..1)
    alias product: ProductForTrade(TradeForEvent(reportableEvent))
    set isActionTypePosc:
        reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
            and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent is absent
            and IsProductETD(product)

func IsActionTypePositionMODI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePositionModi boolean (1..1)
    alias product: ProductForTrade(TradeForEvent(reportableEvent))
    alias openPositionDate:
        reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after -> counterpartyPosition -> openDateTime -> date
            distinct
            only-element // opentDateTime always the same
    alias eventDate:
        reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> eventDate
    set isActionTypePositionModi:
        if reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
                and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                and (openPositionDate < eventDate)
                and IsActionTypeTERM(reportableEvent) = False
        then True
        else False

func IsAllowableAction:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isAllowableAction boolean (1..1)

    set isAllowableAction:
        IsActionTypeNEWT(reportableEvent)
            or IsActionTypeMODI(reportableEvent)
            or IsActionTypePositionMODI(reportableEvent)
            or IsActionTypeCORR(reportableEvent)
            or IsActionTypeREVI(reportableEvent)
            or IsActionTypePOSC(reportableEvent)

func IsVRAllowedForActionType:
    inputs:
        actionTypefromTrade ActionTypeEnum (1..1)
    output:
        validActionType boolean (1..1)
    set validActionType:
        actionTypefromTrade = ActionTypeEnum -> NEWT
            or actionTypefromTrade = ActionTypeEnum -> MODI
            or actionTypefromTrade = ActionTypeEnum -> CORR
            or actionTypefromTrade = ActionTypeEnum -> REVI
            or actionTypefromTrade = ActionTypeEnum -> POSC

func BeforeTradeByUTI:
    inputs:
        reportableEvent ReportableEvent (1..1)
        afterTradeUTI string (1..1)
    output:
        trade Trade (1..1)
    set trade:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before -> trade
            filter
                item -> tradeIdentifier -> assignedIdentifier -> identifier any = afterTradeUTI
            then only-element

func GetProductQualifier:
    inputs:
        productTaxonomy ProductTaxonomy (0..*)
    output:
        qualifier string (0..1)
    set qualifier:
        productTaxonomy
            extract item -> productQualifier
            then only-element

func CommodityObservablePriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
        commodityPayout CommodityPayout (1..1)
    output:
        priceQuantity PriceQuantity (1..1)

    alias priceQuantityWithMatchingObservable:
        tradeLot -> priceQuantity
            then filter
                item -> observable -> commodity = commodityPayout -> underlier -> commodity
            then only-element

    alias priceQuantityWithMatchingKey:
        tradeLot -> priceQuantity
            filter
                GetQuantityKeys(item)
                    contains GetQuantityReference(commodityPayout -> priceQuantity)
            then only-element

    set priceQuantity:
        if priceQuantityWithMatchingObservable exists
        then priceQuantityWithMatchingObservable
        else priceQuantityWithMatchingKey

func CommodityForwardObservablePriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
        forwardPayout ForwardPayout (1..1)
    output:
        priceQuantity PriceQuantity (1..1)

    alias priceQuantityWithMatchingObservable:
        tradeLot -> priceQuantity
            then filter
                item -> observable -> commodity = forwardPayout -> underlier -> commodity
            then only-element

    alias priceQuantityWithMatchingKey:
        tradeLot -> priceQuantity
            filter
                GetQuantityKeys(item)
                    contains GetQuantityReference(forwardPayout -> priceQuantity)
            then only-element

    set priceQuantity:
        if priceQuantityWithMatchingObservable exists
        then priceQuantityWithMatchingObservable
        else priceQuantityWithMatchingKey

func GetQuantityKeys: <"Extract key from each quantity.">
    inputs:
        priceQuantity PriceQuantity (0..1)
    output:
        keyValues string (0..*)

func GetQuantityReference: <"Extract reference from quantity.">
    inputs:
        resolvablePriceQuantity ResolvablePriceQuantity (0..1)
    output:
        referenceValue string (0..1)

func AdjustableDateResolution: <"A fall back for unadjustedDate when adjustedDate is only available. If an adjusted date is only provided then fields requiring an unadjusted date are left blank which will result in a NACK from the TR.">
    inputs:
        adjustableDate AdjustableDate (1..1)
    output:
        date date (0..1)

    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func MinAdjustableDateResolution: <"Finds the earliest date in the list.">
    inputs:
        adjustableDates AdjustableDate (0..*)
    output:
        date date (0..1)

    set date:
        adjustableDates
            extract AdjustableDateResolution(item)
            then min

func AdjustableDatesResolution: <"A fall back for unadjustedDate when adjustedDate is only available. If an adjusted date is only provided then fields requiring an unadjusted date are left blank which will result in a NACK from the TR.">
    inputs:
        adjustableDates AdjustableDates (1..1)
    output:
        date date (0..*)

    add date:
        if adjustableDates -> unadjustedDate exists
        then adjustableDates -> unadjustedDate
        else adjustableDates -> adjustedDate

func AdjustableOrAdjustedOrRelativeDateResolution:
    inputs:
        adjustableDate AdjustableOrAdjustedOrRelativeDate (1..1)
    output:
        date date (0..1)
    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func IsPackageIndicator: <"">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        packageIndicator boolean (1..1)

    set packageIndicator:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation exists
            or reportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade -> executionDetails -> packageReference exists

func GetPackageInformation: <"Find package IdentifiedList from TransactionReportInstruction">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        packageInformation IdentifiedList (0..1)

    set packageInformation:
        if reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation exists
        then reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation
        else if TradeForEvent(reportableEvent) -> executionDetails -> packageReference exists
        then TradeForEvent(reportableEvent) -> executionDetails -> packageReference

func GetLeg1ResolvablePriceQuantity:
    inputs:
        trade Trade (1..1)
    output:
        priceQuantity ResolvablePriceQuantity (0..1)

    alias product: ProductForTrade(trade)

    set priceQuantity:
        // IR
        if IsIRSwaption(product)
        then (UnderlierForProduct(product)
            extract InterestRateLeg1(item)
            then extract item -> priceQuantity)
        else if IsGenericIRS(product) or IsCap(product) or IsFloor(product)
        then InterestRateLeg1(product) extract item -> priceQuantity
        // CR
        else if IsCreditSwaption(product)
        then (EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout
            then extract item -> priceQuantity)
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> priceQuantity
        // EQ
        else if IsEquity(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> priceQuantity
        else if IsVolatilitySwap(product) or IsVarianceSwap(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> priceQuantity
        // FX
        else if IsFXForward(product)
        then FXLeg1(product) extract item -> priceQuantity
        else if IsFXOption(product)
        then FXLeg1(product) extract item -> priceQuantity
        else if IsFXSwap(product)
        then FXSwapLeg1(product) -> priceQuantity
        // CO
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then FixedPriceLeg1(product) -> priceQuantity
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then CommodityLeg1(product) -> priceQuantity
        else if Qualify_Commodity_Option(EconomicTermsForProduct(product))
        then EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> priceQuantity
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
        then (if Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
            then FixedPriceLeg1(UnderlierForProduct(product)) -> priceQuantity
            else if Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
            then CommodityLeg1(UnderlierForProduct(product)) -> priceQuantity)
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
        then (if IsCommodityFixedPriceForward(product)
            then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element -> priceQuantity
            else if IsCommodityFloatingPriceForward(product)
            then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> priceQuantity)
        else if IsSingleCommodityPayoutProduct(product)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> priceQuantity

func GetLeg2ResolvablePriceQuantity:
    inputs:
        trade Trade (1..1)
    output:
        priceQuantity ResolvablePriceQuantity (0..1)

    alias product: ProductForTrade(trade)

    set priceQuantity:
        // IR, EQ
        if IsIRSwaption(product)
        then (InterestRateLeg2(UnderlierForProduct(product))
            then extract item -> priceQuantity)
        else if IsGenericIRS(product) or IsEquitySwap(trade -> tradableProduct)
        then InterestRateLeg2(product) extract item -> priceQuantity
        // FX
        else if IsFXForward(product)
        then FXLeg2(product) extract item -> priceQuantity
        else if IsFXOption(product)
        then FXLeg2(product) extract item -> priceQuantity
        else if IsFXSwap(product)
        then FXSwapLeg2(product) -> priceQuantity
        // CO
        else if IsCommoditySwap(product)
        then CommodityLeg2(product) -> priceQuantity
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
        then CommodityLeg2(UnderlierForProduct(product)) -> priceQuantity
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> priceQuantity

func PriceOfZeroCouponSwaps:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        knownAmountPrice NonNegativeQuantitySchedule (1..*)

    add knownAmountPrice:
        TradableProductForEvent(reportableEvent)
            extract tradeLot -> priceQuantity
            then filter observable is absent
            then extract quantity
            then flatten
            then only-element

func GetPriceNotationEnum:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        priceNotationEnum PriceNotationEnum (0..1)
    set priceNotationEnum:
        if cde.price.PriceNotationEnum(reportableEvent) = PriceNotationEnum -> Percentage
        then PriceNotationEnum -> Decimal
        else cde.price.PriceNotationEnum(reportableEvent)

func PriceOfEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        amount number (1..1)

    alias price: Contract_Price_Monetary(reportableEvent) only-element

    alias eventDate:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> eventDate

    alias schedule:
        // Only applicable for commodity schedules
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
                or Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(ProductForEvent(reportableEvent))
                    )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> commodityPayout -> schedule first
        else if Qualify_Commodity_Option(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
                or Qualify_Commodity_Swaption(
                        EconomicTermsForProduct(ProductForEvent(reportableEvent))
                    )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> optionPayout only-element -> schedule
        else if Qualify_Commodity_Forward(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> forwardPayout only-element -> schedule

    alias schedulePeriod:
        if eventDate <= schedule -> schedulePeriod -> calculationPeriod -> startDate min
        then schedule -> schedulePeriod min [ item -> calculationPeriod -> startDate ]
        else if eventDate >= schedule -> schedulePeriod -> calculationPeriod -> endDate max
        then schedule -> schedulePeriod max [ item -> calculationPeriod -> startDate ]
        else (schedule -> schedulePeriod
            then filter
                item -> calculationPeriod -> startDate <= eventDate and item -> calculationPeriod -> endDate >= eventDate
            then only-element)

    set amount:
        if price -> composite -> operandType = PriceOperandEnum -> AccruedInterest
        then price -> composite -> baseValue
        else if price -> value exists
        then price -> value
        else if price -> datedValue exists
        then (price -> datedValue
            filter item -> date = schedulePeriod -> calculationPeriod -> startDate
            then extract item -> value
            then only-element)

func FindLatestAssignedIdentifier:
    inputs:
        tradeIdentifier TradeIdentifier (1..1)
    output:
        assignedIdentifier AssignedIdentifier (1..1)

    alias assignedIdentifiersWithVersion:
        tradeIdentifier -> assignedIdentifier filter version exists

    set assignedIdentifier:
        if assignedIdentifiersWithVersion count = 0
        then tradeIdentifier -> assignedIdentifier last
        else (assignedIdentifiersWithVersion
            sort [ item -> version ]
            then last)

func FloatingReferencePeriod:
    inputs:
        period PeriodEnum (1..1)
    output:
        result string (1..1)
    set result:
        if period = PeriodEnum -> D
        then "DAIL"
        else if period = PeriodEnum -> W
        then "WEEK"
        else if period = PeriodEnum -> M
        then "MNTH"
        else if period = PeriodEnum -> Y
        then "YEAR"

func GetReportableQuantityPeriodLeg1:
    inputs:
        trade Trade (1..1)
    output:
        reportablePeriod QuantityReportablePeriod (1..*)

    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then FixedPriceLeg1(ProductForTrade(trade)) -> schedule
        else if Qualify_Commodity_Swap_Basis(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then CommodityLeg1(ProductForTrade(trade)) -> schedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if IsCommodityOption(ProductForTrade(trade))
                or Qualify_Commodity_Swaption(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> optionPayout -> schedule only-element
        else if IsCommodityFloatingPriceForward(trade -> tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if IsCommodityFixedPriceForward(trade -> tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> fixedPricePayout only-element -> schedule

    alias quantitySchedule:
        if Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForTrade(trade)))
                or Qualify_AssetClass_Commodity(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then GetLeg1ResolvablePriceQuantity(trade) -> quantitySchedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> priceQuantity -> quantitySchedule

    add reportablePeriod:
        if customizedSchedule exists
        then quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value from quantity period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        quantityPeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        QuantityReportablePeriod {
                            periodValue: quantityPeriod -> value,
                            periodEffectiveDate: matchingCustomPeriod -> calculationPeriod -> startDate,
                            periodEndDate: matchingCustomPeriod -> calculationPeriod -> endDate
                        }
                    ]
            ]
        else quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value and dates from quantity period
                QuantityReportablePeriod {
                    periodValue: quantityPeriod -> value,
                    periodEffectiveDate: quantityPeriod -> date,
                    periodEndDate: empty
                }
            ]

func GetReportableQuantityPeriodLeg2:
    inputs:
        trade Trade (1..1)
    output:
        reportablePeriod QuantityReportablePeriod (1..*)

    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
                or Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then CommodityLeg2(ProductForTrade(trade)) -> schedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(ProductForTrade(trade)))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> forwardPayout only-element -> schedule

    alias quantitySchedule:
        if Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForTrade(trade)))
                or Qualify_AssetClass_Commodity(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then GetLeg2ResolvablePriceQuantity(trade) -> quantitySchedule

    add reportablePeriod:
        if customizedSchedule exists
        then quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value from quantity period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        quantityPeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        QuantityReportablePeriod {
                            periodValue: quantityPeriod -> value,
                            periodEffectiveDate: matchingCustomPeriod -> calculationPeriod -> startDate,
                            periodEndDate: matchingCustomPeriod -> calculationPeriod -> endDate
                        }
                    ]
            ]
        else quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value and dates from quantity period
                QuantityReportablePeriod {
                    periodValue: quantityPeriod -> value,
                    periodEffectiveDate: quantityPeriod -> date,
                    periodEndDate: empty
                }
            ]

func GetBasketConstituentsProductIdentifier: <"Extracts a product identifier from each constituent of custom baskets. One product identifier per basket constituent.">
    inputs:
        trade Trade (1..1)
    output:
        productIdentifiers ProductIdentifier (0..*) <"Single product identifier per basket constituent.">

    alias product: ProductForTrade(trade)

    alias basketConstituents:
        if UnderlierForProduct(product) -> basket -> basketConstituent exists
        then UnderlierForProduct(product) -> basket -> basketConstituent
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> basket -> basketConstituent exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> basket -> basketConstituent
        else if EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> basket -> basketConstituent exists
                and IsSingleCommodityPayoutProduct(product) = False
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> basket -> basketConstituent

    alias referenceObligations:
        if EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> referencePool -> referencePoolItem -> referencePair -> referenceObligation exists
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> referencePool -> referencePoolItem -> referencePair -> referenceObligation
        else if EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation

    add productIdentifiers:
        basketConstituents
            extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
                else if commodity exists
                then commodity -> productIdentifier
                else if index exists
                then index -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productIdentifiers:
        referenceObligations
            extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

func GetProductIdentifierFilteringISIN:
    inputs:
        productIdentifiers ProductIdentifier (0..*) <"List of product identifiers">
    output:
        productIdentifier ProductIdentifier (0..1) <"Single product identifier">

    set productIdentifier: <"Extract ISIN identifier if exists, else return the first.">
        if productIdentifiers -> source any = ProductIdTypeEnum -> ISIN
        then (productIdentifiers
            filter source = ProductIdTypeEnum -> ISIN
            then first)
        else productIdentifiers first

func GetReportablePricePeriod: <"Extracts the period for a price schedule">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePeriod PriceReportablePeriod (1..*)

    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
                or Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(ProductForEvent(reportableEvent))
                    )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> commodityPayout -> schedule first
        else if Qualify_Commodity_Option(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
                or Qualify_Commodity_Swaption(
                        EconomicTermsForProduct(ProductForEvent(reportableEvent))
                    )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> optionPayout only-element -> schedule
        else if Qualify_Commodity_Forward(
                    EconomicTermsForProduct(ProductForEvent(reportableEvent))
                )
        then EconomicTermsForProduct(ProductForEvent(reportableEvent)) -> payout -> forwardPayout only-element -> schedule

    alias priceSchedule: Contract_Price_Monetary(reportableEvent) only-element

    alias priceNotation: GetPriceNotation(priceSchedule)

    add reportablePeriod:
        if customizedSchedule exists
        then priceSchedule -> datedValue // loop through each datedValue
            extract pricePeriod [
                // use value from price period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        pricePeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        Create_PriceReportablePeriod(
                                pricePeriod -> value,
                                matchingCustomPeriod -> calculationPeriod -> startDate,
                                matchingCustomPeriod -> calculationPeriod -> endDate,
                                priceNotation
                            )
                    ]
            ]
        else priceSchedule -> datedValue // loop through each datedValue
            extract pricePeriod [
                // use value and dates from price period
                Create_PriceReportablePeriod(
                        pricePeriod -> value,
                        pricePeriod -> date,
                        empty,
                        priceNotation
                    )
            ]

func GetReportableStrikePricePeriod: <"Extracts the period for a strike price schedule">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePeriod PriceReportablePeriod (1..*)

    alias customizedSchedule:
        if IsCommodityOption(ProductForTrade(TradeForEvent(reportableEvent)))
                or Qualify_Commodity_Swaption(
                        EconomicTermsForProduct(
                                ProductForTrade(TradeForEvent(reportableEvent))
                            )
                    )
        then EconomicTermsForProduct(ProductForTrade(TradeForEvent(reportableEvent))) -> payout -> optionPayout -> schedule only-element

    alias strikePriceSchedule: Contract_StrikePrice(reportableEvent) only-element

    alias priceNotation: GetPriceNotation(strikePriceSchedule)

    add reportablePeriod:
        if customizedSchedule exists
        then strikePriceSchedule -> datedValue // loop through each datedValue
            extract pricePeriod [
                // use value from price period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        pricePeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        Create_PriceReportablePeriod(
                                pricePeriod -> value,
                                matchingCustomPeriod -> calculationPeriod -> startDate,
                                matchingCustomPeriod -> calculationPeriod -> endDate,
                                priceNotation
                            )
                    ]
            ]
        else strikePriceSchedule -> datedValue // loop through each datedValue
            extract pricePeriod [
                // use value and dates from price period
                Create_PriceReportablePeriod(
                        pricePeriod -> value,
                        pricePeriod -> date,
                        empty,
                        priceNotation
                    )
            ]

func Create_PriceReportablePeriod:
    inputs:
        priceValue number (0..1)
        periodEffectiveDate date (0..1)
        periodEndDate date (0..1)
        priceNotation PriceNotationEnum (0..1)
    output:
        reportablePeriod PriceReportablePeriod (1..1)

    set reportablePeriod -> periodValue -> priceMonetary:
        if priceNotation = PriceNotationEnum -> Monetary
        then priceValue
    set reportablePeriod -> periodValue -> pricePercentage:
        if priceNotation = PriceNotationEnum -> Percentage
                or priceNotation = PriceNotationEnum -> Decimal
        then priceValue
    set reportablePeriod -> periodValue -> priceNotation: priceNotation
    set reportablePeriod -> periodEffectiveDate: periodEffectiveDate
    set reportablePeriod -> periodEndDate: periodEndDate

func Create_ContinuousPriceSchedule: <"Converts price schedule to a continuous price schedule, where the period end date is the date before the next period start date.">
    inputs:
        reportablePeriod PriceReportablePeriod (0..*) <"Input schedule may only have start dates specified, or may be discontinous.">
        endDate date (1..1) <"End date of the final period.">
    output:
        continuousReportablePeriod PriceReportablePeriod (0..*)

func Create_ContinuousQuantitySchedule: <"Converts quantity schedule to a continuous quantity schedule, where the period end date is the date before the next period start date.">
    inputs:
        reportablePeriod QuantityReportablePeriod (0..*) <"Input schedule may only have start dates specified, or may be discontinous.">
        endDate date (1..1) <"End date of the final period.">
    output:
        continuousReportablePeriod QuantityReportablePeriod (0..*)

func GetPriceNotation: <"Notations are manners in which Price Values (Price, Rate or Spread) is expressed.
                        Notation 1 - Represents Monetary Value;
                        Notation 2 - Represents Percentage;
                        Notation 3 - Represents Decimal;
                        Notation 4 - Represents Spread
                        ">
    inputs:
        price PriceSchedule (0..1)
    output:
        notation PriceNotationEnum (1..1)

    set notation:
        if price -> value exists or price -> datedValue exists
        then if price -> priceType = PriceTypeEnum -> InterestRate
                    and price -> arithmeticOperator = ArithmeticOperationEnum -> Add
            then PriceNotationEnum -> Basis // 4
            else if (price -> priceType = PriceTypeEnum -> InterestRate
                    or price -> priceType = PriceTypeEnum -> Variance
                    or price -> priceType = PriceTypeEnum -> Volatility
                    or (price -> priceType = PriceTypeEnum -> AssetPrice
                        and price -> unit = price -> perUnitOf))
                    or (price -> priceExpression = PriceExpressionEnum -> PercentageOfNotional)
            then PriceNotationEnum -> Percentage // 2
            else if (price -> priceType = PriceTypeEnum -> ExchangeRate
                    or price -> priceType = PriceTypeEnum -> AssetPrice
                    or price -> priceType = PriceTypeEnum -> CashPrice)
                    or (price -> unit -> currency exists
                        or price -> priceExpression = PriceExpressionEnum -> AbsoluteTerms)
            then PriceNotationEnum -> Monetary // 1
            else PriceNotationEnum -> Decimal // 3

func MultiplyPrice: <"This functions converts default Decimal values into required formats for Basis (x 10000) and Percentages (x 100)">
    inputs:
        value number (0..1)
        notation PriceNotationEnum (0..1)
    output:
        multipliedValue number (0..1)

    set multipliedValue:
        if value exists
        then (if notation = PriceNotationEnum -> Basis
            then RoundToPrecision(value * 10000, 0, RoundingDirectionEnum -> Nearest)
            else if notation = PriceNotationEnum -> Percentage
            then RoundToPrecision(value * 100, 10, RoundingDirectionEnum -> Nearest)
            else RoundToPrecision(value, 13, RoundingDirectionEnum -> Nearest))

func GetNotationEnum: <"This functions returns Business Names of notations e.g. This function returns 'Decimal' for Notation = '3'">
    inputs:
        notationString NumericChar1to4 (0..1)
    output:
        notationEnum PriceNotationEnum (1..1)

    set notationEnum:
        if notationString = "1"
        then PriceNotationEnum -> Monetary
        else if notationString = "2"
        then PriceNotationEnum -> Percentage
        else if notationString = "3"
        then PriceNotationEnum -> Decimal
        else if notationString = "4"
        then PriceNotationEnum -> Basis

func GetNotationString: <"This functions returns character notations for Business names e.g. This function returns '3' for Notation = 'Decimal'">
    inputs:
        notationEnum PriceNotationEnum (1..1)
    output:
        notationString NumericChar1to4 (0..1)

    set notationString:
        if notationEnum = PriceNotationEnum -> Monetary
        then "1"
        else if notationEnum = PriceNotationEnum -> Percentage
        then "2"
        else if notationEnum = PriceNotationEnum -> Decimal
        then "3"
        else if notationEnum = PriceNotationEnum -> Basis
        then "4"

func GetVenueOfExecution: <"Extracts venue of execution from reportable event.">
    inputs:
        reportableInformation ReportableInformation (0..1)
    output:
        venueOfExecution string (0..1)

    set venueOfExecution:
        reportableInformation -> partyInformation -> relatedParty
            filter role = PartyRoleEnum -> ExecutionFacility
            then extract partyReference -> partyId
            then flatten
            then filter identifierType = PartyIdentifierTypeEnum -> MIC
            then extract identifier
            then first

func GetValuation: <"Extracts the valuation history for the max timestamp available">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        valuation Valuation (0..1)

    set valuation:
        if TradeStateForEvent(reportableEvent) -> valuationHistory exists
        then TradeStateForEvent(reportableEvent) -> valuationHistory
            max [ timestamp -> date ]
        else if PositionStateForEvent(reportableEvent) -> valuationHistory exists
        then PositionStateForEvent(reportableEvent) -> valuationHistory
            max [ timestamp -> date ]

func GetNonFinancialCorporateSector:
    inputs:
        nonFinancialSector NonFinancialSector (1..*)
    output:
        corporateSector string (1..*)
    add corporateSector: nonFinancialSector extract nonFinancialSectorIndicator to-string

func GetIndexIndicatorFromFloatingRate:
    inputs:
        floatingRate string (1..1)
    output:
        indicator string (0..1)
    set indicator:
        if [
                FloatingRateIndexEnum -> EUR_EuroSTR to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_12M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_1M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_1W to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_3M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_6M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_FTSE_Term to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Term to-string
            ] any = floatingRate
        then "ESTR"
        else if [
                FloatingRateIndexEnum -> GBP_SONIA to-string,
                FloatingRateIndexEnum -> GBP_SONIA_COMPOUND to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Compounded_Index to-string,
                FloatingRateIndexEnum -> GBP_SONIA_FTSE_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Refinitiv_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_WMBA_SONIA_COMPOUND to-string
            ] any = floatingRate
        then "SONA"
        else if [
                FloatingRateIndexEnum -> USD_SOFR to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_180D to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_30D to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_90D to-string,
                FloatingRateIndexEnum -> USD_SOFR_CME_Term to-string,
                FloatingRateIndexEnum -> USD_SOFR_COMPOUND to-string,
                FloatingRateIndexEnum -> USD_SOFR_Compounded_Index to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_OIS_Compound to-string
            ] any = floatingRate
        then "SOFR"
        else if [
                FloatingRateIndexEnum -> EUR_EONIA to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND_Bloomberg to-string
            ] any = floatingRate
        then "EONA"
        else if [FloatingRateIndexEnum -> EUR_EONIA_Swap_Index to-string] any = floatingRate
        then "EONS"
        else if [
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Act_365 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Act_365_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Annual_Bond_Swap_vs_1m_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Basis_Swap_1m_vs_3m_Euribor_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Basis_Swap_3m_vs_6m_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_ICE_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_ICE_Swap_Rate_12_00 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Reuters to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Telerate to-string
            ] any = floatingRate
        then "EURI"
        else if [FloatingRateIndexEnum -> EUR_USD_Basis_Swaps_11_00_ICAP to-string] any = floatingRate
        then "EUUS"
        else if False
        then "EUCH"
        else if False
        then "GCFR"
        else if [
                FloatingRateIndexEnum -> CAD_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> CHF_ISDAFIX_Swap_Rate to-string,
                FloatingRateIndexEnum -> EUR_ISDA_EURIBOR_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_EURIBOR_Swap_Rate_12_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_LIBOR_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_LIBOR_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> GBP_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> HKD_ISDA_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> HKD_ISDA_Swap_Rate_4_00 to-string,
                FloatingRateIndexEnum -> JPY_ISDA_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> JPY_ISDA_Swap_Rate_15_00 to-string,
                FloatingRateIndexEnum -> USD_ISDAFIX3_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_ISDAFIX3_Swap_Rate_3_00 to-string,
                FloatingRateIndexEnum -> USD_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_ISDA_Swap_Rate_3_00 to-string
            ] any = floatingRate
        then "ISDA"
        else if False
        then "LIBI"
        else if [
                FloatingRateIndexEnum -> AUD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> AUD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> AUD_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA_SwapMarker to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBORSWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_LIBOR to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_LIBOR to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_LIBOR to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_LIBOR to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_FRASETT to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_TSR_10_00 to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_TSR_15_00 to-string,
                FloatingRateIndexEnum -> JPY_Quoting_Banks_LIBOR to-string,
                FloatingRateIndexEnum -> USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_LIBOR to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ICE_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ICE_Swap_Rate_15_00 to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> USD_LIBOR_LIBO to-string,
                FloatingRateIndexEnum -> USD_LIBOR_Reference_Banks to-string
            ] any = floatingRate
        then "LIBO"
        else if [
                FloatingRateIndexEnum -> USD_Municipal_Swap_Index to-string,
                FloatingRateIndexEnum -> USD_Municipal_Swap_Libor_Ratio_11_00_ICAP to-string,
                FloatingRateIndexEnum -> USD_Municipal_Swap_Rate_11_00_ICAP to-string
            ] any = floatingRate
        then "MAAA"
        else if False
        then "PFAN"
        else if [
                FloatingRateIndexEnum -> JPY_Euroyen_TIBOR to-string,
                FloatingRateIndexEnum -> JPY_TIBOR to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_17096 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_17097 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_DTIBOR01 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__10_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__5_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__All_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__All_Banks__Bloomberg to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_ZTIBOR to-string,
                FloatingRateIndexEnum -> USD_TIBOR_ISDC to-string,
                FloatingRateIndexEnum -> USD_TIBOR_Reference_Banks to-string
            ] any = floatingRate
        then "TIBO"
        else if [
                FloatingRateIndexEnum -> SEK_STIBOR to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_SIDE to-string
            ] any = floatingRate
        then "STBO"
        else if [
                FloatingRateIndexEnum -> AUD_BBR_AUBBSW to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSW to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSW_Bloomberg to-string,
                FloatingRateIndexEnum -> AUD_BBSW to-string,
                FloatingRateIndexEnum -> AUD_BBSW_Quarterly_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_BBSW_Semi_Annual_Swap_Rate_ICAP to-string
            ] any = floatingRate
        then "BBSW"
        else if [
                FloatingRateIndexEnum -> ZAR_JIBAR to-string,
                FloatingRateIndexEnum -> ZAR_JIBAR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_JIBAR_SAFEX to-string
            ] any = floatingRate
        then "JIBA"
        else if [
                FloatingRateIndexEnum -> HUF_BUBOR to-string,
                FloatingRateIndexEnum -> HUF_BUBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> HUF_BUBOR_Reuters to-string
            ] any = floatingRate
        then "BUBO"
        else if [
                FloatingRateIndexEnum -> CAD_BA_CDOR to-string // Some CAD_BA in NSNC
                ,
                FloatingRateIndexEnum -> CAD_BA_CDOR_Bloomberg to-string // Some CAD_BA in NSNC
                ,
                FloatingRateIndexEnum -> CAD_CDOR to-string
            ] any = floatingRate
        then "CDOR"
        else if [
                FloatingRateIndexEnum -> DKK_CIBOR to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2_Bloomberg to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2_DKNA13 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_DKNA13 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_DKNA13_Bloomberg to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_Reference_Banks to-string
            ] any = floatingRate
        then "CIBO"
        else if [
                FloatingRateIndexEnum -> RUB_MosPrime to-string,
                FloatingRateIndexEnum -> RUB_MOSPRIME_NFEA to-string,
                FloatingRateIndexEnum -> RUB_MOSPRIME_Reference_Banks to-string
            ] any = floatingRate
        then "MOSP"
        else if [
                FloatingRateIndexEnum -> NOK_NIBOR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR_Bloomberg to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_OIBOR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_Reference_Banks to-string
            ] any = floatingRate
        then "NIBO"
        else if [
                FloatingRateIndexEnum -> CZK_PRIBOR to-string,
                FloatingRateIndexEnum -> CZK_PRIBOR_PRBO to-string,
                FloatingRateIndexEnum -> CZK_PRIBOR_Reference_Banks to-string
            ] any = floatingRate
        then "PRBO"
        else if [
                FloatingRateIndexEnum -> ILS_TELBOR to-string,
                FloatingRateIndexEnum -> ILS_TELBOR01_Reuters to-string,
                FloatingRateIndexEnum -> ILS_TELBOR_Reference_Banks to-string
            ] any = floatingRate
        then "TLBO"
        else if [
                FloatingRateIndexEnum -> PLN_WIBOR to-string,
                FloatingRateIndexEnum -> PLN_WIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLN_WIBOR_WIBO to-string,
                FloatingRateIndexEnum -> PLZ_WIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLZ_WIBOR_WIBO to-string
            ] any = floatingRate
        then "WIBO"
        else if [
                FloatingRateIndexEnum -> CAD_TBILL_ISDD to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Reuters to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Telerate to-string,
                FloatingRateIndexEnum -> USD_TBILL_Auction_High_Rate to-string,
                FloatingRateIndexEnum -> USD_TBILL_H_15 to-string,
                FloatingRateIndexEnum -> USD_TBILL_H_15_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_TBILL_Secondary_Market to-string,
                FloatingRateIndexEnum -> USD_TBILL_Secondary_Market_Bond_Equivalent_Yield to-string,
                FloatingRateIndexEnum -> USD_Treasury_19901_3_00_ICAP to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_BCMP1 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_ICAP_BrokerTec to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_SwapMarker100 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_SwapMarker99 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_T19901 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_T500 to-string
            ] any = floatingRate
        then "TREA"
        else if [
                FloatingRateIndexEnum -> AUD_Quarterly_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_Quarterly_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Semi_annual_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Swap_Rate_Reuters to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> CHF_Basis_Swap_3m_vs_6m_LIBOR_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CHF_OIS_11_00_ICAP to-string // Maybe not
                ,
                FloatingRateIndexEnum -> CHF_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CNY_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> CNY_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> CZK_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> CZK_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_3_Month to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_3_Month_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_Basis_Swap_EONIA_vs_3m_EUR_IBOR_Swap_Rates_A_360_10_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_SwapMarker26 to-string,
                FloatingRateIndexEnum -> GBP_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_4_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_4_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_11_30_BGCANTOR to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_Annual_Swap_Rate_3_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> JPY_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_OIS_3_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> KRW_Quarterly_Annual_Swap_Rate_3_30_ICAP to-string,
                FloatingRateIndexEnum -> MYR_Quarterly_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> MYR_Quarterly_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> NZD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> NZD_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> PHP_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> PHP_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RON_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> RON_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_12_45_TRADITION to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> SEK_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> SEK_Annual_Swap_Rate_SESWFI to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Currency_Basis_Swap_Rate_11_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Currency_Basis_Swap_Rate_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> THB_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_11_15_BGCANTOR to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> TWD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> TWD_Quarterly_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_4_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_LON_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_NY_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_OIS_3_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_OIS_3_00_NY_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_4_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Term to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_Swap_Rate_BCMP1 to-string,
                FloatingRateIndexEnum -> VND_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> VND_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_1_00_TRADITION to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_5_30_TRADITION to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_TRADITION_Reference_Banks to-string
            ] any = floatingRate
        then "SWAP"
        else if False
        then "FUSW"
        else if [
                FloatingRateIndexEnum -> USD_Federal_Funds to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15 to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_OIS_Compound to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_Reference_Dealers to-string
            ] any = floatingRate
        then "EFFR"
        else if [FloatingRateIndexEnum -> USD_Overnight_Bank_Funding_Rate to-string] any = floatingRate
        then "OBFR"
        else if [
                FloatingRateIndexEnum -> CZK_CZEONIA to-string,
                FloatingRateIndexEnum -> CZK_CZEONIA_OIS_Compound to-string
            ] any = floatingRate
        then "CZNA"
        else if [
                FloatingRateIndexEnum -> CAD_CORRA to-string,
                FloatingRateIndexEnum -> CAD_CORRA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> CAD_CORRA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CAD_CORRA_Compounded_Index to-string,
                FloatingRateIndexEnum -> CAD_REPO_CORRA to-string
            ] any = floatingRate
        then "CORA"
        else if [
                FloatingRateIndexEnum -> HKD_HIBOR to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HIBOR_ to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HKAB to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HKAB_Bloomberg to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_ISDC to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNH_HIBOR to-string,
                FloatingRateIndexEnum -> CNH_HIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNH_HIBOR_TMA to-string
            ] any = floatingRate
        then "HKIO"
        else if [
                FloatingRateIndexEnum -> JPY_TONA to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_180D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_30D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_90D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Compounded_Index to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> JPY_TONA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> JPY_TONA_TSR_10_00 to-string
            ] any = floatingRate
        then "TONA"
        else if [FloatingRateIndexEnum -> JPY_TORF_QUICK to-string] any = floatingRate
        then "TORF"
        else if [
                FloatingRateIndexEnum -> USD_SIBOR_SIBO to-string,
                FloatingRateIndexEnum -> USD_SIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SIBOR to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Reuters to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Telerate to-string
            ] any = floatingRate
        then "SIBO"
        else if [
                FloatingRateIndexEnum -> SGD_SOR to-string,
                FloatingRateIndexEnum -> SGD_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SOR_Reuters to-string,
                FloatingRateIndexEnum -> SGD_SOR_Telerate to-string,
                FloatingRateIndexEnum -> SGD_SOR_VWAP to-string,
                FloatingRateIndexEnum -> SGD_SOR_VWAP_Reference_Banks to-string
            ] any = floatingRate
        then "SSOR"
        else if [
                FloatingRateIndexEnum -> SGD_SORA to-string,
                FloatingRateIndexEnum -> SGD_SORA_COMPOUND to-string,
                FloatingRateIndexEnum -> SGD_SORA_OIS_Compound to-string
            ] any = floatingRate
        then "SORA"
        else if [
                FloatingRateIndexEnum -> AED_EBOR_Reuters to-string,
                FloatingRateIndexEnum -> AED_EIBOR to-string,
                FloatingRateIndexEnum -> AUD_AONIA to-string,
                FloatingRateIndexEnum -> AUD_AONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSY__BID_ to-string,
                FloatingRateIndexEnum -> AUD_BBR_ISDC to-string,
                FloatingRateIndexEnum -> AUD_BBSY_Bid to-string,
                FloatingRateIndexEnum -> BRL_CDI to-string,
                FloatingRateIndexEnum -> CAD_BA_ISDD to-string,
                FloatingRateIndexEnum -> CAD_BA_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_BA_Reuters to-string,
                FloatingRateIndexEnum -> CAD_BA_Telerate to-string,
                FloatingRateIndexEnum -> CHF_SARON to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_12M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_1M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_1W to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_2M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_3M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_6M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_9M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Compounded_Index to-string,
                FloatingRateIndexEnum -> CHF_SARON_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> CHF_SARON_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CHF_TOIS_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CL_CLICP_Bloomberg to-string,
                FloatingRateIndexEnum -> CLP_ICP to-string,
                FloatingRateIndexEnum -> CLP_TNA to-string,
                FloatingRateIndexEnum -> CNY_7_Repo_Compounding_Date to-string,
                FloatingRateIndexEnum -> CNY_CNREPOFIX_CFXS_Reuters to-string,
                FloatingRateIndexEnum -> CNY_Deposit_Rate to-string,
                FloatingRateIndexEnum -> CNY_Fixing_Repo_Rate to-string,
                FloatingRateIndexEnum -> CNY_LPR to-string,
                FloatingRateIndexEnum -> CNY_PBOCB_Reuters to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7D_Repo_NDS_Rate_Tradition to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> CNY_Shibor_OIS_Compounding to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR_Reuters to-string,
                FloatingRateIndexEnum -> COP_IBR_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> COP_IBR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_CITA to-string,
                FloatingRateIndexEnum -> DKK_CITA_DKNA14_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_DESTR to-string,
                FloatingRateIndexEnum -> DKK_DESTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> DKK_DESTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> DKK_DKKOIS_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_Tom_Next_OIS_Compound to-string,
                FloatingRateIndexEnum -> EUR_CNO_TEC10 to-string,
                FloatingRateIndexEnum -> EUR_EURONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> EUR_EURONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_TAM_CDC to-string,
                FloatingRateIndexEnum -> EUR_TEC10_CNO to-string,
                FloatingRateIndexEnum -> EUR_TEC10_CNO_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_TEC10_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_TEC5_CNO to-string,
                FloatingRateIndexEnum -> EUR_TEC5_CNO_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_TEC5_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_TMM_CDC_COMPOUND to-string,
                FloatingRateIndexEnum -> GBP_RONIA to-string,
                FloatingRateIndexEnum -> GBP_RONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> GBP_UK_Base_Rate to-string,
                FloatingRateIndexEnum -> GBP_WMBA_RONIA_COMPOUND to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_ATHIBOR to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_Telerate to-string,
                FloatingRateIndexEnum -> GRD_ATHIMID_Reference_Banks to-string,
                FloatingRateIndexEnum -> GRD_ATHIMID_Reuters to-string,
                FloatingRateIndexEnum -> HKD_HONIA to-string,
                FloatingRateIndexEnum -> HKD_HONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> HKD_HONIX_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> HUF_HUFONIA to-string,
                FloatingRateIndexEnum -> HUF_HUFONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> IDR_IDMA_Bloomberg to-string,
                FloatingRateIndexEnum -> IDR_IDRFIX to-string,
                FloatingRateIndexEnum -> IDR_JIBOR to-string,
                FloatingRateIndexEnum -> IDR_JIBOR_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SBI_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> IDR_SOR_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SOR_Telerate to-string,
                FloatingRateIndexEnum -> ILS_SHIR to-string,
                FloatingRateIndexEnum -> ILS_SHIR_OIS_Compound to-string,
                FloatingRateIndexEnum -> INR_BMK to-string,
                FloatingRateIndexEnum -> INR_CMT to-string,
                FloatingRateIndexEnum -> INR_FBIL_MIBOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_INBMK_REUTERS to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_MIFOR to-string,
                FloatingRateIndexEnum -> INR_MIOIS to-string,
                FloatingRateIndexEnum -> INR_MITOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_Modified_MIFOR to-string,
                FloatingRateIndexEnum -> INR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ISK_REIBOR to-string,
                FloatingRateIndexEnum -> ISK_REIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ISK_REIBOR_Reuters to-string,
                FloatingRateIndexEnum -> JPY_BBSF_Bloomberg_10_00 to-string,
                FloatingRateIndexEnum -> JPY_BBSF_Bloomberg_15_00 to-string,
                FloatingRateIndexEnum -> JPY_LTPR_MHBK to-string,
                FloatingRateIndexEnum -> JPY_LTPR_MHCB to-string,
                FloatingRateIndexEnum -> JPY_LTPR_TBC to-string,
                FloatingRateIndexEnum -> JPY_MUTANCALL_TONAR to-string,
                FloatingRateIndexEnum -> JPY_STPR_Quoting_Banks to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reuters_10_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reuters_15_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Telerate_10_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Telerate_15_00 to-string,
                FloatingRateIndexEnum -> KRW_Bond_3222 to-string,
                FloatingRateIndexEnum -> KRW_CD_3220 to-string,
                FloatingRateIndexEnum -> KRW_CD_91D to-string,
                FloatingRateIndexEnum -> KRW_CD_KSDA_Bloomberg to-string,
                FloatingRateIndexEnum -> KRW_KOFR to-string,
                FloatingRateIndexEnum -> KRW_KOFR_OIS_Compound to-string,
                FloatingRateIndexEnum -> MXN_TIIE to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico_Bloomberg to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico_Reference_Banks to-string,
                FloatingRateIndexEnum -> MXN_TIIE_ON to-string,
                FloatingRateIndexEnum -> MXN_TIIE_ON_OIS_Compound to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Reference_Banks to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR_BNM to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> MYR_MYOR to-string,
                FloatingRateIndexEnum -> MYR_MYOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> NOK_NOWA to-string,
                FloatingRateIndexEnum -> NOK_NOWA_OIS_Compound to-string,
                FloatingRateIndexEnum -> NZD_BBR_BID to-string,
                FloatingRateIndexEnum -> NZD_BBR_FRA to-string,
                FloatingRateIndexEnum -> NZD_BBR_ISDC to-string,
                FloatingRateIndexEnum -> NZD_BBR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_BBR_Telerate to-string,
                FloatingRateIndexEnum -> NZD_BKBM_Bid to-string,
                FloatingRateIndexEnum -> NZD_BKBM_FRA to-string,
                FloatingRateIndexEnum -> NZD_BKBM_FRA_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> NZD_NZIONA to-string,
                FloatingRateIndexEnum -> NZD_NZIONA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> NZD_NZIONA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> PHP_PHIREF to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_BAP to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_Bloomberg to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLN_POLONIA to-string,
                FloatingRateIndexEnum -> PLN_POLONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> PLN_POLONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> PLN_WIBID to-string,
                FloatingRateIndexEnum -> PLN_WIRON to-string,
                FloatingRateIndexEnum -> PLN_WIRON_OIS_Compound to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_ITALY_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> RON_RBOR_Reuters to-string,
                FloatingRateIndexEnum -> RON_ROBID to-string,
                FloatingRateIndexEnum -> RON_ROBOR to-string,
                FloatingRateIndexEnum -> RUB_Key_Rate_CBRF to-string,
                FloatingRateIndexEnum -> RUB_RUONIA to-string,
                FloatingRateIndexEnum -> RUB_RUONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> RUB_RUONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SAR_SAIBOR to-string,
                FloatingRateIndexEnum -> SAR_SRIOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SAR_SRIOR_SUAA to-string,
                FloatingRateIndexEnum -> SEK_SIOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SEK_SWESTR to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_1M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_1W to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_2M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_3M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_6M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> SGD_SONAR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SGD_SONAR_OIS_VWAP_COMPOUND to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_BRBO to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_NBSK07 to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_SOR_Reuters to-string,
                FloatingRateIndexEnum -> THB_SOR_Telerate to-string,
                FloatingRateIndexEnum -> THB_THBFIX to-string,
                FloatingRateIndexEnum -> THB_THBFIX_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_THBFIX_Reuters to-string,
                FloatingRateIndexEnum -> THB_THOR to-string,
                FloatingRateIndexEnum -> THB_THOR_COMPOUND to-string,
                FloatingRateIndexEnum -> THB_THOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> TRY_TLREF to-string,
                FloatingRateIndexEnum -> TRY_TLREF_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> TRY_TLREF_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> TRY_TRLIBOR to-string,
                FloatingRateIndexEnum -> TRY_TRYIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_TRYIBOR_Reuters to-string,
                FloatingRateIndexEnum -> TWD_Reference_Dealers to-string,
                FloatingRateIndexEnum -> TWD_Reuters_6165 to-string,
                FloatingRateIndexEnum -> TWD_TAIBIR01 to-string,
                FloatingRateIndexEnum -> TWD_TAIBIR02 to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR_Reuters to-string,
                FloatingRateIndexEnum -> TWD_Telerate_6165 to-string,
                FloatingRateIndexEnum -> TWD_TWCPBA to-string,
                FloatingRateIndexEnum -> UK_Base_Rate to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Average_30D to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Average_90D to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Term to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Term_Structure to-string,
                FloatingRateIndexEnum -> USD_AXI_Term to-string,
                FloatingRateIndexEnum -> USD_BA_H_15 to-string,
                FloatingRateIndexEnum -> USD_BA_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_BMA_Municipal_Swap_Index to-string,
                FloatingRateIndexEnum -> USD_BSBY to-string,
                FloatingRateIndexEnum -> USD_CD_H_15 to-string,
                FloatingRateIndexEnum -> USD_CD_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_CMS_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_CMS_Reference_Banks_ICAP_SwapPX to-string,
                FloatingRateIndexEnum -> USD_CMS_Reuters to-string,
                FloatingRateIndexEnum -> USD_CMS_Telerate to-string,
                FloatingRateIndexEnum -> USD_CMT to-string,
                FloatingRateIndexEnum -> USD_CMT_Average_1W to-string,
                FloatingRateIndexEnum -> USD_CMT_T7051 to-string,
                FloatingRateIndexEnum -> USD_CMT_T7052 to-string,
                FloatingRateIndexEnum -> USD_COF11_FHLBSF to-string,
                FloatingRateIndexEnum -> USD_COF11_Reuters to-string,
                FloatingRateIndexEnum -> USD_COF11_Telerate to-string,
                FloatingRateIndexEnum -> USD_COFI to-string,
                FloatingRateIndexEnum -> USD_CP_H_15 to-string,
                FloatingRateIndexEnum -> USD_CP_Money_Market_Yield to-string,
                FloatingRateIndexEnum -> USD_CP_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_CRITR to-string,
                FloatingRateIndexEnum -> USD_FFCB_DISCO to-string,
                FloatingRateIndexEnum -> USD_FXI_Term to-string,
                FloatingRateIndexEnum -> USD_Prime to-string,
                FloatingRateIndexEnum -> USD_Prime_H_15 to-string,
                FloatingRateIndexEnum -> USD_Prime_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_S_P_Index_High_Grade to-string,
                FloatingRateIndexEnum -> USD_SandP_Index_High_Grade to-string,
                FloatingRateIndexEnum -> USD_SIFMA_Municipal_Swap_Index to-string /* Maybe MAAA */ ,
                FloatingRateIndexEnum -> ZAR_DEPOSIT_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_DEPOSIT_SAFEX to-string,
                FloatingRateIndexEnum -> ZAR_Prime_Average_1 to-string,
                FloatingRateIndexEnum -> ZAR_PRIME_AVERAGE to-string,
                FloatingRateIndexEnum -> ZAR_PRIME_AVERAGE_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_ZARONIA to-string,
                FloatingRateIndexEnum -> ZAR_ZARONIA_OIS_Compound to-string
            ] any = floatingRate
        then empty

func GetNameOfTheFloatingRateOfLeg1:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        name string (0..1)
    set name:
        ProductForEvent(reportableEvent)
            then filter IsFRA = False
            then extract ProductOrUnderlierProduct
            then extract InterestRateLeg1
            then extract RateOption -> indexReferenceInformation -> indexName

func GetNameOfTheFloatingRateOfLeg2:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        name string (0..1)
    set name:
        ProductForEvent(reportableEvent)
            then extract ProductOrUnderlierProduct
            then extract InterestRateLeg2
            then extract RateOption -> indexReferenceInformation -> indexName

func GetFinancialCorporateSector:
    inputs:
        financialSector FinancialSectorEnum (0..*)
    output:
        corporateSector string (0..*)
    add corporateSector: financialSector extract to-string

func IsEU: <"Function to check if Country Code supplied belongs to European Union.">
    inputs:
        countryCode string (1..1)
    output:
        result boolean (1..1)
    set result:
        if ["BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL", "AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE"] any = countryCode
        then True
        else False

func IsESMAThirdCountryEquivalentMarket: <"Function to check if the MIC supplied refers to third country market considered as equivalent to regulated market by ESMA.">
    [regulatoryReference ESMA EMIR annex "ESMA70-708036281-113"
        provision "List of third-country markets considered as equivalent to a regulated market in the Union for the purposes of the definition of OTC derivatives. The markets established in a third country and listed below have been considered as equivalent to a regulated market in the Union in accordance with Article 2a of Regulation (EU) No 648/2012 of the European Parliament and of the Council of 4 July 2012 on OTC derivatives, central counterparties and trade repositories (EMIR) and for the purposes of Article 2(7) of this Regulation.
            Link to the Document: https://www.esma.europa.eu/sites/default/files/library/equivalent_tc-markets_under_emir.pdf"]
    inputs:
        mic string (1..1)
    output:
        result boolean (1..1)
    set result:
        /*  The Following mic codes refer to the list of Execution Venue as mentioned in the document published by ESMA.
         *     The list is ordered in accordance to the order in the document by ESMA.
         *     No mic code is available for No. 16 - North American Derivatives Exchange, Inc.
         */
        if ["BTNL", "XCFF", "XCB", "XCBT", "XCME", "XCEC", "XELX", "ERIS", "IFUS", "KLSH", "LEDG", "FREX", "XMGE", "XNYM", "NODX", "XOCH", "SMFE", "TRU", "XASX", "XSFE", "CHIX", "XMOD", "XCNQ", "IFCA", "NGXC", "XTSE", "XTSX", "XATS", "NEOE", "XTKS", "XOSE", "XNGO", "XFKA", "XSAP", "XTFF", "XKAC", "XTKT", "XSIM", "XSES", "IFSG"] any = mic
        then True
        else False

func IsFCAThirdCountryEquivalentMarket: <"Function to check if the MIC supplied refers to third country market considered as equivalent to regulated market by FCA.">
    [regulatoryReference FCA UKEMIR
        provision "List of third-country markets considered as equivalent to a regulated market in the UK for the purposes of the definition of OTC derivatives. The third country markets listed below have been considered to be equivalent to a UK regulated market in accordance with article 2a of UK EMIR.
            Link to the Document: https://www.fca.org.uk/publication/fca/fca-list-regulated-markets.pdf"]
    inputs:
        mic string (1..1)
    output:
        result boolean (1..1)
    set result:
        /*  The Following mic codes refer to the list of Execution Venue as mentioned in the document published by FCA.
         *     The list is ordered in accordance to the order in the document by FCA.
         *     No mic code is available for North American Derivatives Exchange, Inc.
         */
        if ["XASX", "XSFE", "CHIX", "WBAH", "XBRD", "XBRU", "ZBUL", "IBUL", "ABUL", "NEOE", "XATS", "XMOD", "XCNQ", "NGXC", "XTSE", "XTSX", "XCXD", "XZAG", "XCYS", "XPRA", "XRMZ", "XCSE", "DCSE", "MCSE", "XTAL", "XHEL", "MHEL", "DHEL", "XMON", "XPAR", "XMAT", "DUSA", "BERA", "BERC", "STUC", "STUA", "HAMM", "HAMA", "HANA", "DUSC", "MUNC", "XEER", "MUNA", "EQTB", "EQTA", "XGRM", "FRAA", "XETA", "XEUR", "XETU", "XPSF", "HDAT", "XATH", "XADE", "HEDE", "ASEX", "HUDX", "XBUD", "MICE", "XICE", "DICE", "XMSM", "ETFP", "MTAA", "MOTX", "MIVX", "XDMI", "MTSC", "XTKS", "XOSE", "XNGO", "XFKA", "XSAP", "XTFF", "XKAC", "XTKT", "XRIS", "XLIT", "XLUX", "XMAL", "IFSM", "XNXC", "NDEX", "XEUE", "XEUC", "BTAM", "CCRM", "BEUT", "BARU", "BEUO", "XAMS", "IMEQ", "FISH", "NORX", "NEXO", "ELNO", "ELEU", "ELSE", "XOAS", "XOSL", "XOBD", "WBCL", "PLPD", "WOPO", "RPWC", "WETP", "WIND", "WIPO", "XWAR", "WBON", "WDER", "MFOX", "OMIP", "XLIS", "XBSE", "XSIM", "XSES", "IFSG", "XBRA", "XLJU", "SEND", "MERF", "SBAR", "XMRV", "XMPW", "SBIL", "XDRF", "XBIL", "XVAL", "XMAD", "XBAR", "XMFX", "EUWB", "FIED", "XSTO", "DKED", "EBON", "NOCO", "SEED", "PNED", "USWB", "NOFI", "DKFI", "DSTO", "NOED", "MSTO", "ESTO", "GBWB", "XNGM", "BTNL", "XCFF", "XCB", "XCBT", "XCME", "XCEC", "ERIS", "XELX", "IFUS", "KLSH", "LEDG", "FREX", "XMGE", "XNYM", "NODX", "SMFE"] any = mic
        then True
        else False

func IsValidRefEntity:
    inputs:
        refEntity string (1..1)
    output:
        validRefEntity boolean (1..1)

    alias validFormat: <"Valid pattern contains 2 characters, followed by optional part contains a hyphen and 3 characters.">
        StringContains(refEntity, "[A-Z]{2}(-[A-Z]{3})?")
    alias validCountryCode: SubString(refEntity, 1, 2) to-enum ISOCountryCodeEnum exists

    set validRefEntity: validCountryCode and validFormat

func LastAvailableSpotPrice:
    inputs:
        reportableInformation ReportableInformation (1..1)
    output:
        lastAvailableSpotPrice PriceSchedule (0..1)
    // Last Available Spot Price will be found in the tradeLot for Commodity Basis Swaps.
    // This is the only price in this kind of products which is not a spread. It is an Asset Price also.
    set lastAvailableSpotPrice:
        reportableInformation -> underlyingAssetLastAvailableSpotPrice

func CommodityBasisLegWithNoSpread:
    inputs:
        product Product (1..1)
    output:
        commodityPayout CommodityPayout (0..1)
    // This function takes, from the two commodity payouts of a commodity basis, the one which does not have an spread or which has an spread = 0
    set commodityPayout:
        EconomicTermsForProduct(product) -> payout -> commodityPayout
            filter
                commodityPriceReturnTerms -> spread is absent
                    or commodityPriceReturnTerms -> spread -> price -> value = 0
            then only-element

func GetReportableDelivery: <"Extracts the period for a price schedule">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableDelivery ReportableDelivery (0..*)
    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)
    alias delivery:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then economicTerms -> payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Option(economicTerms)
        then economicTerms -> payout -> optionPayout -> delivery only-element
        else if Qualify_Commodity_Swaption(economicTerms)
        then EconomicTermsForProduct(
                economicTerms -> payout -> optionPayout -> underlier only-element
            ) -> payout -> commodityPayout -> delivery first
        else if IsSingleCommodityPayoutProduct(product)
        then economicTerms -> payout -> commodityPayout only-element -> delivery
        else if Qualify_Commodity_Forward(economicTerms)
        then economicTerms -> payout -> forwardPayout only-element -> delivery
    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then economicTerms -> payout -> commodityPayout -> schedule first
        else if Qualify_Commodity_Option(economicTerms)
                or Qualify_Commodity_Swaption(economicTerms)
        then economicTerms -> payout -> optionPayout only-element -> schedule
        else if IsSingleCommodityPayoutProduct(product)
        then economicTerms -> payout -> commodityPayout only-element -> schedule
        else if Qualify_Commodity_Forward(economicTerms)
        then economicTerms -> payout -> forwardPayout only-element -> schedule
    alias duration:
        reportableEvent -> reportableInformation -> transactionInformation -> esmaTransactionInformation -> duration first
    add reportableDelivery:
        if customizedSchedule exists
        then (customizedSchedule -> schedulePeriod
            extract schedulePeriod [
                schedulePeriod -> deliveryPeriod -> profile
                    extract deliveryProfile [
                        deliveryProfile -> block
                            extract deliveryBlock [
                                Create_DeliveryBlock(
                                        deliveryBlock -> startTime,
                                        deliveryBlock -> endTime,
                                        schedulePeriod -> deliveryPeriod -> startDate,
                                        schedulePeriod -> deliveryPeriod -> endDate,
                                        deliveryProfile -> bankHolidaysTreatment,
                                        duration,
                                        deliveryBlock -> dayOfWeek,
                                        if schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
                                        then schedulePeriod -> deliveryPeriod -> deliveryCapacity
                                        else if deliveryBlock -> deliveryCapacity exists
                                        then deliveryBlock -> deliveryCapacity,
                                        if schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
                                        then schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity -> value
                                        else if deliveryBlock -> priceTimeIntervalQuantity exists
                                        then deliveryBlock -> priceTimeIntervalQuantity -> value,
                                        if schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
                                        then schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity -> unit -> currency
                                        else if deliveryBlock -> priceTimeIntervalQuantity exists
                                        then deliveryBlock -> priceTimeIntervalQuantity -> unit -> currency
                                    )
                            ]
                    ]
                    then flatten
            ]
            then flatten)
        else delivery -> periods
            extract periods [
                periods -> profile
                    extract deliveryProfile [
                        deliveryProfile -> block
                            extract deliveryBlock [
                                Create_DeliveryBlock(
                                        deliveryBlock -> startTime,
                                        deliveryBlock -> endTime,
                                        periods -> startDate,
                                        periods -> endDate,
                                        deliveryProfile -> bankHolidaysTreatment,
                                        duration,
                                        deliveryBlock -> dayOfWeek,
                                        if delivery -> deliveryCapacity exists
                                        then delivery -> deliveryCapacity
                                        else if deliveryBlock -> deliveryCapacity exists
                                        then deliveryBlock -> deliveryCapacity,
                                        deliveryBlock -> priceTimeIntervalQuantity -> value,
                                        deliveryBlock -> priceTimeIntervalQuantity -> unit -> currency
                                    )
                            ]
                    ]
                    then flatten
            ]

func Create_DeliveryBlock:
    inputs:
        deliveryStartTime time (0..1)
        deliveryEndTime time (0..1)
        deliveryStartDate date (0..1)
        deliveryEndDate date (0..1)
        bankHolidaysTreatment BankHolidayTreatmentEnum (0..1)
        duration CommodityTimeUnitEnum (0..1)
        daysOfTheWeek DayOfWeekEnum (0..7)
        deliveryCapacity Quantity (0..1)
        priceTimeIntervalQuantity number (0..1)
        currencyOfThePriceTimeIntervalQuantity string (0..1)
    output:
        deliveryBlock ReportableDelivery (1..1)
    set deliveryBlock:
        ReportableDelivery {
            deliveryStartTime: deliveryStartTime,
            deliveryEndTime: deliveryEndTime,
            deliveryStartDate: deliveryStartDate,
            deliveryEndDate: deliveryEndDate,
            duration: GetDurationCodeFromCommodityTimeUnit(duration),
            daysOfTheWeek: GetDaysOfTheWeek(daysOfTheWeek, bankHolidaysTreatment),
            deliveryCapacity: GetDeliveryCapacityAmount(deliveryCapacity),
            quantityUnit: GetDeliveryCapacityUnit(deliveryCapacity),
            priceTimeIntervalQuantity: priceTimeIntervalQuantity,
            currencyOfThePriceTimeIntervalQuantity: currencyOfThePriceTimeIntervalQuantity
        }

func GetDaysOfTheWeek:
    inputs:
        daysOfTheWeek DayOfWeekEnum (0..7)
        bankHolidaysTreatment BankHolidayTreatmentEnum (0..1)
    output:
        dayCode string (0..*)
    alias mon: daysOfTheWeek contains DayOfWeekEnum -> MON
    alias tue: daysOfTheWeek contains DayOfWeekEnum -> TUE
    alias wed: daysOfTheWeek contains DayOfWeekEnum -> WED
    alias thu: daysOfTheWeek contains DayOfWeekEnum -> THU
    alias fri: daysOfTheWeek contains DayOfWeekEnum -> FRI
    alias sat: daysOfTheWeek contains DayOfWeekEnum -> SAT
    alias sun: daysOfTheWeek contains DayOfWeekEnum -> SUN
    add dayCode: // MOND
        if mon and (tue = False or wed = False or thu = False or fri = False)
        then "MOND"
    add dayCode: // TUED
        if tue and (mon = False or wed = False or thu = False or fri = False)
        then "TUED"
    add dayCode: // WEDD
        if wed and (mon = False or tue = False or thu = False or fri = False)
        then "WEDD"
    add dayCode: // THUD
        if thu and (mon = False or tue = False or wed = False or fri = False)
        then "THUD"
    add dayCode: // FRID
        if fri and (mon = False or tue = False or wed = False or thu = False)
        then "FRID"
    add dayCode: // SATD
        if sat and (sun = False) then "SATD"
    add dayCode: // SUND
        if sun and (sat = False) then "SUND"
    add dayCode: // WDAY
        if mon and tue and wed and thu and fri then "WDAY"
    add dayCode: // WEND
        if sat and sun then "WEND"
    add dayCode:
        if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekday
                and (mon or tue or wed or thu or fri)
                and ((sat or sun) = False)
        then "IBHL"
        else if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekend
                and (sat or sun)
                and ((mon or tue or wed or thu or fri) = False)
        then "IBHL"
    add dayCode:
        if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekend
                and (mon or tue or wed or thu or fri)
                and ((sat or sun) = False)
        then "XBHL"
        else if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekday
                and (sat or sun)
                and ((mon or tue or wed or thu or fri) = False)
        then "XBHL"

func GetDurationCodeFromCommodityTimeUnit: <"Function to get the duration of a delivery profile from CommodityTimeUnitEnum to DurationType1Code">
    inputs:
        timeUnit CommodityTimeUnitEnum (1..1)
    output:
        duration DurationType1Code (1..1)
    set duration:
        if timeUnit = CommodityTimeUnitEnum -> Minute
        then DurationType1Code -> MNUT
        else if timeUnit = CommodityTimeUnitEnum -> Hour
        then DurationType1Code -> HOUR
        else if timeUnit = CommodityTimeUnitEnum -> Day
        then DurationType1Code -> DASD
        else if timeUnit = CommodityTimeUnitEnum -> Week
        then DurationType1Code -> WEEK
        else if timeUnit = CommodityTimeUnitEnum -> Month
        then DurationType1Code -> QURT
        else if timeUnit = CommodityTimeUnitEnum -> Season
        then DurationType1Code -> SEAS
        else if timeUnit = CommodityTimeUnitEnum -> Year
        then DurationType1Code -> YEAR
        else if timeUnit = CommodityTimeUnitEnum -> Other
        then DurationType1Code -> OTHR

func GetLoadType: <"Function to get the load type of a delivery profile from LoadTypeEnum to EnergyLoadType1Code">
    inputs:
        profile AssetDeliveryProfile (1..1)
    output:
        loadType EnergyLoadType1Code (1..1)
    set loadType:
        if profile -> loadType = LoadTypeEnum -> BaseLoad
        then EnergyLoadType1Code -> BSLD
        else if profile -> loadType = LoadTypeEnum -> PeakLoad
        then EnergyLoadType1Code -> PKLD
        else if profile -> loadType = LoadTypeEnum -> OffPeak
        then EnergyLoadType1Code -> OFFP
        else if profile -> loadType = LoadTypeEnum -> BlockHours
        then EnergyLoadType1Code -> HABH
        else if profile -> loadType = LoadTypeEnum -> Shaped
        then EnergyLoadType1Code -> SHPD
        else if profile -> loadType = LoadTypeEnum -> GasDay
        then EnergyLoadType1Code -> GASD
        else if profile -> loadType = LoadTypeEnum -> Other
        then EnergyLoadType1Code -> OTHR

func GetDeliveryCapacityAmount:
    inputs:
        deliveryCapacity Quantity (0..1)
    output:
        amount number (0..1)
    set amount: QuantityToDeliveryCapacity(deliveryCapacity) -> amount

func GetDeliveryCapacityUnit:
    inputs:
        deliveryCapacity Quantity (0..1)
    output:
        unit EnergyQuantityUnit2Code (0..1)
    set unit: QuantityToDeliveryCapacity(deliveryCapacity) -> unit

func QuantityToDeliveryCapacity:
    inputs:
        quantity Quantity (0..1)
    output:
        deliveryCapacity DeliveryCapacity (0..1)
    alias capacityUnit: quantity -> unit -> capacityUnit
    alias frequency: quantity -> frequency
    set deliveryCapacity:
        // POWER UNITS
        if capacityUnit = CapacityUnitEnum -> KW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> KWAT
            }
        else if capacityUnit = CapacityUnitEnum -> MW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> MWAT
            }
        else if capacityUnit = CapacityUnitEnum -> GW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> GWAT
            }
        // BRITISH THERMAL UNITS
        else if [CapacityUnitEnum -> GBBTU, CapacityUnitEnum -> ISOBTU, CapacityUnitEnum -> USBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> BTUD
                })
        else if [CapacityUnitEnum -> GBMBTU, CapacityUnitEnum -> ISOMBTU, CapacityUnitEnum -> USMBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: (1000.0 * quantity -> value) / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> BTUD
                })
        else if [CapacityUnitEnum -> GBMMBTU, CapacityUnitEnum -> ISOMMBTU, CapacityUnitEnum -> USMMBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MBTD
                })
        // CUBIC METERS
        else if capacityUnit = CapacityUnitEnum -> CBM
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> L
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / (frequency -> periodMultiplier * 1000.0),
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> HL
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / (frequency -> periodMultiplier * 10.0),
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> KL
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        // JOULES
        else if capacityUnit = CapacityUnitEnum -> MJ
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MJDD
                })
        else if capacityUnit = CapacityUnitEnum -> GJ
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GJDD
                })
        // WATT*TIME UNITS
        else if capacityUnit = CapacityUnitEnum -> KWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> KWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> KWHD
                })
        else if capacityUnit = CapacityUnitEnum -> MWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MWHD
                })
        else if capacityUnit = CapacityUnitEnum -> GWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GWHD
                })
        // THERMAL UNITS
        else if [CapacityUnitEnum -> GBTHM, CapacityUnitEnum -> ISOTHM, CapacityUnitEnum -> USTHM] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> THMD
                })

func ExtractDateFromDateTime:
    inputs:
        dateTimeInput zonedDateTime (1..1)
    output:
        dateOutput date (1..1)

    set dateOutput: dateTimeInput -> date

func IsFRA:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_InterestRate_Fra(EconomicTermsForProduct(product)) = True

func Get_OptionPremiumOnEventDate:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        optionPremium Transfer (0..1)
    alias eventDate:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> eventDate
    alias premiums:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> after -> transferHistory
            filter transfer -> transferExpression -> priceTransfer = FeeTypeEnum -> Premium
            then transfer
    set optionPremium:
        if premiums count = 1
        then premiums only-element
        else if premiums count > 1
        then (premiums max [ AdjustableOrAdjustedOrRelativeDateResolution(settlementDate) ])

func GetUnderlyingIdentificationType:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result string (0..1)
    alias product:
        if IsCreditSwaption(ProductForEvent(reportableEvent))
                or IsIRSwaption(ProductForEvent(reportableEvent))
        then UnderlierForProduct(ProductForEvent(reportableEvent))
        else ProductForEvent(reportableEvent)
    set result:
        if (UnderlierForProduct(product) -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                    and UnderlierForProduct(product) -> security -> economicTerms -> payout -> forwardPayout -> underlier -> index is absent) // exclude Option on Future on index
                or UnderlierForProduct(product) -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and ((EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
                            and IsSingleCommodityPayoutProduct(product) = False
                        or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                        or UnderlierForProduct(product) -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN))
                        // IR on bond
                or (EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond -> source any = ProductIdTypeEnum -> ISIN)
        then "I"
        else if UnderlierForProduct(product) -> basket exists
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> basket exists
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
                or EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> basket exists
                    and IsSingleCommodityPayoutProduct(product) = False)
        then "B"
        else if UnderlierForProduct(product) -> index exists
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> index exists
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                or EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                    // IR Swaps floating or inflation rate
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> inflationRate exists
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index exists
                    and IsSingleCommodityPayoutProduct(product) = False)
                or Qualify_InterestRate_Fra(EconomicTermsForProduct(product))
                    // ETD Option on Futures on Index
                or (IsProductETD(product)
                    and UnderlierForProduct(UnderlierForProduct(product)) -> index exists)
        then "X"

func GetSeniority:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result string (0..1)

    alias product: ProductForEvent(reportableEvent)

    alias indexReferenceInformation:
        if IsCreditSwaption(product)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation

    alias referenceInformation:
        if IsCreditSwaption(product)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation

    alias basketReferenceInformation:
        if IsCreditSwaption(product)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation
        else if IsCreditDefaultSwapBasket(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation

    alias creditSeniority: indexReferenceInformation -> seniority

    alias debtSeniority:
        if referenceInformation exists
        then referenceInformation -> referenceObligation -> security -> debtType -> debtEconomics -> debtSeniority
        else if IsTotalReturnSwapDebtUnderlier(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security -> debtType -> debtEconomics -> debtSeniority

    alias basketSeniority:
        if basketReferenceInformation exists
        then basketReferenceInformation -> referencePool -> referencePoolItem -> referencePair -> referenceObligation -> security -> debtType -> debtEconomics -> debtSeniority

    set result:
        if creditSeniority = CreditSeniorityEnum -> SeniorUnSec
                or creditSeniority = CreditSeniorityEnum -> SeniorSec
                or creditSeniority = CreditSeniorityEnum -> SeniorLossAbsorbingCapacity
                or debtSeniority any = DebtSeniorityEnum -> Senior
                or basketSeniority all = DebtSeniorityEnum -> Senior
        then "SNDB"
        else if creditSeniority = CreditSeniorityEnum -> SubTier3
                or creditSeniority = CreditSeniorityEnum -> SubUpperTier2
                or creditSeniority = CreditSeniorityEnum -> SubLowerTier2
                or creditSeniority = CreditSeniorityEnum -> SubTier1
                or debtSeniority any = DebtSeniorityEnum -> Subordinated
                or basketSeniority all = DebtSeniorityEnum -> Subordinated
        then "SBOD"
        else if creditSeniority = CreditSeniorityEnum -> Other
                or debtSeniority any = DebtSeniorityEnum -> Secured
                or basketSeniority exists
        then "OTHR"

func IsSingleCommodityPayoutProduct: //IsSingleCommodityPayoutProduct
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    alias economicTerms: EconomicTermsForProduct(product)
    set result:
        // EconomicTermsForProduct(product) -> payout -> commodityPayout only-element exists
        // and EconomicTermsForProduct(product) -> payout -> fixedPricePayout is absent
        // and EconomicTermsForProduct(product) -> payout -> interestRatePayout is absent
        economicTerms -> payout -> commodityPayout only exists
            and economicTerms -> payout -> commodityPayout count = 1

func ConvertNonISOToISOCurrency:
    inputs:
        nonISOCurrency string (0..1)
    output:
        isoCurrency ISOCurrencyCodeEnum (0..1)

    set isoCurrency:
        if nonISOCurrency = "CNH"
        then (if nonISOCurrency = "CNH" then ISOCurrencyCodeEnum -> CNY)
        else nonISOCurrency to-enum ISOCurrencyCodeEnum

func DeliveryTypeForProducts:
    inputs:
        product Product (1..1)
    output:
        deliveryType string (1..1)

    alias settlementLeg:
        if SettlementTermsLeg1(product) exists
        then SettlementTermsLeg1(product)
        else SettlementTermsLeg2(product)

    alias deliveryTypeFromSettlementLeg:
        if (settlementLeg -> settlementType = SettlementTypeEnum -> Cash or settlementLeg -> cashSettlementTerms exists)
        then "CASH"
        else if (settlementLeg -> settlementType = SettlementTypeEnum -> Physical
                or settlementLeg -> physicalSettlementTerms exists)
        then "PHYS"
        else if (settlementLeg -> settlementType = SettlementTypeEnum -> CashOrPhysical or settlementLeg -> settlementType = SettlementTypeEnum -> Election)
        then "OPTL"

    set deliveryType:
        if ["CASH", "PHYS", "OPTL"] any = deliveryTypeFromSettlementLeg
        then deliveryTypeFromSettlementLeg
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product)) // CASH if it is a non-deliverable product, in which case cashSettlementTerms would be populated, therefore never reaching this instance
        then "PHYS"
        else if Qualify_AssetClass_Equity(EconomicTermsForProduct(product))
        then (if IsVarianceSwap(product)
                    or IsVolatilitySwap(product)
                    or product -> index -> productTaxonomy -> primaryAssetClass any = AssetClassEnum -> Equity
                    or UnderlierForProduct(product) -> index -> productTaxonomy -> primaryAssetClass any = AssetClassEnum -> Equity
            then "CASH")
        else if Qualify_AssetClass_Credit(EconomicTermsForProduct(product))
        then "OPTL"
        else if Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct(product))
        then (if Qualify_ForeignExchange_NDF(EconomicTermsForProduct(product))
                    or // This instance should never be reached
                    Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product))
            // NDO
            then "CASH"
            else if Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product))
                    or Qualify_ForeignExchange_Spot_Forward(
                            EconomicTermsForProduct(product)
                        )
                    or Qualify_ForeignExchange_VanillaOption(
                            EconomicTermsForProduct(product)
                        )
            then "PHYS")
        else if Qualify_AssetClass_Commodity(EconomicTermsForProduct(product))
        then (if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Option_Cash(EconomicTermsForProduct(product)) // This should never be reached
            then "CASH"
            else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Option_Physical(EconomicTermsForProduct(product))
                    or // This should never be reached
                    Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
            then "PHYS")

func GetExpirationDate:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        expirationDate date (0..1)

    alias product: ProductForEvent(transactionReportInstruction)
    alias fixingDates: InterestRateLeg2(product) -> resetDates -> fixingDates
    alias periodMultiplier:
        if fixingDates -> periodMultiplier exists
        then fixingDates -> periodMultiplier
        else 0

    set expirationDate:
        if Qualify_InterestRate_Fra(product -> contractualProduct -> economicTerms)
        then AddBusinessDays(
                    cde.datetime.EffectiveDate(transactionReportInstruction),
                    periodMultiplier,
                    fixingDates -> businessCenters -> businessCenter
                )
        else cde.datetime.ExpirationDate(product)

func GetReportTrackingNumber:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportingTrackingNumber string (0..1)

    alias role:
        FilterPartyRole(
                TradeForEvent(reportableEvent) -> partyRole,
                PartyRoleEnum -> ExecutionFacility
            ) -> partyReference only-element

    set reportingTrackingNumber:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter issuerReference = role
            then extract assignedIdentifier -> identifier
            then flatten
            then if item exists then item else "RTNNotProvided"
            then only-element

func GetRegimeSpecificIdentifiers:
    inputs:
        reportableInformation ReportableInformation (1..1)
        supervisoryBody SupervisoryBodyEnum (1..1)
        tradeIdentifierType TradeIdentifierTypeEnum (1..1)
    output:
        regimeSpecificIdentifiers string (0..*)

    alias regimeTransactionIds:
        reportableInformation -> transactionInformation
            then filter item -> supervisoryBody = supervisoryBody
            then transactionIdentifier filter identifierType = tradeIdentifierType

    add regimeSpecificIdentifiers:
        if (regimeTransactionIds exists)
        then regimeTransactionIds -> assignedIdentifier -> identifier

func ETDNotionalOption:
    inputs:
        optionPayout OptionPayout (0..1)
        tradeLot TradeLot (0..*)
    output:
        notional Measure (1..1)
    alias quantityCurrency:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> currency exists
            then extract value
            then only-element
    alias quantityFinancial:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> financialUnit exists
            then extract value
            then only-element

    alias strikePrice: optionPayout -> exerciseTerms -> strike -> strikePrice

    alias amount: // todo: consider contractSize
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then quantityCurrency
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then quantityFinancial * strikePrice -> value
    alias amountUnit:
        // Monetary schedule
        if tradeLot -> priceQuantity -> quantity -> unit -> currency exists
        then (tradeLot only-element -> priceQuantity -> quantity
            then filter unit -> currency exists
            then only-element
            then extract unit)
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then strikePrice -> unit

    set notional:
        Measure {
            value: amount,
            unit: amountUnit
        }

func ETDNotionalFuture:
    inputs:
//        product Product (0..1)
        tradeLot TradeLot (0..*)
    output:
        notional Measure (1..1)

    alias quantityCurrency:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> currency exists
            then extract value
            then only-element
    alias quantityFinancial:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> financialUnit exists
            then extract value
            then only-element

    alias price: tradeLot only-element -> priceQuantity -> price only-element

    alias amount: // todo: consider contractSize
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then quantityCurrency
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then quantityFinancial * price -> value

    alias amountUnit:
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then (tradeLot only-element -> priceQuantity -> quantity
            then filter unit -> currency exists
            then only-element
            then extract unit)
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then price -> unit

    set notional:
        Measure {
            value: amount,
            unit: amountUnit
        }

func IsRegulatedMarketOrThirdCountryEquivalentMarket: <"Returns True if the venue of execution of the trade is populated with a MIC code of a trading venue that was a regulated market or a third-country market considered as equivalent.">
    inputs:
        reportableInformation ReportableInformation (1..1)
        regime RegimeNameEnum (1..1)
    output:
        result boolean (1..1)

    alias getMic:
        GetOrFetchMicData(
                reportableInformation -> enrichment -> micData,
                GetVenueOfExecution(reportableInformation)
            )

    set result:
        if regime = RegimeNameEnum -> EMIR
        then (getMic -> marketCategoryEsma = MicMarketCategoryEnum -> RMKT // executed in a regulated market
                or IsESMAThirdCountryEquivalentMarket(getMic -> mic) = True // executed in a third country market considered as equivalent to regulated market
                )
        else if regime = RegimeNameEnum -> UKEMIR
        then (getMic -> marketCategoryFca = MicMarketCategoryEnum -> RMKT // executed in a regulated market
                or IsFCAThirdCountryEquivalentMarket(getMic -> mic) = True // executed in a third country market considered as equivalent to regulated market
                )

func GetCollateralBalancesForMarginType: <"'GetCollateralBalancesForMarginType' is a custom function that fetches Collateral Balances for required Margin Type.">
    inputs:
        reportableCollateral ReportableCollateral (1..1)
        marginType CollateralMarginTypeEnum (1..1)
    output:
        collateralBalances CollateralBalance (0..*)

    add collateralBalances:
        reportableCollateral -> collateralDetails -> collateral -> collateralPortfolio
            filter
                legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = marginType
            then extract collateralBalance
            then flatten

func GetMarginValue: <"'GetMarginValue' is a custom function that fetches Collateral Margin values for the required Margin Type.">
    inputs:
        partyCollateralBalances CollateralBalance (0..*)
        haircutType HaircutIndicatorEnum (1..1)
    output:
        marginValue Money (0..1)

    set marginValue:
        partyCollateralBalances
            filter haircutIndicator = haircutType
            then filter collateralBalanceStatus = CollateralStatusEnum -> FullAmount
            then extract amountBaseCurrency
            then only-element

func GetMarginCurrency: <"'GetMarginCurrency' is a custom function that fetches Collateral Margin currency for the required Margin Type.">
    inputs:
        partyCollateralBalances CollateralBalance (0..*)
    output:
        marginCurrency ISOCurrencyCodeEnum (0..1)

    /*
     * Rationale Reference: The rationale for the following code snippet is discussed in ISDA DRR Technical Execution Working Group on July 27' 2023.
     * Rationale: Current structure of CDM Collateral Object allows margin currency to be posted for each type of Haircut (Pre or Post). ESMA EMIR regulatory Rules does not specify the type of haircut to be considered for margin currency. This code snippet ensures and checks for both pre and post currency to be same.
     */
    set marginCurrency:
        if (GetMarginValue(partyCollateralBalances, HaircutIndicatorEnum -> PreHaircut) -> unit -> currency = GetMarginValue(
                    partyCollateralBalances,
                    HaircutIndicatorEnum -> PostHaircut
                ) -> unit -> currency)
        then (GetMarginValue(partyCollateralBalances, HaircutIndicatorEnum -> PreHaircut) -> unit -> currency
            then extract ConvertNonISOToISOCurrency)

func GetExecutionTimestamp:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        executionTime zonedDateTime (0..1)

    set executionTime:
        if reportableEvent -> reportableInformation -> originalExecutionTimestamp exists
        then reportableEvent -> reportableInformation -> originalExecutionTimestamp
        else (reportableEvent -> originatingWorkflowStep -> timestamp
            filter qualification = EventTimestampQualificationEnum -> executionDateTime
            then extract dateTime
            then only-element)

func PayoutLeg1:
    inputs:
        product Product (1..1)
        tradeLot TradeLot (0..1)
        reportableInformation ReportableInformation (0..1)
    output:
        payoutLeg PayoutLegWithAuxiliary (0..1)

    set payoutLeg:
        if IsCreditSwaption(product)
        then PayoutLegWithAuxiliary {
                creditDefaultPayout: EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout,
                ...
            }
        else if IsCreditDefaultSwap(product)
        then PayoutLegWithAuxiliary {
                creditDefaultPayout: EconomicTermsForProduct(product) -> payout -> creditDefaultPayout,
                ...
            }
        else if IsEquityOption(product)
                or IsInterestRateDebtOption(product)
                or (IsProductETD(product) and EconomicTermsForProduct(product) -> payout -> optionPayout exists)
        then PayoutLegWithAuxiliary {
                optionPayout: EconomicTermsForProduct(product) -> payout -> optionPayout only-element,
                tradeLot: tradeLot,
                isProductETD: IsProductETD(product),
                ...
            }
        else if Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg1(UnderlierForProduct(product)),
                ...
            }
        else if IsEquityForward(product)
                or (IsProductETD(product) and EconomicTermsForProduct(product) -> payout -> forwardPayout exists)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                tradeLot: tradeLot,
                isProductETD: IsProductETD(product),
                ...
            }
        else if IsEquity(product) or IsTotalReturnSwapDebtUnderlier(product)
        then PayoutLegWithAuxiliary {
                performancePayout: EconomicTermsForProduct(product) -> payout -> performancePayout only-element,
                tradeLot: tradeLot,
                ...
            }
        else if IsFXForward(product) or IsFXOption(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXLeg1(product),
                ...
            }
        else if IsFXSwap(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXSwapLeg1(product),
                ...
            }
        else if IsCommodityOption(product)
        then PayoutLegWithAuxiliary {
                optionPayout: EconomicTermsForProduct(product) -> payout -> optionPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                isProductETD: IsProductETD(product),
                ...
            }
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if (Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    ))
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if (Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    ))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(UnderlierForProduct(product))
                else CommodityLeg1(UnderlierForProduct(product)),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(product)
                else CommodityLeg1(product),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsSingleCommodityPayoutProduct(product)
        then PayoutLegWithAuxiliary {
                commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsCommodityFixedPriceForward(product)
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if IsCommodityFloatingPriceForward(product)
        then PayoutLegWithAuxiliary {
                commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsFixedFloatZeroCouponSwapKnownAmount(product)
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2FixedFloatSingleCurrency(product),
                ...
            }
        else if Qualify_InterestRate_Forward_Debt(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                ...
            }
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg1(product),
                ...
            }

func PayoutLeg2:
    inputs:
        product Product (1..1)
        tradeLot TradeLot (0..1)
        reportableInformation ReportableInformation (0..1)
    output:
        payoutLeg PayoutLegWithAuxiliary (0..1)

    set payoutLeg:
        if Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2(UnderlierForProduct(product)),
                ...
            }
        else if IsFXForward(product) or IsFXOption(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXLeg2(product),
                ...
            }
        else if IsFXSwap(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXSwapLeg2(product),
                ...
            }
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: CommodityLeg2(product),
                auxiliaryLeg: PayoutLeg {
                    fixedPricePayout: FixedPriceLeg1(product),
                    ...
                },
                ...
            }
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(product)
                else CommodityLeg2(product),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsCommodityFixedPriceForward(product)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                auxiliaryLeg: PayoutLeg {
                    fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                    ...
                },
                ...
            }
        else if IsCommodityFloatingPriceForward(product)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                auxiliaryLeg: PayoutLeg {
                    commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                    ...
                },
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product))
                or Qualify_AssetClass_Equity(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2(product),
                ...
            }

func Notional:
    inputs:
        payoutLeg PayoutLegWithAuxiliary (0..1)
    output:
        measure Measure (0..1)

    alias optionMultiplier:
        if payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier exists
                and payoutLeg -> optionPayout -> underlier -> security -> securityType <> SecurityTypeEnum -> Debt
        then payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier -> value
        else 1

    alias optionNotional:
        if payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> unit -> currency exists
        then Measure {
                unit: payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> unit,
                value: payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> value * optionMultiplier
            }
        else if payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then Measure {
                unit: payoutLeg -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unit,
                value: payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule -> value * optionMultiplier * payoutLeg -> optionPayout -> exerciseTerms -> strike -> strikePrice -> value
            }

    alias commodityOptionNotional:
        if payoutLeg -> optionPayout -> exerciseTerms -> strike -> strikePrice exists
        then Measure {
                unit: payoutLeg -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unit,
                value: cde.quantity.CommodityOptionNotional(payoutLeg -> optionPayout)
            }
        else if payoutLeg -> optionPayout -> exerciseTerms -> strike -> averagingStrikeFeature exists
        then if payoutLeg -> lastAvailableSpotPrice exists
            then Measure {
                    unit: payoutLeg -> lastAvailableSpotPrice -> unit,
                    value: cde.quantity.CommodityNotional(
                            payoutLeg -> optionPayout -> priceQuantity -> quantitySchedule,
                            payoutLeg -> lastAvailableSpotPrice
                        )
                }
            else payoutLeg -> tradeLot -> priceQuantity only-element -> quantity
                filter unit -> currency exists
            then only-element
            then extract
                Measure {
                    unit: unit,
                    value: value
                }

    alias creditDefaultNotional:
        payoutLeg -> creditDefaultPayout -> priceQuantity -> quantitySchedule
            then extract
                Measure {
                    unit: unit,
                    value: value
                }

    alias interestRateMultiplier:
        payoutLeg -> interestRatePayout -> priceQuantity -> quantitySchedule
            then extract
                if multiplier -> value exists
                then multiplier -> value
                else 1

    alias interestRateNotional:
        payoutLeg -> interestRatePayout -> priceQuantity
            then extract
                Measure {
                    unit: if quantitySchedule exists
                        then quantitySchedule -> unit
                    else if quantityReference exists
                    then quantityReference -> quantitySchedule -> unit,
                    value: if quantitySchedule exists
                        then quantitySchedule -> value * interestRateMultiplier
                }

    alias performanceMultiplier:
        payoutLeg -> performancePayout -> priceQuantity -> quantitySchedule
            then extract
                if multiplier -> value exists
                then multiplier -> value
                else 1

    alias performanceNotional:
        if payoutLeg -> performancePayout -> priceQuantity -> quantitySchedule -> unit -> currency exists
        then (payoutLeg -> performancePayout -> priceQuantity -> quantitySchedule
            then extract
                Measure {
                    unit: unit,
                    value: value * performanceMultiplier
                })
        else if payoutLeg -> tradeLot -> priceQuantity -> quantity -> unit -> currency exists
        then (payoutLeg -> tradeLot -> priceQuantity -> quantity
            then filter unit -> currency exists
            then only-element
            then extract
                Measure {
                    unit: unit,
                    value: value
                })

    alias forwardNotional:
        if payoutLeg -> auxiliaryLeg -> fixedPricePayout exists
        then Measure {
                unit: payoutLeg -> auxiliaryLeg -> fixedPricePayout -> fixedPrice -> price -> unit,
                value: cde.quantity.CommodityNotional(
                        payoutLeg -> forwardPayout -> priceQuantity -> quantitySchedule,
                        payoutLeg -> auxiliaryLeg -> fixedPricePayout -> fixedPrice -> price
                    )
            }
        else if payoutLeg -> auxiliaryLeg -> commodityPayout exists
        then (CommodityObservablePriceQuantity(
                payoutLeg -> tradeLot,
                payoutLeg -> auxiliaryLeg -> commodityPayout
            ) -> quantity
            filter unit -> currency exists
            then only-element
            then extract
                Measure {
                    unit: unit,
                    value: value
                })
        else if payoutLeg -> lastAvailableSpotPrice exists
        then Measure {
                unit: payoutLeg -> lastAvailableSpotPrice -> unit,
                value: cde.quantity.CommodityNotional(
                        payoutLeg -> forwardPayout -> priceQuantity -> quantitySchedule,
                        payoutLeg -> lastAvailableSpotPrice
                    )
            }
        else if payoutLeg -> forwardPayout -> priceQuantity -> quantitySchedule -> unit -> currency exists
        then (payoutLeg -> forwardPayout -> priceQuantity -> quantitySchedule
            then extract
                Measure {
                    unit: unit,
                    value: value
                })
        else if payoutLeg -> forwardPayout -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then (payoutLeg -> forwardPayout -> priceQuantity
            then extract
                Measure {
                    unit: quantitySchedule -> unit,
                    value: quantitySchedule -> value * priceSchedule only-element -> value
                })

    alias fixedPriceNotional:
        payoutLeg -> fixedPricePayout
            then extract
                Measure {
                    unit: fixedPrice -> price -> unit,
                    value: cde.quantity.CommodityNotional(
                            priceQuantity -> quantitySchedule,
                            fixedPrice -> price
                        )
                }

    alias cashflowNotional:
        payoutLeg -> cashflow -> priceQuantity
            then extract
                Measure {
                    unit: if quantitySchedule exists
                        then quantitySchedule -> unit
                    else if quantityReference exists
                    then quantityReference -> quantitySchedule -> unit,
                    value: quantitySchedule -> value
                }

    alias commodityNotional:
        if payoutLeg -> auxiliaryLeg -> fixedPricePayout exists
        then Measure {
                unit: payoutLeg -> auxiliaryLeg -> fixedPricePayout -> fixedPrice -> price -> unit,
                value: cde.quantity.CommodityNotional(
                        payoutLeg -> commodityPayout -> priceQuantity -> quantitySchedule,
                        payoutLeg -> auxiliaryLeg -> fixedPricePayout -> fixedPrice -> price
                    )
            }
        else if payoutLeg -> lastAvailableSpotPrice exists
        then Measure {
                unit: payoutLeg -> lastAvailableSpotPrice -> unit,
                value: cde.quantity.CommodityNotional(
                        payoutLeg -> commodityPayout -> priceQuantity -> quantitySchedule,
                        payoutLeg -> lastAvailableSpotPrice
                    )
            }
        else CommodityObservablePriceQuantity(
                payoutLeg -> tradeLot,
                payoutLeg -> commodityPayout
            ) -> quantity
            filter unit -> currency exists
            then only-element
            then extract
                Measure {
                    unit: unit,
                    value: value
                }

    alias optionETDNotional:
        ETDNotionalOption(payoutLeg -> optionPayout, payoutLeg -> tradeLot)

    alias futureETDNotional: ETDNotionalFuture(payoutLeg -> tradeLot)

    set measure:
        if payoutLeg -> optionPayout exists
        then if payoutLeg -> optionPayout -> underlier -> commodity exists
            then commodityOptionNotional
            else if payoutLeg -> isProductETD
            then optionETDNotional
            else optionNotional
        else if payoutLeg -> creditDefaultPayout exists
        then creditDefaultNotional
        else if payoutLeg -> interestRatePayout exists
        then interestRateNotional
        else if payoutLeg -> performancePayout exists
        then performanceNotional
        else if payoutLeg -> fixedPricePayout exists
        then fixedPriceNotional
        else if payoutLeg -> cashflow exists
        then cashflowNotional
        else if payoutLeg -> commodityPayout exists
        then commodityNotional
        else if payoutLeg -> forwardPayout exists
        then if payoutLeg -> isProductETD
            then futureETDNotional
            else forwardNotional

func GetContractType:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        contractType CommonContractType (0..1)

    set contractType:
        ProductForEvent(reportableEvent)
            then extract
                if IsFRA
                then FRAS
                else if Qualify_ForeignExchange_Spot_Forward(
                            contractualProduct -> economicTerms
                        )
                        or Qualify_ForeignExchange_NDF(contractualProduct -> economicTerms)
                        or IsSingleCommodityPayoutProduct
                        or IsCommodityForward
                        or Qualify_InterestRate_Forward_Debt(EconomicTermsForProduct)
                        or (Qualify_EquityForward_PriceReturnBasicPerformance_SingleIndex(
                                contractualProduct -> economicTerms
                            )
                            or Qualify_EquityForward_PriceReturnBasicPerformance_SingleName(
                                    contractualProduct -> economicTerms
                                )
                            or Qualify_EquityForward_PriceReturnBasicPerformance_Basket(
                                    contractualProduct -> economicTerms
                                ))
                then FORW
                else if IsIRSwaption or IsCreditSwaption or IsCommoditySwaption
                then SWPT
                else if Qualify_InterestRate_CapFloor(EconomicTermsForProduct)
                        or EconomicTermsForProduct -> payout -> optionPayout only exists or IsProductETD
                then OPTN
                else if Qualify_BaseProduct_IRSwap(contractualProduct -> economicTerms)
                        or Qualify_BaseProduct_Inflation(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_BaseProduct_CrossCurrency(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_AssetClass_Credit(contractualProduct -> economicTerms)
                        or Qualify_BaseProduct_EquitySwap(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_Commodity_Swap_FixedFloat(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_Commodity_Swap_Basis(contractualProduct -> economicTerms)
                        or IsFXSwap
                        or contractualProduct -> economicTerms -> payout -> performancePayout only exists
                then SWAP
                else if IsProductETD and EconomicTermsForProduct -> payout -> forwardPayout only exists
                then FUTR
                else OTHR

func GetAssetClass:
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        assetClass CommonAssetClass (0..1)

    set assetClass:
        if Qualify_AssetClass_InterestRate(economicTerms)
        then INTR
        else if Qualify_AssetClass_Credit(economicTerms)
        then CRDT
        else if Qualify_AssetClass_Equity(economicTerms)
        then EQUI
        else if Qualify_AssetClass_Commodity(economicTerms)
        then COMM
        else if Qualify_AssetClass_ForeignExchange(economicTerms)
        then CURR

func IsMax32UpperCaseAlphanumericText:
    inputs:
        text string (1..1)
    output:
        result boolean (1..1)
    set result: StringContains(text, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$")

func GetUnderlierProductIdentifier: <"Extracts a product identifier from the product underlier.">
    inputs:
        product Product (1..1)
    output:
        productId ProductIdentifier (0..*)

    add productId:
        if EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
        else if EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        if UnderlierForProduct(product) exists
        then UnderlierForProduct(product)
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
                else if index exists
                then index -> productIdentifier
                else if commodity exists and IsProductETD(product)
                then commodity -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        if (IsProductETD(product)
                and UnderlierForProduct(product) -> commodity -> productIdentifier exists)
        then UnderlierForProduct(product) -> commodity -> productIdentifier
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
        // swaptions
        else if UnderlierForProduct(product) -> contractualProduct -> productIdentifier exists
        then UnderlierForProduct(product) -> contractualProduct -> productIdentifier
        // IR on bond
        else if EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond exists
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond
        // Commodities Index: only for ETDs
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index -> productIdentifier
        // ETD Option on Futures on Index
        else if (IsProductETD(product)
                and UnderlierForProduct(UnderlierForProduct(product)) -> index exists)
        then UnderlierForProduct(UnderlierForProduct(product)) -> index -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

func GetNextFloatingReferenceResetDate:
    inputs:
        reportableEvent ReportableEvent (1..1)
        interestRateLeg InterestRatePayout (1..1)
    output:
        nextFloatingReferenceResetDate date (0..1)

    set nextFloatingReferenceResetDate:
        ProductForEvent(reportableEvent)
            then filter IsFRA = False
            then extract ProductOrUnderlierProduct
            then extract interestRateLeg
            then extract
                if rateSpecification -> floatingRate exists and resetDates exists
                then resetDates -> fixingDates -> adjustedDate
                else if rateSpecification -> inflationRate exists and resetDates exists
                then resetDates -> fixingDates -> adjustedDate

func ExtractReferenceEntity: <"For Credit Default Swaps or Credit Swaptions, extracts the reference entity that contains an LEI or CountryCode entityId, or if neither exists, returns any reference entity id.">
    inputs:
        reportableEvent ReportableEvent (0..1)
    output:
        referenceEntity string (0..1)

    alias product: ProductForEvent(reportableEvent)

    alias referenceEntityProduct:
        if IsCreditSwaption(product)
        then UnderlierForProduct(product) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceEntity
        else if IsCreditDefaultSwap(product)
        then product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceEntity

    alias referenceEntityByScheme:
        referenceEntityProduct -> entityId
            then filter
                (StringContains(
                        item -> scheme,
                        "http://www.fpml.org/coding-scheme/external/iso17442"
                    ) // LEI
                    or StringContains(
                            item -> scheme,
                            "http://www.fpml.org/coding-scheme/external/iso3166"
                        )) // CountryCode
            then first

    set referenceEntity:
        if referenceEntityByScheme exists and referenceEntityByScheme <> ""
        then referenceEntityByScheme
        else referenceEntityProduct -> entityId
            then last

func FormatToShortFraction5DecimalNumber: <"Rounds the number to fit within 25 digits, including up to 5 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 9999999999999999999999999
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 5, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 25, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToBaseOne18Rate: <"Rounds the number to fit within 18 digits, including up to 13 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 999999999999999999 
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 13, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 18, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToBaseOneRate: <"Rounds the number to fit within 11 digits, including up to 10 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999999999 
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 10, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 11, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToMax5Number: <"Rounds the number to fit within 5 digits, with no decimals. If the length of the integer part exceeds the allowed limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999 
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 0, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 5, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToMax3Number: <"Rounds the number to fit within 3 digits, with no decimals. If the length of the integer part exceeds the allowed limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999 
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 0, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 3, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToLongFraction20DecimalNumber: <"Rounds the number to fit within 20 digits, including up to 19 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999999999999999999 
        then (RoundToPrecisionRemoveTrailingZeros(inputNumber, 19, RoundingDirectionEnum -> Nearest)
            then RoundToSignificantFigures(item, 20, RoundingDirectionEnum -> Nearest))
        else inputNumber