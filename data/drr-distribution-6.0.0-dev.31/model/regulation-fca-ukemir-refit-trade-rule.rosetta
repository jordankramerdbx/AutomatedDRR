namespace drr.regulation.fca.ukemir.refit.trade
version "6.0.0-dev.31"

import cdm.base.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.qualification.*
import cdm.event.workflow.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.master.*
import cdm.observable.asset.*
import cdm.product.qualification.*

import drr.regulation.common.*
import drr.regulation.fca.*
import drr.regulation.fca.ukemir.*
import drr.regulation.fca.ukemir.refit.*
import drr.standards.iosco.cde.* as cde
import drr.standards.iso.*
import cdm.base.math.*

corpus Dissemination Trade

report FCA UKEMIR Trade in T+1
  	from TransactionReportInstruction
  	when ReportableProduct
  	with type FCAUKEMIRTransactionReport

// Test Eligibility Rule
eligibility rule ReportableProduct from TransactionReportInstruction: <"When eligible for JFSA">
    [regulatoryReference FCA UKEMIR Trade article "9" paragraph "1"
        provision "Counterparties and CCPs shall ensure that the details of any derivative contract they have concluded and of any modification or termination of the contract are reported to a trade repository registered in accordance with Article 55 or recognised in accordance with Article 77. The details shall be reported no later than the working day following the conclusion, modification or termination of the contract."]
    extract True

// UK EMIR Definitions
reporting rule ReportingTimestamp from TransactionReportInstruction: <"Reporting Timestamp">
    [regulatoryReference FCA UKEMIR table "1" dataElement "1" field "Reporting timestamp"
        provision "Date and time of the submission of the report to the trade repository."]
    cde.datetime.ReportingTimestamp
        as "1.1 Reporting Timestamp"

reporting rule ReportSubmittingEntityID from TransactionReportInstruction: <"Report Submitting entity ID ">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "2" field "Report Submitting entity ID"
        provision "In the case where the entity responsible for reporting has delegated the submission of the report to a third party or to the other counterparty, that entity has to be identified in this field by a unique code. Otherwise the entity responsible for reporting should be identified in this field."]
    extract ExtractReportSubmittingPartyIdentifier(reportingSide)
        as "1.2 Report Submitting entity ID"

reporting rule EntityResponsibleForReporting from TransactionReportInstruction: <"Entity responsible for reporting">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "3" field "Entity responsible for reporting"
        provision "Where a financial counterparty is solely responsible, and legally liable, for reporting on behalf of both counterparties in accordance with Article 9(1a) of Regulation (EU) No 648/2012 and the non-financial counterparty does not decide to report itself the details of its OTC derivative contracts with the financial counterparty, the unique code identifying that financial counterparty. Where a management company is responsible, and legally liable, for reporting on behalf of an Undertaking for Collective Investment in Transferable Securities (UCITS) in accordance with Article 9(1b) of that Regulation, the unique code identifying that management company. Where an Alternative Investment Fund Manager (AIFM) is responsible, and legally liable, for reporting on behalf of an Alternative Investment Fund (AIF) in accordance with Article 9(1c) of that Regulation, the unique code identifying that AIFM. Where the trustees or managers of an occupational pension scheme are responsible, and legally liable, for reporting on its behalf in accordance with Article 9(1d) of that Regulation, the unique code identifying those trustees or managers. This field is applicable only to the OTC derivatives."]
    extract
        if IsRegulatedMarketOrThirdCountryEquivalentMarket(
                    reportableInformation,
                    RegimeNameEnum -> UKEMIR
                ) = False // Not executed in a regulated market or 3rd country equivalent Market
        then ExtractPartyResponsibleForReportingIdentifier(reportingSide)
        as "1.3 Entity responsible for reporting"

reporting rule Counterparty1 from TransactionReportInstruction: <"Counterparty 1 (reporting counterparty)">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "4" field "Counterparty 1 (reporting counterparty)"
        provision "Identifier of the counterparty to a derivative transaction who is fulfilling its reporting obligation via the report in question. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund and not the fund manager is reported as the counterparty."]
    extract cde.party.Counterparty1
        as "1.4 Counterparty 1 (reporting counterparty)"

reporting rule NatureOfCounterparty1 from TransactionReportInstruction: <"Nature of the Counterparty 1">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "5" field "Nature of the Counterparty 1"
        provision "Indicate if the counterparty 1 is a CCP, a financial, non-financial counterparty or other type of counterparty as defined in points 1, 8 and 9 of Article 2 of Regulation (EU) No 648/2012 or an entity as referred to in accordance with point 5 of Article 1."]
    /*
     * F = Financial Counterparty
     * N = Non-Financial Counterparty
     * C = Central Counterparty
     * O = Other
     */
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter partyReference = reportInstruction -> reportingSide -> reportingParty
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract
                if natureOfParty = NatureOfPartyEnum -> Financial
                then "F"
                else if natureOfParty = NatureOfPartyEnum -> NonFinancial
                then "N"
                else if natureOfParty = NatureOfPartyEnum -> CentralCounterparty
                then "C"
                else if natureOfParty = NatureOfPartyEnum -> Exempt
                then "O"
    ]
        as "1.5 Nature of the Counterparty 1"

reporting rule CorporateSectorOfTheCounterparty1 from TransactionReportInstruction: <"Corporate sector of the counterparty 1">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "6" field "Corporate sector of the counterparty 1"
        provision "Nature of the counterparty 1s company activities. If the counterparty 1 is a financial counterparty, this field shall contain all necessary codes included in the Taxonomy for Financial Counterparties in field 6 of Table 1 of the Annex to EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023 and applying to that counterparty. If the counterparty 1 is a non-Financial Counterparty, this field shall contain all necessary codes included in the Taxonomy for Non-Financial Counterparties in field 6 of Table 1 of the Annex to EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023 and applying to that counterparty. Where more than one activity is reported, the codes shall be populated in order of the relative importance of the corresponding activities."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            then filter
                partyReference = reportInstruction -> reportingSide -> reportingParty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> Financial
                        or regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract
                if natureOfParty = NatureOfPartyEnum -> NonFinancial
                then GetNonFinancialCorporateSector(corporateSector -> nonFinancialSector)
                else if natureOfParty = NatureOfPartyEnum -> Financial
                then GetFinancialCorporateSector(corporateSector -> financialSector)
    ]
        as "1.6 Corporate sector of the counterparty 1"

reporting rule ClearingThresholdOfCounterparty1 from TransactionReportInstruction: <"Clearing Threshold of Counterparty 1">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "7" field "Clearing Threshold of Counterparty 1"
        provision "Information whether counterparty 1 is above the clearing threshold referred to in Article 4a or 10 of Regulation (EU) No 648/2012 at the date when the transaction was concluded."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingParty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> Financial
                        or regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation
            then extract fcaPartyInformation -> exceedsClearingThreshold
            then only-element
    ]
        as "1.7 Clearing Threshold of Counterparty 1"

reporting rule Counterparty2IdentifierType from TransactionReportInstruction: <"Counterparty 2 Identifier Type">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "8" field "Counterparty 2 Identifier Type"
        provision "Indicator of whether LEI was used to identify counterparty 2."]
    extract cde.party.Counterparty2IdentifierType
        as "1.8 Counterparty 2 Identifier Type"

reporting rule Counterparty2 from TransactionReportInstruction: <"Counterparty 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "9" field "Counterparty 2"
        provision "Identifier of the second counterparty to a derivative transaction. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund and not the fund manager is reported as the counterparty."]
    extract cde.party.Counterparty2
        as "1.9 Counterparty 2"

// CDE logic is returning same LEI as Cpty 1
reporting rule CountryOfTheCounterParty2 from TransactionReportInstruction: <"Country of the counterparty 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "10" field "Country of the counterparty 2"
        provision "In case counterparty 2 is a natural person, the code of country of residence of that person."]
    filter IsAllowableAction
    then extract reportInstruction [
        extract reportableInformation -> partyInformation
        then filter
            partyReference = reportInstruction -> reportingSide -> reportingCounterparty
        then only-element
        then extract
            partyReference -> person -> contactInformation -> address -> country only-element
        then extract to-enum ISOCountryCodeEnum
    ]
        as "1.10 Country of the counterparty 2"

reporting rule NatureOfTheCounterparty2 from TransactionReportInstruction: <"Nature of the Counterparty 2">
    [regulatoryReference FCA UKEMIR table "1" dataElement "11" field "Nature of the Counterparty 2"
        provision "Indicate if counterparty 2 is a CCP, a financial, non-financial counterparty or other type of counterparty in accordance with point 5 of Article 1 or points 1, 8 and 9 of Article 2 of Regulation (EU) No 648/2012."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract
                if natureOfParty = NatureOfPartyEnum -> Financial
                then "F"
                else if natureOfParty = NatureOfPartyEnum -> NonFinancial
                then "N"
                else if natureOfParty = NatureOfPartyEnum -> CentralCounterparty
                then "C"
                else if natureOfParty = NatureOfPartyEnum -> Exempt
                then "O"
    ]
        as "1.11 Nature of the Counterparty 2"

reporting rule CorporateSectorOfTheCounterparty2 from TransactionReportInstruction: <"Corporate sector of the counterparty 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "12" field "Corporate sector of the counterparty 2"
        provision "Nature of counterparty 2s company activities. If counterparty 2 is a financial counterparty, this field shall contain all necessary codes included in the Taxonomy for Financial Counterparties in field 6 of Table 1 of the Annex to EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023 and applying to that counterparty. If counterparty 2 is a non-financial counterparty, this field shall contain all necessary codes included in the Taxonomy for Non-Financial Counterparties in field 6 of Table 1 of the Annex to EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023 and applying to that counterparty. Where more than one activity is reported, the codes shall be populated in order of the relative importance of the corresponding activities."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> Financial
                        or regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract
                if natureOfParty = NatureOfPartyEnum -> NonFinancial
                then GetNonFinancialCorporateSector(corporateSector -> nonFinancialSector)
                else if natureOfParty = NatureOfPartyEnum -> Financial
                then GetFinancialCorporateSector(corporateSector -> financialSector)
    ]
        as "1.12 Corporate sector of the counterparty 2"

reporting rule ClearingThresholdOfCounterparty2 from TransactionReportInstruction: <"Clearing Threshold of Counterparty 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "13" field "Clearing Threshold of Counterparty 2"
        provision "Information whether counterparty 2 is above the clearing threshold referred to in Article 4a or 10 of Regulation (EU) No 648/2012 at the date when the transaction was concluded."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> Financial
                        or regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract exceedsClearingThreshold
    ]
        as "1.13 Clearing Threshold of Counterparty 2"

reporting rule ReportingObligationOfTheCounterparty2 from TransactionReportInstruction: <"Reporting obligation of the counterparty 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "14" field "Reporting obligation of the counterparty 2"
        provision "Indicator of whether counterparty 2 has the reporting obligation under Regulation (EU) No 648/2012 irrespective of who is responsible and legally liable for its reporting."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportInstruction -> reportableInformation -> partyInformation
            filter
                partyReference = reportInstruction -> reportingSide -> reportingCounterparty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> Financial
                        or regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation -> fcaPartyInformation
            then only-element
            then extract
                (natureOfParty = NatureOfPartyEnum -> Financial
                    or (natureOfParty = NatureOfPartyEnum -> NonFinancial
                        and exceedsClearingThreshold = True))
    ]
        as "1.14 Reporting obligation of the counterparty 2"

reporting rule BrokerID from TransactionReportInstruction: <"Broker ID">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "15" field "Broker ID"
        provision "In the case a broker acts as intermediary for the counterparty 1 without becoming a counterparty himself, the counterparty 1 shall identify this broker by a unique code."]
    [regulatoryReference ISDA PeerReviewGroup date "20230627"
        provision "'Broker' is understood in the traditional way, it means as intermediary role. Which leads to 'Arranging Broker' party role."]
    filter IsAllowableAction
    then extract
        ExtractPartyFromRelatedPartyByRole(
                reportableInformation -> partyInformation -> relatedParty,
                PartyRoleEnum -> ArrangingBroker
            )
    then extract PartyLei(partyId)
        as "1.15 Broker ID"

reporting rule ClearingMember from TransactionReportInstruction: <"Clearing member">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "16" field "Clearing member"
        provision "Identifier of the clearing member through which a derivative transaction was cleared at a CCP. This data element is applicable to cleared transactions."]
    filter IsAllowableAction
    then extract cde.settlement.ClearingMember
        as "1.16 Clearing member"

reporting rule Direction from TransactionReportInstruction: <"Direction">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "17" field "Direction"
        provision "Indicator of whether counterparty 1 is the buyer or the seller as determined at the time of the transaction."]
    /*
     * 4 alphabetic characters:
     * 	BYER = buyer
     * 	SLLR = seller
     * Populated in accordance with Article 3a
     */
    // extract if CDECounterparty1() = CDEDirection1BuyerIdentifier() then "BYER" else "SLLR"
    filter IsAllowableAction
    then extract cde.party.Direction1
        as "1.17 Direction"

reporting rule DirectionOfLeg1 from TransactionReportInstruction: <"Direction of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "18" field "Direction of leg 1"
        provision "Indicator of whether the counterparty 1 is the payer or the receiver of leg 1 as determined at the date the derivative was concluded."]
    /*
     * 4 alphabetic characters:
     * 	MAKE = payer
     * 	TAKE = receiver
     * Populated in accordance with Article 3a
     */
    filter IsAllowableAction
    then extract
        cde.party.Direction2(
                item,
                TradeForEvent
                    extract trade [
                        trade -> tradableProduct -> product
                            extract
                                if IsCommoditySwapFloatFloat
                                then CommodityLeg1 -> payerReceiver
                                else if IsCommoditySwapFixedFloat
                                then FixedPriceLeg1 -> payerReceiver
                                else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                                then contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver
                                else if IsFXForward
                                then FXLeg1 -> payerReceiver
                                else if IsFXSwap
                                then FXSwapLeg1 -> payerReceiver
                                else if Qualify_InterestRate_Option_Swaption(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_InterestRate_CapFloor(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_AssetClass_Credit(
                                                contractualProduct -> economicTerms
                                            ) = False
                                then InterestRateLeg1 -> payerReceiver
                    ]
            )
        as "1.18 Direction of leg 1"

reporting rule DirectionOfLeg2 from TransactionReportInstruction: <"Direction of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "19" field "Direction of leg 2"
        provision "Indicator of whether the counterparty 1 is the payer or the receiver of leg 2 as determined at the date the derivative was concluded."]
    /*
     * 4 alphabetic characters:
     * 	MAKE = payer
     * 	TAKE = receiver
     * Populated in accordance with Article 3a
     */
    filter IsAllowableAction
    then extract
        cde.party.Direction2(
                item,
                TradeForEvent -> tradableProduct -> product
                    then extract
                        if IsCommoditySwap
                        then CommodityLeg2 -> payerReceiver
                        else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                        then (if InterestRateLeg2 exists
                            then InterestRateLeg2 -> payerReceiver
                            else if contractualProduct -> economicTerms -> payout -> fixedPricePayout exists
                            then contractualProduct -> economicTerms -> payout -> fixedPricePayout -> payerReceiver
                                distinct
                                only-element)
                        else if IsFXForward
                        then FXLeg2 -> payerReceiver
                        else if IsFXSwap
                        then FXSwapLeg2 -> payerReceiver
                        else if Qualify_InterestRate_Option_Swaption(
                                        contractualProduct -> economicTerms
                                    ) = False
                                and Qualify_InterestRate_CapFloor(
                                        contractualProduct -> economicTerms
                                    ) = False
                                and Qualify_AssetClass_Credit(
                                        contractualProduct -> economicTerms
                                    ) = False
                        then InterestRateLeg2 -> payerReceiver
            )
        as "1.19 Direction of leg 2"

reporting rule DirectlyLinkedToCommercialActivityOrTreasuryFinancing from TransactionReportInstruction: <"Directly linked to commercial activity or treasury financing">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "20" field "Directly linked to commercial activity or treasury financing"
        provision "Information on whether the contract is objectively measurable as directly linked to counterparty 1s commercial or treasury financing activity, as referred to in Article 10(3) of Regulation (EU) No 648/2012. This field shall be populated only where the counterparty 1 is a non-financial counterparty, as referred to in Article 2(9) of the Regulation (EU) No 648/2012."]
    filter IsAllowableAction
    then extract reportableEvent [
        reportableEvent -> reportableInformation -> partyInformation
            filter
                partyReference = reportableEvent -> reportingSide -> reportingParty
                    and (regimeInformation -> fcaPartyInformation -> natureOfParty any = NatureOfPartyEnum -> NonFinancial)
            then only-element
            then extract regimeInformation -> fcaPartyInformation -> directlyLinkedActivity
            then only-element
    ]
        as "1.20 Directly linked to commercial activity or treasury financing"

reporting rule ExecutionAgentReportingParty from TransactionReportInstruction: <"Execution Agent for the Reporting Counterparty">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "21" field "ExecutionAgent"
        provision "LEI identifying the entity that executed the transaction on behalf of the counterparty, and binds the counterparty to the terms of the transaction, but is not a broker."]
    filter IsAllowableAction
    then extract reportableEvent [
        reportableEvent -> reportableInformation -> partyInformation
            filter partyReference = reportableEvent -> reportingSide -> reportingParty
            then distinct only-element
            then extract
                ExtractPartyFromRelatedPartyByRole(
                        relatedParty,
                        PartyRoleEnum -> ExecutionAgent
                    )
            then extract PartyLei(partyId)
    ]
        as "1.21 Execution Agent Reporting Party"

reporting rule ExecutionAgentReportingCounterparty from TransactionReportInstruction: <"Execution Agent for the Other Counterparty">
    [regulatoryReference FCA UKEMIR Trade table "1" dataElement "21" field "ExecutionAgent"
        provision "LEI identifying the entity that executed the transaction on behalf of the counterparty, and binds the counterparty to the terms of the transaction, but is not a broker."]
    filter IsAllowableAction
    then extract reportableEvent [
        reportableEvent -> reportableInformation -> partyInformation
            filter partyReference = reportableEvent -> reportingSide -> reportingCounterparty
            then distinct only-element
            then extract
                ExtractPartyFromRelatedPartyByRole(
                        relatedParty,
                        PartyRoleEnum -> ExecutionAgent
                    )
            then extract PartyLei(partyId)
    ]
        as "1.21 Execution Agent Reporting Counterparty"

reporting rule UTIFCAValue from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC"> //do ESMA mean Trade or Transaction?
    extract
        if GetRegimeSpecificIdentifiers(
                reportableInformation,
                SupervisoryBodyEnum -> FCA,
                TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            )
            exists
        then GetRegimeSpecificIdentifiers(
                    reportableInformation,
                    SupervisoryBodyEnum -> FCA,
                    TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
                )
        else if TradeForEvent exists
        then (TradeForEvent -> tradeIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
        else if PositionForEvent exists
        then (PositionForEvent -> positionIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
    then distinct
    then only-element

reporting rule UTI from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC"> //do ESMA mean Trade or Transaction?
    [regulatoryReference FCA UKEMIR table "2" dataElement "1" field "UTI"
        provision "Unique Transaction Identifier as referred to in Article 8 of the EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023."]
    UTIFCAValue then filter IsMax32UpperCaseAlphanumericText = True
        as "2.1 UTI"

reporting rule UTIProprietary from TransactionReportInstruction: <"Unique Transaction Identifier as managed by LEIROC"> //do ESMA mean Trade or Transaction?
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "1" field "UTI"
        provision "Unique Transaction Identifier as referred to in Article 8 of the EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023."]
    UTIFCAValue then filter IsMax32UpperCaseAlphanumericText = False
        as "2.1 UTI (Proprietary)"

reporting rule ReportTrackingNumber from TransactionReportInstruction: <"Report Tracking Number">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "2" field "Report Tracking Number"
        provision "Where a derivative was executed on a trading venue, a number generated by the trading venue and unique to that execution."]
    filter IsAllowableAction
    then extract
        if (GetOrFetchMicData(
                        reportableInformation -> enrichment -> micData,
                        GetVenueOfExecution(reportableInformation)
                    ) -> countryCode = "GB"
                and GetVenueOfExecution(reportableInformation) exists
                and PositionForEvent is absent
                and UKEMIRIsMicXOFF = False
                and UKEMIRIsMicXXXX = False)
        then GetReportTrackingNumber
        as "2.2 Report Tracking Number"

reporting rule PriorUTI from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "3" field "Prior UTI"
        provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (e.g. in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (e.g. in clearing or if a transaction is split into several different transactions). This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (e.g. in the case of a compression)."]
    filter IsAllowableAction
    then if originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                or (TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                    and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False)
        then extract cde.link.PriorUTI
        else (extract reportableInformation -> transactionInformation
        then filter
            regimeName = RegimeNameEnum -> UKEMIR
                and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
        then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
        then flatten
        then distinct
        then only-element)
    then filter IsMax32UpperCaseAlphanumericText = True
        as "2.3 Prior UTI"

reporting rule PriorUTIProprietary from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "3" field "Prior UTI"
        provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (e.g. in the case of a novation, when a transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (e.g. in clearing or if a transaction is split into several different transactions). This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (e.g. in the case of a compression)."]
    filter IsAllowableAction
    then if originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                or (TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                    and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False)
        then extract cde.link.PriorUTI
        else (extract reportableInformation -> transactionInformation
        then filter
            regimeName = RegimeNameEnum -> UKEMIR
                and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
        then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
        then flatten
        then distinct
        then only-element)
    then filter IsMax32UpperCaseAlphanumericText = False
        as "2.3 Prior UTI (Proprietary)"

reporting rule SubsequentPositionUTI from TransactionReportInstruction: <"Subsequent Position UTI">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "4" field "Subsequent Position UTI"
        provision "The UTI of the position in which a derivative is included. This field is applicable only for the reports related to the termination of a derivative due to its inclusion in a position."]
    filter
        (IsActionTypeMODI or IsActionTypeCORR or IsActionTypeTERM or IsActionTypeREVI or IsActionTypePOSC)
    then extract
        if reportableInformation -> subsequentPositionUTI exists
        then reportableInformation -> subsequentPositionUTI
    then filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
    then extract assignedIdentifier -> identifier
    then distinct
    then only-element
        as "2.4 Subsequent Position UTI"

reporting rule PTRRID from TransactionReportInstruction: <"PTRR ID">
    [regulatoryReference FCA UKEMIR table "2" dataElement "5" field "PTRR ID"
        provision "Identifier generated by the PTRR service provider or CCP providing the PTRR service in order to connect all derivatives entering into a given PTRR event and resulting from that PTRR event."]
    filter
        (IsActionTypeNEWT or IsActionTypeMODI or IsActionTypeCORR or IsActionTypeTERM or IsActionTypeREVI)
    then extract reportableEvent [
        reportableEvent -> originatingWorkflowStep -> eventIdentifier
            then extract eventIdentifier [
                eventIdentifier
                    // Event filtering
                    then filter
                        if IsCompressed(reportableEvent -> originatingWorkflowStep)
                                or IsPortfolioRebalancing(
                                        reportableEvent -> originatingWorkflowStep
                                    )
                        // Issuer = PTRRServiceProvider
                        then (if reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction -> execution exists
                            then issuerReference = FilterPartyRole(
                                        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction -> execution -> partyRoles,
                                        PartyRoleEnum -> PTRRServiceProvider
                                    ) -> partyReference
                                    distinct
                                    only-element
                            else issuerReference = FilterRelatedPartyByRole(
                                    reportableEvent -> reportableInformation -> partyInformation -> relatedParty,
                                    PartyRoleEnum -> PTRRServiceProvider
                                ) -> partyReference
                                distinct
                                only-element)
                    then extract eventIdentifier -> assignedIdentifier -> identifier
            ]
            then flatten
    ]
    then only-element
        as "2.5 PTRR ID"

reporting rule PackageIdentifier from TransactionReportInstruction: <"Package identifier">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "6" field "Package identifier"
        provision "Identifier (determined by the counterparty 1) in order to connect derivatives in the same package in accordance with Article 3(3). A package may include reportable and non-reportable transactions."]
    filter IsAllowableAction
    then extract GetPackageInformation
    then extract cde.link.PackageIdentifier
    then only-element
        as "2.6 Package identifier"

reporting rule ISIN from TransactionReportInstruction: <"ISIN">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "7" field "ISIN"
        provision "ISIN identifying the product if that product is admitted to trading or traded on a regulated market, MTF, OTF or systematic internaliser."]
    filter
        IsAllowableAction and reportableInformation -> transactionInformation -> fcaTransactionInformation only-element -> tradableOnTradingVenue = TradableOnTradingVenueEnum -> Admitted
    then extract ProductForEvent
    then extract [
        [contractualProduct -> productIdentifier, security -> productIdentifier]
            filter source = ProductIdTypeEnum -> ISIN
            then only-element
            then extract identifier
    ]
        as "2.7 ISIN"

reporting rule UPI from TransactionReportInstruction: <"UPI">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "8" field "UPI"
        provision "UPI identifying the product."]
    filter
        IsAllowableAction and reportableInformation -> transactionInformation -> fcaTransactionInformation only-element -> tradableOnTradingVenue = TradableOnTradingVenueEnum -> NotAdmitted
    then extract ProductForEvent
    then extract [
        [contractualProduct -> productIdentifier, security -> productIdentifier]
            then filter source = ProductIdTypeEnum -> UPI
            then only-element
            then extract identifier
    ]
        as "2.8 UPI"

reporting rule ProductClassification from TransactionReportInstruction: <"Product classification">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "9" field "Product classification"
        provision "Classification of Financial Instrument (CFI) code pertaining to the instrument."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract [
        [contractualProduct -> productTaxonomy, security -> productTaxonomy, basket -> productTaxonomy, index -> productTaxonomy, loan -> productTaxonomy]
            filter source = TaxonomySourceEnum -> CFI
            then only-element
            then extract value -> name
    ]
        as "2.9 Product classification"

reporting rule ContractType from TransactionReportInstruction: <"Contract Type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "10" field "Contract type"
        provision "Each reported contract shall be classified according to its type."]
    [regulatoryReference ISDA PeerReviewGroup date "20230920"
        provision "SPDB and CFDS output values will not be supported in DRR until CDM is able to functionally qualify them as distinct products. The qualification of these products needs to be backed by transaction or reporting samples provided by DRR firms."]
    [regulatoryReference ISDA PeerReviewGroup date "20230920"
        provision "OTHR is populated if none of the possible outputs are a precise fit"]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20231003"
        provision "The decision has been to apply ETD functionality to all products as a matter of prudence and consistency, understanding products like Swap are generally not ETD"]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsFRA
        then "FRAS"
        else if Qualify_ForeignExchange_Spot_Forward(contractualProduct -> economicTerms)
                or // this is going to need additional date treatments to distinguish spot vs forward per ESMA rules
                Qualify_ForeignExchange_NDF(contractualProduct -> economicTerms)
                    // this needs to be extended to cover other types of Forwards (e.g. Commodity, Equity, Bond) once the CDM contains suitable examples
                or IsSingleCommodityPayoutProduct
                or IsCommodityForward
                or Qualify_InterestRate_Forward_Debt(EconomicTermsForProduct)
        then "FORW"
        else if IsProductETD and EconomicTermsForProduct -> payout -> forwardPayout only exists
        then "FUTR"
        else if IsIRSwaption or IsCreditSwaption or IsCommoditySwaption
        then "SWPT"
        else if Qualify_InterestRate_CapFloor(EconomicTermsForProduct)
                or EconomicTermsForProduct -> payout -> optionPayout only exists
        then "OPTN"
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
                or Qualify_BaseProduct_Inflation(EconomicTermsForProduct)
                or Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct)
                or Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(
                        EconomicTermsForProduct
                    )
                or Qualify_AssetClass_Credit(EconomicTermsForProduct)
                or Qualify_BaseProduct_EquitySwap(EconomicTermsForProduct)
                or Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct)
                or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct)
                or // Commodity will need to be refined once further product types are added to the model, possible scope for an AssetClass qualification rule
                IsFXSwap
                or EconomicTermsForProduct -> payout -> performancePayout only exists // TH Review: what does only 1 performancePayout describe?
        then "SWAP"
        else "OTHR"
        as "2.10 Contract Type"

reporting rule AssetClass from TransactionReportInstruction: <"Asset Class">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "11" field "Asset class"
        provision "Each reported contract shall be classified according to the asset class it is based on."]
    [regulatoryReference FCA QandA_On_EMIR_Reporting section "TR" question "1"
        provision "TR Question 1 [last update 24 September 2020] How should the following financial instruments be classified for reporting and other purposes under EMIR? (b) Cross-currency swaps, swaptions, Caps and Floors? (c) Total Return Swaps
				TR Answer 1 (b) These financial instruments should be classified as interest rates, in line with current market practice. On the sections to be reported, ESMA finds that where both sections are relevant having in mind the terms of the contract being reported, both sections of reporting fields are to be reported i.e.option and interest rate for swaption, Caps and Floors, and FX and interest rate or crosscurrency swaps. The contract type (Field 1 of Table 2) should be populated with the value ST for swaption.There are two fields for the notional amount currency and one for the notional amount. To avoid that one counterparty reports the notional amount in CCY1 (Field 9 of Table 2) while the other would report in CCY2 (Field 10 of Table 2), which would create a reconciliation problem, the Field Notional Amount (Field 20 of Table 2) should be denominated in the currency reported in Notional currency 1 (Field 9 of Table 2).
			(c) Total Return Swaps should be classified based on the underlying. For example, a Total Return Swap on an equity index should be reported with value EQ in field Asset class (Table 2 field 2), whereas a Total Return Swap on a bond or loan should be reported with value CR in field Asset class (Table 2 field 2)."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if Qualify_AssetClass_InterestRate(EconomicTermsForProduct)
        then "INTR"
        else if Qualify_AssetClass_Credit(EconomicTermsForProduct)
        then "CRDT"
        else if Qualify_AssetClass_Equity(EconomicTermsForProduct)
        then "EQUI"
        else if Qualify_AssetClass_Commodity(EconomicTermsForProduct) or IsSingleCommodityPayoutProduct
        then "COMM"
        else if Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct)
        then "CURR"
        as "2.11 Asset Class"

reporting rule DerivativeBasedOnCryptoAssets from TransactionReportInstruction: <"Derivative based on crypto-assets">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "12" field "Derivative based on crypto-assets"
        provision "Indicator whether the derivative is based on crypto-assets."]
    extract
        if reportableInformation -> cryptoBased exists
        then reportableInformation -> cryptoBased
        else False
        as "2.12 Derivative based on crypto-assets"

reporting rule UnderlyingIdentificationType from TransactionReportInstruction: <"Underlying Identification Type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "13" field "Underlying Identification Type"
        provision "The type of relevant underlying identifier."]
    [regulatoryReference ISDA PeerReviewGroup date "20230426"
        provision "Regarding test samples of Equity baskets with a single index or a single security with an ISIN, the view of Credit Suisse's representative is that those samples are valid because they illustrate an acceptable boundary condition."]
    [regulatoryReference ISDA PeerReviewGroup date "20230426"
        provision "Regarding whether the underlying ISIN will always be used in EMIR reporting, the view of Credit Suisse's representative is that MIFID only accepts ISIN."]
    filter IsAllowableAction
    then extract GetUnderlyingIdentificationType
        as "2.13 Underlying Identification Type" // todo: clarify whether commo should result in a value here

reporting rule UnderlyingIdentification from TransactionReportInstruction: <"Underlying Identification">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "14" field "Underlying Identification"
        provision "The direct underlying shall be identified by using a unique identification for this underlying based on its type. For Credit Default Swaps, the ISIN of the reference obligation should be provided."]
    filter IsAllowableAction
    then extract
        (if IsCreditSwaption(ProductForEvent) or IsIRSwaption(ProductForEvent)
        then UnderlierForProduct(ProductForEvent)
        else ProductForEvent)
    then extract
        // Underlying Identification Type = I for ISIN
        if UnderlierForProduct -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then identifier)
        else if UnderlierForProduct -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if (IsProductETD and UnderlierForProduct -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (UnderlierForProduct -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        // Underlying Identification Type = X for Index
        else if UnderlierForProduct -> index exists
        then (UnderlierForProduct -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then last
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if IsFRA
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
        then ([EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId first, EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexReferenceInformation -> indexId first] only-element)
    then last
        as "2.14 Underlying Identification"

reporting rule IndicatorOfTheUnderlyingIndex from TransactionReportInstruction: <"Indicator of the underlying index">
    [regulatoryReference FCA UKEMIR table "2" field "15"
        provision "An indication of the underlying index, where available."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> index exists
                and UnderlierForProduct -> index -> productIdentifier -> source any = ProductIdTypeEnum -> Name
        then (UnderlierForProduct -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        // Commodities: only for ETDs
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists and IsSingleCommodityPayoutProduct = False)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if Qualify_InterestRate_Fra(EconomicTermsForProduct)
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex
            first
            to-string
    then extract GetIndexIndicatorFromFloatingRate
        as "2.15 Indicator of the underlying index"

reporting rule NameOfTheUnderlyingIndex from TransactionReportInstruction: <"Name of the underlying index">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "16" field "Name of the underlying index"
        provision "The full name of the underlying index as assigned by the index provider."]
    filter IsAllowableAction
    then extract
        (if IsCreditSwaption(ProductForEvent) or IsIRSwaption(ProductForEvent)
        then UnderlierForProduct(ProductForEvent)
        else ProductForEvent)
    then extract
        if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> index exists
                and UnderlierForProduct -> index -> productIdentifier -> source any = ProductIdTypeEnum -> Name
        then (UnderlierForProduct -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        // Commodities: only for ETDs
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists and IsSingleCommodityPayoutProduct = False)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if IsFRA
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName first
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
        then ([EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName first, EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexReferenceInformation -> indexName first] only-element)
            to-string
        as "2.16 Name of the underlying index"

reporting rule CustomBasketCode from TransactionReportInstruction: <"Custom basket code">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "17" field "Custom basket code"
        provision "If the derivative transaction is based on a custom basket, unique code assigned by the structurer of the custom basket to link its constituents."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract contractualProduct -> economicTerms -> payout
    then extract
        (if forwardPayout -> underlier -> basket exists
        then forwardPayout -> underlier -> basket -> productIdentifier -> identifier only-element
        else if optionPayout -> underlier -> basket exists
        then optionPayout -> underlier -> basket -> productIdentifier -> identifier only-element
        else if performancePayout -> underlier -> basket exists
        then performancePayout -> underlier -> basket -> productIdentifier -> identifier only-element
        else if optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        then optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId only-element
        else if creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        then creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId only-element)
        as "2.17 Custom basket code"

reporting rule IdentifierOfBasketConstituents from TransactionReportInstruction: <"Identifier of the basket's constituents">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "18" field "Basket's constituents"
        provision "Field 18 is repeatable and shall be populated in case there is a basket with constituents"]
    [regulatoryReference FCA UKEMIR Trade table "2b" field "18"
        provision "In case of custom baskets composed, among others, of financial instruments traded in a trading venue, only financial instruments traded in a trading venue shall be specified."]
    extract TradeForEvent
    then extract GetBasketConstituentsProductIdentifier
    then extract if source = ProductIdTypeEnum -> ISIN then identifier
        as "2.18 Identifier of the basket's constituents"

reporting rule SettlementCurrency1 from TransactionReportInstruction: <"Settlement Currency 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "19" field "Settlement currency 1"
        provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of the leg 1. This data element is not applicable for physically settled products (e.g. physically settled swaptions)."]
    [regulatoryReference ISDA PeerReviewGroup
        provision "In the case where settlement currency is not provided, model does not infer cash vs. physical settlement based on the product and then extract the notional currency as settlement currency. The conclusion at Peer Review was that firms should fill out the settlement currency field if it is reportable and DRR should not infer it from the notional."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract SettlementTermsLeg1
    then extract cde.settlement.SettlementCurrency
        as "2.19 Settlement Currency 1"

reporting rule SettlementCurrency2 from TransactionReportInstruction: <"Settlement Currency 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "20" field "Settlement currency 2"
        provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of the leg 2. This data element is not applicable for physically settled products (e.g. physically settled swaptions)."]
    [regulatoryReference ISDA PeerReviewGroup
        provision "In the case where settlement currency is not provided, model does not infer cash vs. physical settlement based on the product and then extract the notional currency as settlement currency. The conclusion at Peer Review was that firms should fill out the settlement currency field if it is reportable and DRR should not infer it from the notional."]
    [regulatoryReference ISDA EMEADataAndReporting date "20230417"
        provision "As per ESMA communication to ISDA by ESMA and Reviewed in ISDA Data and Reporting EMEA Working Group - Settlement Currency 2 will not be populated based on ESMA response to question raised by ISDA: your observation is correct, the settlement currency 2 would in principle be applicable in the case of physically settled FX derivatives. However, in line with CDE TG, the settlement currencies were considered not applicable for physically settled derivatives. This may require further discussion with the regulators regarding potential changes to the CDE TG. At this stage we agree that the field is not expected to be populated"]
    filter IsAllowableAction
    then empty
        as "2.20 Settlement Currency 2"

reporting rule ValuationAmount from TransactionReportInstruction: <"Valuation amount">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "21" field "Valuation amount"
        provision "Mark-to-market valuation of the contract, or mark-to-model valuation as referred to in Article 6 of these Technical Standards.The CCPs valuation to be used for a cleared trade."]
    filter
        (IsActionTypeNEWT or IsActionTypeVALU or IsActionTypeCORR or IsActionTypeREVI or IsActionTypePOSC)
    then cde.valuation.ValuationAmount
        as "2.21 Valuation amount"

reporting rule ValuationCurrency from TransactionReportInstruction: <"Valuation currency">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "22" field "Valuation currency"
        provision "Currency in which the valuation amount is denominated."]
    filter
        (IsActionTypeNEWT or IsActionTypeVALU or IsActionTypeCORR or IsActionTypeREVI or IsActionTypePOSC)
    then cde.valuation.ValuationCurrency
        as "2.22 Valuation currency"

reporting rule ValuationTimestamp from TransactionReportInstruction: <"Valuation Timestamp">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "23" field "Valuation timestamp"
        provision "Date and time of the last valuation marked to market, provided by the CCP or calculated using the current or last available market price of the inputs."]
    filter
        (IsActionTypeNEWT or IsActionTypeVALU or IsActionTypeCORR or IsActionTypeREVI or IsActionTypePOSC)
    then cde.valuation.ValuationTimestamp
        as "2.23 Valuation Timestamp"

reporting rule ValuationMethod from TransactionReportInstruction: <"Valuation method">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "24" field "Valuation method"
        provision "Source and method used for the valuation of the transaction by counterparty 1. If at least one valuation input is used that is classified as mark-to-model in the below table, then the whole valuation is classified as mark-to-model. If only inputs are used that are classified as mark-to-market in the table below, then the whole valuation is classified as mark-to-market."]
    filter
        (IsActionTypeNEWT or IsActionTypeVALU or IsActionTypeCORR or IsActionTypeREVI or IsActionTypePOSC)
    then extract cde.valuation.ValuationMethod(GetValuation)
        as "2.24 Valuation method"

reporting rule Delta from TransactionReportInstruction: <"Delta">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "25" field "Delta"
        provision "The ratio of the absolute change in price of a derivative transaction to the change in price of the underlier. This field is applicable only to options and swaptions. Updated delta shall be reported on a daily basis by financial counterparties and non-financial counterparties as referred to in Article 10 of Regulation (EU) No 648/2012."]
    filter
        (IsActionTypeNEWT or IsActionTypeVALU or IsActionTypeCORR or IsActionTypeREVI or IsActionTypePOSC)
    then extract cde.quantity.Delta
        as "2.25 Delta"

reporting rule CollateralPortfolioIndicator from TransactionReportInstruction: <"Collateral Portfolio Indicator">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "26" field "Collateral Portfolio Indicator"
        provision "Indicator of whether the collateralisation was performed on a portfolio basis. By 'on a portfolio basis', it is meant the set of transactions that are margined together (either on a net or a gross basis) contrary to the scenario where the margin is calculated and posted for each individual transaction separately."]
    filter IsAllowableAction
    then extract cde.collateral.CollateralPortfolioIndicator
        as "2.26 Collateral Portfolio Indicator"

reporting rule CollateralPortfolioCode from TransactionReportInstruction: <"Collateral Portfolio Code">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "27" field "Confirmation Portfolio Code"
        provision "If collateral is reported on a portfolio basis, unique code assigned by counterparty 1 to the portfolio. This data element is not applicable if the collateralisation was performed on a transaction level basis, or if there is no collateral agreement or if no collateral is posted or received."]
    filter IsAllowableAction
    then extract cde.collateral.CollateralPortfolioCode
        as "2.27 Collateral Portfolio Code"

reporting rule ConfirmationTimestamp from TransactionReportInstruction: <"Confirmation Timestamp">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "28" field "Confirmation Timestamp"
        provision "Date and time of the confirmation, as set out in Article 12 of Commission Delegated Regulation (EU) No 149/20132. Applicable only to OTC derivative contracts not cleared by a CCP."]
    extract
        if IsCleared(originatingWorkflowStep) = False
        then originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> confirmationDateTime
    then distinct only-element
    then extract dateTime
        as "2.28 Confirmation Timestamp"

reporting rule Confirmed from TransactionReportInstruction: <"Confirmed">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "29" field "Confirmed"
        provision "For new reportable transactions, whether the legally binding terms of an OTC derivatives contract were documented and agreed upon (confirmed) or not (unconfirmed). If documented and agreed, whether such confirmation was done: via a shared confirmation facility or platform, or a private/bilateral electronic system (electronic); via a human-readable written document, such as fax, paper or manually processed e-mails (non- electronic).Applicable only to OTC derivative contracts not cleared by a CCP."]
    filter IsAllowableAction
    then extract
        if IsCleared(originatingWorkflowStep) = False
                and IsRegulatedMarketOrThirdCountryEquivalentMarket(
                        reportableInformation,
                        RegimeNameEnum -> UKEMIR
                    ) = False // Not executed in a regulated market or 3rd country equivalent Market
        then cde.settlement.Confirmed
        as "2.29 Confirmed"

reporting rule ClearingObligation from TransactionReportInstruction: <"Clearing Obligation">
    [regulatoryReference FCA UKEMIR table "2" dataElement "30" field "Clearing obligation"
        provision "Indicates whether the reported contract belongs to a class of OTC derivatives that has been declared subject to the clearing obligation and both counterparties to the contract are subject to the clearing obligation under Regulation (EU) No 648/2012, as of the time of execution of the contract. Applicable only to OTC derivative contracts."]
    filter IsAllowableAction
    then extract
        if IsRegulatedMarketOrThirdCountryEquivalentMarket(
                    reportableInformation,
                    RegimeNameEnum -> UKEMIR
                ) = False // Not executed in a regulated market or 3rd country equivalent Market
        then (if IsCleared(originatingWorkflowStep)
            then "UKWN"
            else (reportableInformation -> partyInformation
                extract regimeInformation
                then flatten
                then filter supervisoryBody = SupervisoryBodyEnum -> FCA
                then filter regimeName = RegimeNameEnum -> UKEMIR
                then last
                then extract
                    if (mandatorilyClearable = MandatorilyClearableEnum -> ProductAndCptyMandatory)
                    then "TRUE"
                    else if (mandatorilyClearable = MandatorilyClearableEnum -> ProductMandatoryButNotCpty)
                    then "FLSE"
                    else if (mandatorilyClearable = MandatorilyClearableEnum -> ProductNotMandatory)
                    then "UKWN"))
        as "2.30 Clearing Obligation"

reporting rule Cleared from TransactionReportInstruction: <"Cleared">
    [regulatoryReference FCA UKEMIR table "2" dataElement "31" field "Cleared"
        provision "Indicator of whether the derivative has been cleared by a CCP."]
    filter IsAllowableAction
    then extract
        if IsCleared(originatingWorkflowStep) then "Y" else "N"
        as "2.31 Cleared"

reporting rule ClearingTimestamp from TransactionReportInstruction: <"Clearing Timestamp">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "32" field "Clearing Timestamp"
        provision "Time and date when clearing took place. Applicable only to derivatives cleared by a CCP."]
    filter IsAllowableAction
    then extract originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> clearingDateTime
    then only-element
    then extract dateTime
        as "2.32 Clearing Timestamp"

reporting rule CentralCounterparty from TransactionReportInstruction: <"Central Counterparty">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "33" field "Central counterparty"
        provision "Identifier of the CCP that cleared the transaction. This data element is not applicable if the value of the data element Cleared is N (No, not centrally cleared)."]
    filter IsAllowableAction
    then cde.settlement.CentralCounterparty
        as "2.33 Central Counterparty"

reporting rule MasterAgreementType from TransactionReportInstruction: <"Master Agreement type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "34" field "Master Agreement Type"
        provision "Reference to the master agreement type under which the counterparties concluded a derivative."]
    filter IsAllowableAction
    then extract
        (if TradeForEvent exists
        then TradeForEvent -> contractDetails
        else if PositionForEvent exists
        then PositionForEvent -> contractDetails)
    then extract documentation
    then filter
        legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum -> MasterAgreement
    then only-element
    then extract legalAgreementIdentification -> agreementName
    then extract
        if masterAgreementType = MasterAgreementTypeEnum -> ISDAMaster
        then "ISDA"
        else if masterAgreementType = MasterAgreementTypeEnum -> ISDAFIA_CDEA
        then "CDEA"
        else if masterAgreementType = MasterAgreementTypeEnum -> EMA
        then "EUMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> FBF
        then "FMAT"
        else if masterAgreementType = MasterAgreementTypeEnum -> German
        then "DERV"
        else if masterAgreementType = MasterAgreementTypeEnum -> CMOF
        then "CMOP"
        else if masterAgreementType = MasterAgreementTypeEnum -> Swiss
        then "CHMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> EFETElectricity
        then "EFMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> EFETGas
        then "EFMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> GMRA
        then "GMRA"
        else if masterAgreementType = MasterAgreementTypeEnum -> GMSLA
        then "GMSL"
        else if masterAgreementType = MasterAgreementTypeEnum -> Bespoke
        then "BIAG"
        else if masterAgreementType = MasterAgreementTypeEnum -> ISDAIIFM_TMA
        then "IDMA"
        else "OTHR"
        as "2.34 Master Agreement Type"

//      TO DO: check full list to confirm if others need code other than OTHR
reporting rule OtherMasterAgreementType from TransactionReportInstruction: <"Other master agreement type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "35" field "Other master agreement type"
        provision "Name of the master agreement. This field shall only be completed where OTHR is reported in field 2.34 of this table."]
    filter IsAllowableAction
    then extract
        (if TradeForEvent exists
        then TradeForEvent -> contractDetails
        else if PositionForEvent exists
        then PositionForEvent -> contractDetails)
    then extract documentation
    then filter
        legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum -> MasterAgreement
    then only-element
    then extract legalAgreementIdentification -> agreementName
    then extract
        if masterAgreementType = MasterAgreementTypeEnum -> AFB
        then "AFBMAForFXAndDerivativesTransactions"
        else if masterAgreementType = MasterAgreementTypeEnum -> CMA
        then "ClearingMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> IFEMA
        then "InternationalForeignExchangeMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> IFEOMA
        then "InternationalForeignExchangeAndOptionsMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> ICOM
        then "InternationalCurrencyOptionsMarketMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> JSCC
        then "MasterAgreementOfJapanSecuritiesClearingCorp"
        else if masterAgreementType = MasterAgreementTypeEnum -> EEIPower
        then "EEIMasterPowerPurchaseAndSaleAgreement"
        else if masterAgreementType = MasterAgreementTypeEnum -> GTMA
        then "FOAGridTradeMasterAgreement"
        else if masterAgreementType = MasterAgreementTypeEnum -> GasEDI
        then "GasEDIBaseCntrctShortTermSaleAndPurNatGas"
        else if masterAgreementType = MasterAgreementTypeEnum -> IETA_ERPA
        then "IntlEmissionTAEmissionReductionPurchaseAgrmt"
        else if masterAgreementType = MasterAgreementTypeEnum -> IETA_ETMA
        then "IntlEmissionsTradingAssocEmissionsTradingMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> IETA_IETMA
        then "IntlEmissionsTradingAssocAndTradingMA"
        else if masterAgreementType = MasterAgreementTypeEnum -> LBMA
        then "IntlBullionMATermsByTheLdnBullionMktAssoc"
        else if masterAgreementType = MasterAgreementTypeEnum -> LEAP
        then "LeadershipInEnergyAutomatedProcessing"
        else if masterAgreementType = MasterAgreementTypeEnum -> MCPSA
        then "CTAMasterCoalPurchaseAndSalesAgreement"
        else if masterAgreementType = MasterAgreementTypeEnum -> NAESBGas
        then "NAESBBaseContractSaleAndPurchaseOfNaturalGas"
        else if masterAgreementType = MasterAgreementTypeEnum -> NBP
        then "ShortTermFlatNBPTradingTermsAndConditions"
        else if masterAgreementType = MasterAgreementTypeEnum -> RussianDerivatives
        then "StdDocForDerivTxnsOnTheRussianFinMarkets"
        else if masterAgreementType = MasterAgreementTypeEnum -> RussianRepo
        then "MAForRepurchaseAgreementOnTheRussianFinMkt"
        else if masterAgreementType = MasterAgreementTypeEnum -> SCoTA
        then "globalCOALStandardCoalTradingAgreement"
        else if masterAgreementType = MasterAgreementTypeEnum -> TTF
        then "TTFHubNaturalGasTradingTermsAndConditions"
        else if masterAgreementType = MasterAgreementTypeEnum -> ZBT
        then "ZeebruggeHubNaturalGasTradingTandC"
        else otherAgreement
        as "2.35 Other Master Agreement Type"

reporting rule MasterAgreementVersion from TransactionReportInstruction: <"Master Agreement version">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "36" field "Master Agreement version"
        provision "Reference to the year of the master agreement relevant to the reported trade, if applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract contractDetails -> documentation
    then filter
        legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum -> MasterAgreement
    then only-element
    then extract legalAgreementIdentification -> vintage
        as "2.36 Master Agreement version"

reporting rule Intragroup from TransactionReportInstruction: <"Intragroup">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "37" field "Intragroup"
        provision "Indicates whether the contract was entered into as an intragroup transaction, defined in Article 3 of Regulation (EU) No 648/2012, except that, for the contract to be characterised as an intragroup transaction for the purposes of this reporting field, the references to counterparties established in a third-country jurisdiction in Articles 3(1), 3(2)(a)(i) and 3(2)(d) respectively apply to counterparties established in any third country jurisdiction, not only jurisdictions for which: (a) the Commission has adopted an implementing act as referred to in Article 13(2) in respect of that third country before IP completion day, or (b) the Treasury have made regulations under that Article in respect of that third country after IP completion day. This does not affect the meaning of the term intragroup transaction as used elsewhere in Regulation (EU) No 648/2012 or related legislation."]
    filter IsAllowableAction
    then extract
        if IsRegulatedMarketOrThirdCountryEquivalentMarket(
                    reportableInformation,
                    RegimeNameEnum -> UKEMIR
                ) = False // Not executed in a regulated market or 3rd country equivalent Market
        then reportableInformation -> intragroup
        as "2.37 Intragroup"

reporting rule PTRR from TransactionReportInstruction: <"PTRR">
    [regulatoryReference FCA UKEMIR table "2" dataElement "38" field "PTRR"
        provision "Identify whether the contract results from a PTRR operation."]
    [regulatoryReference ISDA PeerReviewGroup date "20230823"
        provision "Portfolio rebalancing scenarios are not yet addressed in PTRR fields, only compression scenarios are addressed."]
    filter IsAllowableAction
    then extract
        IsCompressed(originatingWorkflowStep)
            or IsPortfolioRebalancing(originatingWorkflowStep)
        as "2.38 PTRR"

reporting rule TypeOfPTRRTechnique from TransactionReportInstruction: <"Type of PTRR technique">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "39" field "Type of PTRR technique"
        provision "Indicator of a type of a PTRR operation for the purpose of reporting under EMIR. Portfolio Compression without a third-party service provider: An arrangement to reduce risk in existing portfolios of trades using non-price forming trades mainly to reduce notional amount outstanding, the number of transactions or otherwise harmonise the terms, by wholly or partially terminating trades and commonly to replace the terminated derivatives with new replacement trades. Portfolio Compression with a third-party service provider or CCP: A PTRR service provided by a service provider or CCP to reduce risk in existing portfolios of trades using non-price forming trades mainly to reduce notional amount outstanding, the number of transactions or otherwise harmonise the terms, by wholly or partially terminating trades and commonly to replace the terminated derivatives with new replacement trades. Portfolio Rebalancing/Margin management: A PTRR service provided by a service provider to reduce risk in an existing portfolio of trades by adding new non-price forming trades and where no existing trades in the portfolio are terminated or replaced and the notional is increased rather than decreased. Other Portfolio PTTR services: A PTRR service provided by a service provider to reduce risk in existing portfolios of trades using non-price forming trades and where such service does not qualify as Portfolio Compression or Portfolio Rebalancing."]
    [regulatoryReference ISDA PeerReviewGroup date "20230823"
        provision "Portfolio rebalancing scenarios are not yet addressed in PTRR fields, only compression scenarios are addressed."]
    filter IsAllowableAction or IsActionTypeTERM
    then extract
        if IsCompressed(originatingWorkflowStep)
        then (if originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction -> execution -> partyRoles -> role any = PartyRoleEnum -> PTRRServiceProvider
            then "PWAS"
            else "PWOS")
        else if IsPortfolioRebalancing(originatingWorkflowStep)
        then "PRBM"
        as "2.39 Type of PTRR technique"

reporting rule PTRRServiceProvider from TransactionReportInstruction: <"PTRR service provider">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "40" field "PTRR service provider"
        provision "LEI identifying the PTRR service provider."]
    [regulatoryReference ISDA PeerReviewGroup date "20230823"
        provision "Portfolio rebalancing scenarios are not yet addressed in PTRR fields, only compression scenarios are addressed."]
    filter IsAllowableAction or IsActionTypeTERM
    then extract
        if IsCompressed(originatingWorkflowStep)
                or IsPortfolioRebalancing(originatingWorkflowStep)
        then FilterPartyRole(
                originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction -> execution -> partyRoles,
                PartyRoleEnum -> PTRRServiceProvider
            ) -> partyReference
            distinct
            only-element
    then extract PartyLei(partyId)
        as "2.40 PTRR service provider"

reporting rule VenueOfExecution from TransactionReportInstruction: <"Venue of Execution">
    [regulatoryReference FCA UKEMIR table "2" dataElement "41" field "Venue of Execution"
        provision "Identification of the venue where the transaction was executed. Use the ISO 10383 segment MIC for transactions executed on a trading venue, Systematic Internaliser (SI) or organised trading platform outside of the UK. Where the segment MIC does not exist, use the operating MIC. Use MIC code XOFF for financial instruments admitted to trading, or traded on a trading venue or for which a request for admission was made, where the transaction on that financial instrument is not executed on a trading venue, SI or organised trading platform outside of the UK, or where a counterparty does not know it is trading with a counterparty 2 acting as an SI. Use MIC code XXXX for financial instruments that are not admitted to trading or traded on a trading venue or for which no request for admission has been made and that are not traded on an organised trading platform outside of the UK."]
    filter IsAllowableAction
    then extract reportableEvent [
        if UKEMIRIsMicXOFF
        then "XOFF"
        else if UKEMIRIsMicXXXX
        then "XXXX"
        else (GetVenueOfExecution(reportableInformation)
            then extract
                GetOrFetchMicData(
                        reportableEvent -> reportableInformation -> enrichment -> micData,
                        item
                    )
            then extract
                if (status = "EXPIRED" and expiryDate <= GetExecutionTimestamp(reportableEvent) -> date)
                        or status <> "EXPIRED"
                then if micType = MicTypeEnum -> SGMT
                    then mic
                    else operatingMic)
    ]
        as "2.41 Venue of Execution"

reporting rule ExecutionTimestamp from TransactionReportInstruction: <"Execution Timestamp">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "42" field "Execution Timestamp"
        provision "Date and time a transaction was originally executed, resulting in the generation of a new UTI. This data element remains unchanged throughout the life of the UTI. For position level reporting it should refer to the time when position was opened for the first time."]
    filter IsAllowableAction
    then cde.datetime.ExecutionTimestamp
        as "2.42 Execution Timestamp"

reporting rule EffectiveDate from TransactionReportInstruction: <"Effective Date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "43" field "Effective Date"
        provision "Unadjusted date at which obligations under the OTC derivative transaction come into effect, as included in the confirmation. If the effective date is not specified as part of the terms of the contract, the counterparties shall report in this field the date of execution of the derivative."]
    [regulatoryReference ISDA EMIRReportingBestPractice table "2" field "26"
        provision "Where an Effective Date is specified in the terms of the contract, report that date (i.e. the effective date represented on the confirmation). If an effective date is not specified in the terms of the contract, report the execution date (see best practice for Execution Timestamp)."]
    filter IsAllowableAction
    then extract
        if Qualify_InterestRate_Fra(ProductForEvent -> contractualProduct -> economicTerms)
        then (if TradeForEvent exists
            then TradeForEvent -> tradeDate
            else if PositionForEvent exists
            then PositionForEvent -> openDateTime -> date)
        else cde.datetime.EffectiveDate
        as "2.43 Effective Date"

reporting rule ExpirationDate from TransactionReportInstruction: <"Expiration Date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "44" field "Expiration Date"
        provision "Unadjusted date at which obligations under the derivative transaction stop being effective, as included in the confirmation. Early termination does not affect this data element."]
    filter IsAllowableAction
    then extract GetExpirationDate
        as "2.44 Expiration Date"

reporting rule EarlyTerminationDate from TransactionReportInstruction: <"Early termination date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "45" field "Early termination date"
        provision "Effective date of the early termination (expiry) of the reported transaction. This data element is applicable if the termination of the transaction occurs prior to its maturity due to an ex- interim decision of a counterparty (or counterparties)."]
    filter (IsActionTypeCORR or IsActionTypeTERM or IsActionTypeREVI)
    then extract
        (if originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                and IsProductETD(ProductForEvent)
                and (originatingWorkflowStep -> counterpartyPositionBusinessEvent -> intent = PositionEventIntentEnum -> CorporateActionAdjustment
                    or originatingWorkflowStep -> counterpartyPositionBusinessEvent -> intent = PositionEventIntentEnum -> Transfer)
                and reportablePosition -> counterpartyPosition -> positionBase -> tradeLot -> priceQuantity -> quantity -> value all = 0
        then originatingWorkflowStep -> counterpartyPositionBusinessEvent -> effectiveDate
        else cde.datetime.EarlyTerminationDate)
        as "2.45 Early termination date"

reporting rule FinalContractualSettlementDate from TransactionReportInstruction: <"Final Contractual Settlement Date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "46" field "Final contractual settlement date"
        provision "Unadjusted date as per the contract, by which all transfer of cash or assets should take place and the counterparties should no longer have any outstanding obligations to each other under that contract. For products that may not have a final contractual settlement date (e.g. American options), this data element reflects the date by which the transfer of cash or asset would take place if termination were to occur on the expiration date."]
    filter IsAllowableAction
    then extract
        if IsFRA(ProductForEvent)
        then InterestRateLeg2(ProductForEvent) -> paymentDate -> unadjustedDate
        else cde.settlement.FinalContractualSettlementDate
        as "2.46 Final Contractual Settlement Date"

reporting rule DeliveryType from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "47" field "Delivery type"
        provision "Indicates whether the contract is settled physically or in cash."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract DeliveryTypeForProducts
        as "2.47 Delivery Type"

// ToDo Note also we don't have Bond Forward, Equity Forward examples yet.
// ToDo - Credit Options are inconsistent & use settlementType - awaiting clarification on harmonisation potential before coding (and in any case, no DRR examples yet!)
// ToDo Commodities also likely to have other nuances?
//TODO: Add Equity Swap Samples to test this part of the code
/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule PriceFormatMonetary from TransactionReportInstruction: <"Price formatted as Monetary.">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "48" field "Price"
        provision "Price specified in the derivative transaction. It does not include fees, taxes or commissions. Where the price is not known when a new transaction is reported, the price is updated as it becomes available. For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference FCA UKEMIR section "4.4.7" paragraph "391"
        provision "ESMA proposed in the Consultation Paper certain amendments to the mechanics in which the price of a derivative contract is reported. In particular, ESMA proposed to	change the fields and their definitions to better align with the CDE guidance and clarified	that the field Price should only be populated when the information is not provided in another field (e.g. Fixed rate)."]
    filter IsAllowableAction
    then extract
        if cde.price.PriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.Price, PriceNotationEnum -> Monetary)
        as "2.48 Price (Monetary)"

reporting rule PriceFormatPercentage from TransactionReportInstruction: <"Price formatted as Percentage.">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "48" field "Price"
        provision "Price specified in the derivative transaction. It does not include fees, taxes or commissions. Where the price is not known when a new transaction is reported, the price is updated as it becomes available. For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference FCA UKEMIR section "4.4.7" paragraph "391"
        provision "ESMA proposed in the Consultation Paper certain amendments to the mechanics in which the price of a derivative contract is reported. In particular, ESMA proposed to	change the fields and their definitions to better align with the CDE guidance and clarified	that the field Price should only be populated when the information is not provided in another field (e.g. Fixed rate)."]
    filter IsAllowableAction
    then extract
        if cde.price.PriceNotationEnum = PriceNotationEnum -> Percentage
        then MultiplyPrice(cde.price.Price, PriceNotationEnum -> Percentage)
        as "2.48 Price (Percentage)"

reporting rule PriceFormatBasis from TransactionReportInstruction: <"Price formatted as Basis.">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "48" field "Price"
        provision "Price specified in the derivative transaction. It does not include fees, taxes or commissions. Where the price is not known when a new transaction is reported, the price is updated as it becomes available. For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    [regulatoryReference FCA UKEMIR section "4.4.7" paragraph "391"
        provision "ESMA proposed in the Consultation Paper certain amendments to the mechanics in which the price of a derivative contract is reported. In particular, ESMA proposed to	change the fields and their definitions to better align with the CDE guidance and clarified	that the field Price should only be populated when the information is not provided in another field (e.g. Fixed rate)."]
    filter IsAllowableAction
    then extract
        if cde.price.PriceNotationEnum = PriceNotationEnum -> Basis
        then MultiplyPrice(cde.price.Price, PriceNotationEnum -> Basis)
        as "2.48 Price (Basis)"

reporting rule PriceNotation from TransactionReportInstruction: <"Price Notation">
    filter IsAllowableAction
    then extract cde.price.PriceNotationEnum
        as "2.48 Price Notation (Non Reportable)"

/*------------------------------------------------------------------------------------ */
reporting rule PriceCurrency from TransactionReportInstruction: <"Price Currency">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "49" field "Price currency"
        provision "Currency in which the price is denominated. Price currency is only applicable if price is expressed as monetary value."]
    filter IsAllowableAction
    then extract cde.price.PriceCurrency
    then extract ConvertNonISOToISOCurrency
        as "2.49 Price Currency"

reporting rule ContractPriceSchedule from TransactionReportInstruction: <"Contract Price Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "50-52" field "Contract Price Schedule"
        provision "Fields 50-52 are repeatable and shall be populated in the case of derivatives involving price schedules"]
    filter IsAllowableAction
    then extract UKEMIRReportablePricePeriod
    then extract
        PriceScheduleReport {
            effectiveDate: UnadjustedEffectiveDateOfThePrice,
            endDate: UnadjustedEndDateOfThePrice,
            priceMonetary: PriceInEffectBetweenTheUnadjustedEffectiveAndEndDateFormatMonetary,
            pricePercentage: PriceInEffectBetweenTheUnadjustedEffectiveAndEndDatePercentage
        }

func UKEMIRReportablePricePeriod:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirReportablePricePeriods PriceReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericReportablePriceSchedule:
        GetReportablePricePeriod(transactionReportInstruction)
    set emirReportablePricePeriods:
        Create_ContinuousPriceSchedule(genericReportablePriceSchedule, expirationDate)

reporting rule UnadjustedEffectiveDateOfThePrice from PriceReportablePeriod: <"Unadjusted effective date of the price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "50" field "Unadjusted effective date of the price"
        provision "Unadjusted effective date of the price."]
    cde.price.PriceScheduleEffectiveDate
        as "2.50/2.52-$ 2.50 Unadjusted effective date of the price"

reporting rule UnadjustedEndDateOfThePrice from PriceReportablePeriod: <"Unadjusted end date of the price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "51" field "Unadjusted end date of the price"
        provision "Unadjusted end date of the price (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    cde.price.PriceScheduleEndDate
        as "2.50/2.52-$ 2.51 Unadjusted end date of the price"

reporting rule PriceInEffectBetweenTheUnadjustedEffectiveAndEndDateFormatMonetary from PriceReportablePeriod: <"Price in effect between the unadjusted effective and end date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "52" field "Price in effect between the unadjusted effective and end date"
        provision "Price in effect between the unadjusted effective date and inclusive of the unadjusted end date."]
    cde.price.PriceScheduleAmountFormatMonetary
        as "2.50/2.52-$ 2.52 Price in effect between the unadjusted effective and end date (Monetary)"

reporting rule PriceInEffectBetweenTheUnadjustedEffectiveAndEndDatePercentage from PriceReportablePeriod: <"Price in effect between the unadjusted effective and end date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "52" field "Price in effect between the unadjusted effective and end date"
        provision "Price in effect between the unadjusted effective date and inclusive of the unadjusted end date."]
    cde.price.PriceScheduleAmountFormatPercentage
        as "2.50/2.52-$ 2.52 Price in effect between the unadjusted effective and end date (Percentage)"

reporting rule PackageTransactionPriceMonetary from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "53" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component.This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.PackageTransactionPrice, PriceNotationEnum -> Monetary)
        as "2.53 Package Transaction Price (Monetary)"

reporting rule PackageTransactionPricePercentage from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "53" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component.This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Percentage
        then MultiplyPrice(
                    cde.price.PackageTransactionPrice,
                    PriceNotationEnum -> Percentage
                )
        as "2.53 Package Transaction Price (Percentage)"

reporting rule PackageTransactionPriceBasis from TransactionReportInstruction: <"Package Transaction Price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "53" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component.This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract
        if cde.price.PackageTransactionPriceNotationEnum = PriceNotationEnum -> Basis
        then MultiplyPrice(cde.price.PackageTransactionPrice, PriceNotationEnum -> Basis)
        as "2.53 Package Transaction Price (Basis)"

reporting rule PackageTransactionPriceNotation from TransactionReportInstruction: <"Package Transaction Price Notation">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "53" field "Package transaction price"
        provision "Traded price of the entire package in which the reported derivative transaction is a component.This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (Price currency) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract cde.price.PackageTransactionPriceNotationEnum
        as "2.53 Package Transaction Price Notation"

reporting rule PackageTransactionPriceCurrency from TransactionReportInstruction: <"Package Transaction Price Currency">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "54" field "Package transaction price currency"
        provision "Currency in which the Package transaction price is denominated. This data element is not applicable if no package is involved, or package transaction spread is used, or package transaction price is expressed as percentage."]
    filter IsAllowableAction
    then extract cde.price.PackageTransactionPriceCurrency
        as "2.54 Package Transaction Price Currency"

reporting rule NotionalAmountOfLeg1 from TransactionReportInstruction: <"Notional of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "55" field "Notional amount of leg 1"
        provision "Notional amount of leg 1 as referred to in Article 7 of the FCA's Technical Standards."]
    [regulatoryReference FCA UKEMIR article "5" paragraph "2"
        provision "The initial report of a derivative contract whose notional amount varies over time shall specify the notional amount as applicable at the date of conclusion of the derivative contract and the notional amount schedule. When reporting the notional amount schedule, counterparties shall indicate: (i) the unadjusted date on which the associated notional amount becomes effective; (ii) the unadjusted end date of the notional amount; and (iii) the notional amount which becomes effective on the associated unadjusted effective date."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent -> tradableProduct
        else TradableProductForEvent
            then extract
                PayoutLeg1(
                        item -> product,
                        item -> tradeLot only-element,
                        reportableEvent -> reportableInformation
                    )
            then extract
                (if Notional -> value = 0 and IsFXProduct(ProductForEvent(reportableEvent))
                then 9999999999999999999999999
                else Notional -> value)
    ]
    then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.55 Notional Amount 1"

reporting rule NotionalCurrency1 from TransactionReportInstruction: <"Notional currency 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "56" field "Notional currency 1"
        provision "Where applicable: the currency in which the notional amount of leg 1 is denominated."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent -> tradableProduct
        else TradableProductForEvent
            then extract
                PayoutLeg1(
                        item -> product,
                        item -> tradeLot only-element,
                        reportableEvent -> reportableInformation
                    )
            then extract Notional -> unit -> currency
    ]
    then extract ConvertNonISOToISOCurrency
        as "2.56 Notional Currency 1"

reporting rule NotionalAmountScheduleLeg1 from TransactionReportInstruction: <"Notional Amount Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "57-59" field "Notional Amount Schedule"
        provision "Fields 57-59 are repeatable and shall be populated in the case of derivatives involving notional amount schedules"]
    filter IsAllowableAction
    then extract UKEMIRNotionalAmountPeriodLeg1
    then extract
        NotionalAmountScheduleLeg1Report {
            amount: NotionalAmountInEffectOnAssociatedEffectiveDateOfLeg1,
            effectiveDate: EffectiveDateOfTheNotionalAmountOfLeg1,
            endDate: EndDateOfTheNotionalAmountOfLeg1
        }

func UKEMIRNotionalAmountPeriodLeg1:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirNotionalAmountPeriods QuantityReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericNotionalAmountSchedule:
        GetLeg1ResolvablePriceQuantity(TradeForEvent(transactionReportInstruction)) -> quantitySchedule
            then filter unit -> currency exists
            then extract datedValue
            then extract notionalAmountPeriod [
                // use value and dates from quantity period
                QuantityReportablePeriod {
                    periodValue: notionalAmountPeriod -> value,
                    periodEffectiveDate: notionalAmountPeriod -> date,
                    periodEndDate: empty
                }
            ]
    set emirNotionalAmountPeriods:
        Create_ContinuousQuantitySchedule(genericNotionalAmountSchedule, expirationDate)

reporting rule EffectiveDateOfTheNotionalAmountOfLeg1 from QuantityReportablePeriod: <"Effective date of the notional amount of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "57" field "Effective date of the notional amount of leg 1"
        provision "Unadjusted date on which the associated notional amount of leg 1 becomes effective."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "2.57/2.59-$ 2.57 Effective date of the notional amount of leg 1"

reporting rule EndDateOfTheNotionalAmountOfLeg1 from QuantityReportablePeriod: <"End date of the notional amount of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "58" field "End date of the notional amount of leg 1"
        provision "Unadjusted end date of the notional amount of leg 1(not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20231128"
        provision "This field remained unmodelled as WG believe that ESMA's update on 23rd September regarding the new conditionality for schedule date fields is incorrect."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "2.57/2.59-$ 2.58 End date of the notional amount of leg 1"

reporting rule NotionalAmountInEffectOnAssociatedEffectiveDateOfLeg1 from QuantityReportablePeriod: <"Notional amount in effect on associated effective date of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "59" field "Notional amount in effect on associated effective date of leg 1"
        provision "Notional amount of leg 1 which becomes effective on the associated unadjusted effective date."]
    cde.quantity.NotionalAmountScheduleAmount
        as "2.57/2.59-$ 2.59 Notional amount in effect on associated effective date of leg 1"

reporting rule TotalNotionalQuantityOfLeg1 from TransactionReportInstruction: <"Total Notional Quantity Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "60" field "Total notional quantity of leg 1"
        provision "Aggregate Notional quantity of the underlying asset of leg 1 for the term of the transaction. Where the total notional quantity is not known when a new transaction is reported, the total notional quantity is updated as it becomes available."]
    // todo: add coverage for equity swaps
    filter IsAllowableAction
    then extract TradableProductForEvent
    then extract
        if IsEquity(product) or IsEquityForward(product)
        then cde.quantity.EquityTotalNotionalQuantity
        else if IsCommoditySwapFloatFloat(product)
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg1(product))
        else if IsSingleCommodityPayoutProduct(product)
        then cde.quantity.CommodityTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> commodityPayout only-element
                )
        else if IsCommodityFloatingPriceForward(product)
        then cde.quantity.CommodityTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> commodityPayout only-element
                )
        else if IsCommoditySwapFixedFloat(product)
        then cde.quantity.FixedPriceTotalNotionalQuantity(FixedPriceLeg1(product))
        else if IsCommodityFixedPriceForward(product)
        then cde.quantity.FixedPriceTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element
                )
        else if IsSingleCommodityPayoutProduct(product)
        then cde.quantity.CommodityTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> commodityPayout only-element
                )
        else if IsCommodityFloatingPriceForward(product)
        then cde.quantity.CommodityTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> commodityPayout only-element
                )
        else if IsCommodityFixedPriceForward(product)
        then cde.quantity.FixedPriceTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element
                )
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
        then cde.quantity.CommodityTotalNotionalQuantity(
                    CommodityLeg1(UnderlierForProduct(product))
                )
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
        then cde.quantity.FixedPriceTotalNotionalQuantity(
                    FixedPriceLeg1(UnderlierForProduct(product))
                )
        else if Qualify_Commodity_Option(EconomicTermsForProduct(product))
        then cde.quantity.OptionTotalNotionalQuantity(
                    EconomicTermsForProduct(product) -> payout -> optionPayout only-element
                )
        // ETDs -- Not in CDE because not covered by CDE specifications
        else if IsProductETD(product) // todo: support multipliers
        then (tradeLot only-element -> priceQuantity -> quantity
            filter unit -> financialUnit exists
            then extract value
            then only-element)
    then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.60 Total notional quantity-Leg 1"

reporting rule NotionalQuantityScheduleLeg1 from TransactionReportInstruction: <"Notional Quantity Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "61-63" field "Notional Quantity Schedule"
        provision "Fields 61-63 are repeatable and shall be populated in the case of derivatives involving notional quantity schedules"]
    filter IsAllowableAction
    then extract UKEMIRReportableQuantityPeriodLeg1
    then extract
        NotionalQuantityScheduleLeg1Report {
            value: NotionalQuantityInEffectOnAssociatedEffectiveDateOfLeg1,
            effectiveDate: EffectiveDateOfTheNotionalQuantityOfLeg1,
            endDate: EndDateOfTheNotionalQuantityOfLeg1
        }

func UKEMIRReportableQuantityPeriodLeg1:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirReportableQuantityPeriods QuantityReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericReportableQuantitySchedule:
        GetReportableQuantityPeriodLeg1(TradeForEvent(transactionReportInstruction))
    set emirReportableQuantityPeriods:
        Create_ContinuousQuantitySchedule(genericReportableQuantitySchedule, expirationDate)

reporting rule EffectiveDateOfTheNotionalQuantityOfLeg1 from QuantityReportablePeriod: <"Effective date of the notional quantity of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "61" field "Effective date of the notional quantity of leg 1"
        provision "Unadjusted date on which the associated notional quantity of leg 1 becomes effective."]
    cde.quantity.NotionalQuantityScheduleEffectiveDate
        as "2.61/2.63-$ 2.61 Effective date of the notional quantity of leg 1"

reporting rule EndDateOfTheNotionalQuantityOfLeg1 from QuantityReportablePeriod: <"End date of the notional quantity of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "62" field "End date of the notional quantity of leg 1"
        provision "Unadjusted end date of the notional quantity of leg 1 (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    cde.quantity.NotionalQuantityScheduleEndDate
        as "2.61/2.63-$ 2.62 End date of the notional quantity of leg 1"

reporting rule NotionalQuantityInEffectOnAssociatedEffectiveDateOfLeg1 from QuantityReportablePeriod: <"Notional quantity in effect on associated effective date of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "63" field "Notional quantity in effect on associated effective date of leg 1"
        provision "Notional quantity of leg 1 which becomes effective on the associated unadjusted effective date."]
    cde.quantity.NotionalQuantityScheduleValue
        then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.61/2.63-$ 2.63 Notional quantity in effect on associated effective date of leg 1"

reporting rule NotionalAmountOfLeg2 from TransactionReportInstruction: <"Notional Amount of Leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2g" dataElement "64" field "Notional amount of leg 2"
        provision "Where applicable, notional amount of leg 2 as referred to in Article 7 of the FCA's Technical Standards. "]
    [regulatoryReference FCA UKEMIR article "5" paragraph "2"
        provision "The initial report of a derivative contract whose notional amount varies over time shall specify the notional amount as applicable at the date of conclusion of the derivative contract and the notional amount schedule. When reporting the notional amount schedule, counterparties shall indicate: (i) the unadjusted date on which the associated notional amount becomes effective; (ii) the unadjusted end date of the notional amount; and (iii) the notional amount which becomes effective on the associated unadjusted effective date."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent -> tradableProduct
        else TradableProductForEvent
            then extract
                PayoutLeg2(
                        item -> product,
                        item -> tradeLot only-element,
                        reportableEvent -> reportableInformation
                    )
            then extract
                (if Notional -> value = 0 and IsFXProduct(ProductForEvent(reportableEvent))
                then 9999999999999999999999999
                else Notional -> value)
    ]
    then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.64 Notional Amount 2"

reporting rule NotionalCurrency2 from TransactionReportInstruction: <"Notional currency 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "65" field "Notional currency 2"
        provision "Where applicable: the currency in which the notional amount of leg 2 is denominated. "]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent -> tradableProduct
        else TradableProductForEvent
            then extract
                PayoutLeg2(
                        item -> product,
                        item -> tradeLot only-element,
                        reportableEvent -> reportableInformation
                    )
            then extract Notional -> unit -> currency
    ]
    then extract ConvertNonISOToISOCurrency
        as "2.65 Notional Currency 2"

reporting rule NotionalAmountScheduleLeg2 from TransactionReportInstruction: <"Notional Amount Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "66-68" field "Notional Amount Schedule"
        provision "Fields 66-68 are repeatable and shall be populated in the case of derivatives involving notional amount schedules"]
    filter IsAllowableAction
    then extract UKEMIRNotionalAmountPeriodLeg2
    then extract
        NotionalAmountScheduleLeg2Report {
            amount: NotionalAmountInEffectOnAssociatedEffectiveDateOfLeg2,
            effectiveDate: EffectiveDateOfTheNotionalAmountOfLeg2,
            endDate: EndDateOfTheNotionalAmountOfLeg2
        }

func UKEMIRNotionalAmountPeriodLeg2:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirNotionalAmountPeriods QuantityReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericNotionalAmountSchedule:
        GetLeg2ResolvablePriceQuantity(TradeForEvent(transactionReportInstruction)) -> quantitySchedule
            then filter unit -> currency exists
            then extract datedValue
            then extract notionalAmountPeriod [
                // use value and dates from quantity period
                QuantityReportablePeriod {
                    periodValue: notionalAmountPeriod -> value,
                    periodEffectiveDate: notionalAmountPeriod -> date,
                    periodEndDate: empty
                }
            ]
    set emirNotionalAmountPeriods:
        Create_ContinuousQuantitySchedule(genericNotionalAmountSchedule, expirationDate)

reporting rule EffectiveDateOfTheNotionalAmountOfLeg2 from QuantityReportablePeriod: <"Effective date of the notional amount of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "66" field "Effective date of the notional amount of leg 2"
        provision "Unadjusted date on which the associated notional amount of leg 2 becomes effective."]
    cde.quantity.NotionalAmountScheduleEffectiveDate
        as "2.66/2.68-$ 2.66 Effective date of the notional amount of leg 2"

reporting rule EndDateOfTheNotionalAmountOfLeg2 from QuantityReportablePeriod: <"End date of the notional amount of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "67" field "End date of the notional amount of leg 2"
        provision "Unadjusted end date of the notional amount of leg 2 (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20231128"
        provision "This field remained unmodelled as WG believe that ESMA's update on 23rd September regarding the new conditionality for schedule date fields is incorrect."]
    cde.quantity.NotionalAmountScheduleEndDate
        as "2.66/2.68-$ 2.67 End date of the notional amount of leg 2"

reporting rule NotionalAmountInEffectOnAssociatedEffectiveDateOfLeg2 from QuantityReportablePeriod: <"Notional amount in effect on associated effective date of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "68" field "Notional amount in effect on associated effective date of leg 2"
        provision "Notional amount of leg 2 which becomes effective on the associated unadjusted effective date."]
    cde.quantity.NotionalAmountScheduleAmount
        as "2.66/2.68-$ 2.68 Notional amount in effect on associated effective date of leg 2"

reporting rule TotalNotionalQuantityOfLeg2 from TransactionReportInstruction: <"Total Notional Quantity Leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "69" field "Total notional quantity of leg 2"
        provision "Aggregate Notional quantity of the underlying asset of leg 2 for the term of the transaction. Where the total notional quantity is not known when a new transaction is reported, the total notional quantity is updated as it becomes available."]
    // todo: add coverage for equity swaps
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsCommoditySwap
        then cde.quantity.CommodityTotalNotionalQuantity(CommodityLeg2)
        else if IsCommodityForward
        then (if EconomicTermsForProduct -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> value exists
            then EconomicTermsForProduct -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> value
            else if EconomicTermsForProduct -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> datedValue exists
            then EconomicTermsForProduct -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> datedValue -> value sum)
        else if IsEquity and InterestRateLeg2 -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then (InterestRateLeg2 -> priceQuantity -> quantitySchedule
            then extract
                if multiplier exists
                then value * multiplier -> value
                else value)
        as "2.69 Total notional quantity-Leg 2"

reporting rule NotionalQuantityScheduleLeg2 from TransactionReportInstruction: <"Notional Quantity Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "70-72" field "Notional Quantity Schedule"
        provision "Fields 70-72 are repeatable and shall be populated in the case of derivatives involving notional quantity schedules"]
    filter IsAllowableAction
    then extract UKEMIRReportableQuantityPeriodLeg2
    then extract
        NotionalQuantityScheduleLeg2Report {
            value: NotionalQuantityInEffectOnAssociatedEffectiveDateOfLeg2,
            effectiveDate: EffectiveDateOfTheNotionalQuantityOfLeg2,
            endDate: EndDateOfTheNotionalQuantityOfLeg2
        }

func UKEMIRReportableQuantityPeriodLeg2:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirReportableQuantityPeriods QuantityReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericReportableQuantitySchedule:
        GetReportableQuantityPeriodLeg2(TradeForEvent(transactionReportInstruction))
    set emirReportableQuantityPeriods:
        Create_ContinuousQuantitySchedule(genericReportableQuantitySchedule, expirationDate)

reporting rule EffectiveDateOfTheNotionalQuantityOfLeg2 from QuantityReportablePeriod: <"Effective date of the notional quantity of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "70" field "Effective date of the notional quantity of leg 2"
        provision "Unadjusted date on which the associated notional quantity of leg 2 becomes effective."]
    cde.quantity.NotionalQuantityScheduleEffectiveDate
        as "2.70/2.72-$ 2.70 Effective date of the notional quantity of leg 2"

reporting rule EndDateOfTheNotionalQuantityOfLeg2 from QuantityReportablePeriod: <"End date of the notional quantity of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "71" field "End date of the notional quantity of leg 2"
        provision "Unadjusted end date of the notional quantity of leg 2 (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    cde.quantity.NotionalQuantityScheduleEndDate
        as "2.70/2.72-$ 2.71 End date of the notional quantity of leg 2"

reporting rule NotionalQuantityInEffectOnAssociatedEffectiveDateOfLeg2 from QuantityReportablePeriod: <"Notional quantity in effect on associated effective date of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "72" field "Notional quantity in effect on associated effective date of leg 2"
        provision "Notional quantity of leg 2 which becomes effective on the associated unadjusted effective date."]
    cde.quantity.NotionalQuantityScheduleValue
        then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.70/2.72-$ 2.72 Notional quantity in effect on associated effective date of leg 2"

// Repeatable Field modelling
reporting rule OtherPayment from TransactionReportInstruction: <"Other Payment">
    filter IsAllowableAction or IsActionTypeTERM
    then extract transactionReportInstruction [
        TradeStateForEvent
            then extract transferHistory
            then filter IsOtherPayment
            then extract
                OtherPaymentReport {
                    paymentType: OtherPaymentType,
                    amount: OtherPaymentAmount,
                    currency: OtherPaymentCurrency,
                    date: OtherPaymentDate,
                    payer: ExtractOtherPaymentPayer(item, transactionReportInstruction),
                    payerFormat: OtherPaymentPayerFormat,
                    receiver: ExtractOtherPaymentReceiver(
                            item,
                            transactionReportInstruction
                        ),
                    receiverFormat: OtherPaymentReceiverFormat
                }
    ]

reporting rule OtherPaymentType from TransferState: <"Other Payment Type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "73" field "Other payment type"
        provision "Type of other payment amount. Option premium payment is not included as a payment type as premiums for option are reported using the option premium dedicated data element."]
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentType
        as "2.73/2.78-$ 2.73 Other Payment Type"

reporting rule OtherPaymentAmount from TransferState: <"Other Payment Amount">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "74" field "Other payment amount"
        provision "Payment amounts with corresponding payment types to accommodate requirements of transaction descriptions from different asset classes."]
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentAmount
        as "2.73/2.78-$ 2.74 Other Payment Amount"

reporting rule OtherPaymentCurrency from TransferState: <"Other Payment Currency">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "75" field "Other payment currency"
        provision "Currency in which other payment amount is denominated."]
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentCurrency
        as "2.73/2.78-$ 2.75 Other Payment Currency"

reporting rule OtherPaymentDate from TransferState: <"Other Payment Date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "76" field "Other payment date"
        provision "Unadjusted date on which the other payment amount is paid."]
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentDate
        as "2.73/2.78-$ 2.76 Other Payment Date"

reporting rule OtherPaymentPayer from TransferState: <"Other Payment Payer">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "77" field "Other payment payer"
        provision "Identifier of the payer of other payment amount."]
    empty // This rule is implemented within repeating rule OtherPayment.  This rule has been maintained so the regulatoryReference and "as" name can be specified.  DSL change request to allow easier modelling https://github.com/finos/rune-dsl/issues/852 
        as "2.73/2.78-$ 2.77 Other Payment Payer"

reporting rule OtherPaymentPayerFormat from TransferState: <"Other Payment Payer Format">
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentPayerFormat
        as "2.73/2.78-$ 2.77 Other Payment Payer Format (non-reportable)"

reporting rule OtherPaymentReceiver from TransferState: <"Other Payment Receiver">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "78" field "Other payment receiver"
        provision "Identifier of the receiver of other payment amount."]
    empty // This rule is implemented within repeating rule OtherPayment.  This rule has been maintained so the regulatoryReference and "as" name can be specified.  DSL change request to allow easier modelling https://github.com/finos/rune-dsl/issues/852 
        as "2.73/2.78-$ 2.78 Other Payment Receiver"

reporting rule OtherPaymentReceiverFormat from TransferState: <"Other Payment Receiver Format">
    filter IsOtherPayment
    then extract cde.payment.OtherPaymentReceiverFormat
        as "2.73/2.78-$ 2.78 Other Payment Receiver Format (non-reportable)"

// End of Repeatable Field modelling
reporting rule FixedRateOfLeg1OrCoupon from TransactionReportInstruction: <"Fixed rate of leg 1 or coupon">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "79" field "Fixed rate of leg 1 or coupon"
        provision "An indication of the fixed rate leg 1 or coupon used, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract cde.price.InterestRateFixedRate * 100
        as "2.79 Fixed Rate of leg 1 or coupon"

reporting rule FixedRateOrCouponDayCountConventionLeg1 from TransactionReportInstruction: <"Fixed rate or coupon day count convention leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" field "80" field "Fixed Rate Day Count Convention Leg 1"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
        as "2.80 Fixed rate or coupon day count convention leg 1"

// Remap to the CDE, currently endpoint "as" is probiting this
reporting rule FixedRateOrCouponPaymentFrequencyPeriodLeg1 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "81" field "Fixed rate or coupon payment frequency period leg 1"
        provision "Where applicable: time unit associated with the frequency of payments, e.g. day, week, month, year or term of the stream for the fixed rate of leg 1 or coupon."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.PaymentFrequencyPeriod
        as "2.81 Fixed rate or coupon payment frequency period leg 1"

reporting rule FixedRateOrCouponPaymentFrequencyPeriodMultiplierLeg1 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "82" field "Fixed rate or coupon payment frequency period multiplier leg 1"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur for the fixed rate of leg 1 or coupon. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract ProductForTrade
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.PaymentFrequencyPeriodMultiplier
        as "2.82 Fixed rate or coupon payment frequency period multiplier leg 1"

reporting rule IdentifierOfFloatingRateOfLeg1 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "83" field "EMIR 2.83 - Identifier of the floating rate of leg 1"
        provision "Where applicable: an identifier of the interest rates used which are reset at predetermined intervals by reference to a market reference rate."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption
    then extract item -> indexReferenceInformation -> indexId only-element
        as "2.83 - Identifier of the floating rate of leg 1"

reporting rule IndicatorOfTheFloatingRateOfLeg1 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "84" field "Indicator of the floating rate of leg 1"
        provision "An indication of the interest rate, where available."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract ProductForTrade
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption
    then extract item -> floatingRateIndex to-string
    then extract GetIndexIndicatorFromFloatingRate
        as "2.84 Indicator of the floating rate of leg 1"

reporting rule NameOfTheFloatingRateOfLeg1 from TransactionReportInstruction: <"Name of the Floating Rate of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "85" field "Name of the Floating Rate of Leg 1"
        provision "The full name of the interest rate as assigned by the index provider."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract GetNameOfTheFloatingRateOfLeg1
        as "2.85 Name of the Floating Rate of Leg 1"

//TODO: Update the samples to include Day Count Conventions on Floating legs
reporting rule FloatingRateDayCountConventionOfLeg1 from TransactionReportInstruction: <"Floating rate day count convention of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "86" field "Floating rate day count convention of leg 1"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments for the floating rate of leg 1 are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "2.86 Floating rate day count convention of leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodOfLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "87" field "Floating rate payment frequency period of leg 1"
        provision "Where applicable: time unit associated with the frequency of payments, e.g. day, week, month, year or term of the stream for the floating rate of leg 1."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.PaymentFrequencyPeriod
        as "2.87 Floating rate payment frequency period of leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierOfLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier of leg 1">
    [regulatoryReference FCA UKEMIR table "2" dataElement "88" field "Floating rate payment frequency period multiplier of leg 1"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur for the floating rate of leg 1. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.PaymentFrequencyPeriodMultiplier
        as "2.88 Floating rate payment frequency period multiplier of leg 1"

reporting rule FloatingRateReferencePeriodOfLeg1TimePeriod from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "89" field "Floating rate reference period of leg 1 - time period"
        provision "Time period describing the reference period for the floating rate of leg 1."]
    [regulatoryReference ISDA PeerReviewGroup date "20231115"
        provision "The codes ADHO and EXPI are not supported on the basis that pertinent business scenarios remain unclear for these values and it has not been possible to elect the relevant logic. Further enhancements will be addressed once clear guidance or examples come forth."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption -> indexTenor -> period
    then extract FloatingReferencePeriod
        as "2.89 Floating rate reference period of leg 1 - time period"

reporting rule FloatingRateReferencePeriodOfLeg1Multiplier from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "90" field "Floating rate reference period of leg 1 - multiplier"
        provision "Multiplier of the time period describing the reference period for the floating rate of leg 1."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption -> indexTenor -> periodMultiplier
        as "2.90 Floating rate reference period of leg 1 - multiplier"

reporting rule FloatingRateResetFrequencyPeriodOfLeg1 from TransactionReportInstruction: <"Floating rate reset frequency period of leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "91" field "Floating rate reset frequency period of leg 1"
        provision "Where applicable: time unit associated with the frequency of payments resets, e.g. day, week, month, year or term of the stream for the floating rate of leg 1."]
    [regulatoryReference ISDA PeerReviewGroup date "20230427" date "20230512"
        provision "This is not a CDE field, but common between CFTC and EMIR. This field should be populated for Interest Rate products only under EMIR."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "2.91 Floating rate reset frequency period of Leg 1"

reporting rule FloatingRateResetFrequencyMultiplierOfLeg1 from TransactionReportInstruction: <"Floating rate reset frequency multiplier of leg 1">
    [regulatoryReference FCA UKEMIR table "2" dataElement "92" field "Floating rate reset frequency multiplier of leg 1"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment resets dates occur for the floating rate of leg 1. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20230427" date "20230512"
        provision "This is not a CDE field, but common between CFTC and EMIR. This field should be populated for Interest Rate products only under EMIR."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract ProductForTrade
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract resetDates -> resetFrequency -> periodMultiplier
        as "2.92 Floating rate reset frequency multiplier of leg 1"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule SpreadOfLeg1Monetary from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "109" field "Spread of Leg 1"
        provision "An indication of the spread of leg 1, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s), difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract cde.price.SpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "2.93 Spread of Leg 1 (Monetary)"

reporting rule SpreadOfLeg1Percentage from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "109" field "Spread of Leg 1"
        provision "An indication of the spread of leg 1, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s), difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract cde.price.SpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Percentage
        then MultiplyPrice(value, GetPriceNotation)
        as "2.93 Spread of Leg 1 (Percentage)"

reporting rule SpreadOfLeg1Basis from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "109" field "Spread of Leg 1"
        provision "An indication of the spread of leg 1, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s), difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract
        if cde.price.SpreadLeg1 exists
        then (if GetPriceNotation(cde.price.SpreadLeg1) = PriceNotationEnum -> Basis
            then MultiplyPrice(
                        cde.price.SpreadLeg1 -> value,
                        GetPriceNotation(cde.price.SpreadLeg1)
                    ))
        else if GetNameOfTheFloatingRateOfLeg1 exists
        then 0
        as "2.93 Spread of Leg 1 (Basis)"

reporting rule SpreadOfLeg1Notation from TransactionReportInstruction: <"Spread of Leg 1 Notation">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "93" field "Spread of Leg 1"
        provision "An indication of the spread of leg 1, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s), difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract
        if cde.price.SpreadLeg1 exists
        then cde.price.SpreadLeg1NotationEnum
        else if GetNameOfTheFloatingRateOfLeg1 exists
        then PriceNotationEnum -> Basis
        as "2.93 Spread of Leg 1 Notation (Non Reportable)"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule SpreadCurrencyOfLeg1 from TransactionReportInstruction: <"Spread Currency of Leg 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "94" field "Spread Currency of Leg 1"
        provision "Where applicable: currency in which the spread of leg 1 is denominated. This data element is only applicable if spread is expressed as monetary amount."]
    filter IsAllowableAction
    then extract cde.price.SpreadLeg1Currency
    then extract ConvertNonISOToISOCurrency
        as "2.94 Spread Currency of Leg 1"

reporting rule FixedRateOfLeg2 from TransactionReportInstruction: <"Fixed rate of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "95" field "Fixed rate of leg 2"
        provision "An indication of the fixed rate leg 2 used, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract if IsFRA then InterestRateLeg1 else InterestRateLeg2
    then extract cde.price.InterestRateFixedRate * 100
        as "2.95 Fixed Rate of leg 2"

reporting rule FixedRateDayCountConventionLeg2 from TransactionReportInstruction: <"Fixed rate day count convention leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "96" field "Fixed rate day count convention leg 2"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract if IsFRA then InterestRateLeg1 else InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.DayCountConvention
            // To-Do: Day count fraction is missing in leg2 of the sample use-case "IRS Cross Currency Fixed Fixed" - Technically CDM Object validation should fail where fixed rate is provided
        as "2.96 Fixed rate day count convention leg 2"

// Remap to the CDE, currently endpoint "as" is probiting this
reporting rule FixedRatePaymentFrequencyPeriodLeg2 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "97" field "Fixed rate payment frequency period leg 2"
        provision "Where applicable: time unit associated with the frequency of payments, e.g. day, week, month, year or term of the stream for the fixed rate of leg 2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract if IsFRA then InterestRateLeg1 else InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.PaymentFrequencyPeriod
        as "2.97 Fixed rate payment frequency period leg 2"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierLeg2 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "98" field "Fixed rate payment frequency period multiplier of leg 2"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur for the fixed rate of leg 2. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract if IsFRA then InterestRateLeg1 else InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract cde.payment.PaymentFrequencyPeriodMultiplier
        as "2.98 Fixed rate payment frequency period multiplier of leg 2"

reporting rule IdentifierOfFloatingRateOfLeg2 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "99" field "EMIR 2.99 - Identifier of the floating rate of leg 2"
        provision "Where applicable: an identifier of the interest rates used which are reset at predetermined intervals by reference to a market reference rate."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption
    then extract item -> indexReferenceInformation -> indexId only-element
        as "2.99 - Identifier of the floating rate of leg 2"

reporting rule IndicatorOfTheFloatingRateOfLeg2 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "100" field "Indicator of the floating rate of leg 2"
        provision "An indication of the interest rate, where available."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption
    then extract item -> floatingRateIndex to-string
    then extract GetIndexIndicatorFromFloatingRate
        as "2.100 Indicator of the floating rate of leg 2"

reporting rule NameOfTheFloatingRateOfLeg2 from TransactionReportInstruction: <"Name of the Floating Rate of Leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "101" field "Name of the Floating Rate of Leg 2"
        provision "The full name of the interest rate as assigned by the index provider."]
    [docReference FCA UKEMIR Guidelines paragraph "416"
        provision "When reporting FRAs the counterparties should pay attention to the following: a. The underlying rate should be reported in the fields pertaining to the underlying section (fields 2.13-2.16)."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    // To be revisited when both index name and code are available in CDM
    filter IsAllowableAction
    then GetNameOfTheFloatingRateOfLeg2
        as "2.101 Name of the Floating Rate of Leg 2"

reporting rule FloatingRateDayCountConventionOfLeg2 from TransactionReportInstruction: <"Floating rate day count convention of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "102" field "Floating rate day count convention of leg 2"
        provision "Where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments for the floating rate of leg 2 are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.DayCountConvention
        as "2.102 Floating rate day count convention of leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodOfLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "103" field "Floating rate payment frequency period of leg 2"
        provision "Where applicable: time unit associated with the frequency of payments, e.g. day, week, month, year or term of the stream for the floating rate of leg 2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.PaymentFrequencyPeriod
        as "2.103 Floating rate payment frequency period of leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierOfLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier of leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "104" field "Floating rate payment frequency period multiplier of leg 2"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur for the floating rate of leg 2. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract cde.payment.PaymentFrequencyPeriodMultiplier
        as "2.104 Floating rate payment frequency period multiplier of leg 2"

reporting rule FloatingRateReferencePeriodOfLeg2TimePeriod from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "105" field "Floating rate reference period of leg 2 - time period"
        provision "Time period describing the reference period for the floating rate of leg 2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20231115"
        provision "The codes ADHO and EXPI are not supported on the basis that pertinent business scenarios remain unclear for these values and it has not been possible to elect the relevant logic. Further enhancements will be addressed once clear guidance or examples come forth."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption -> indexTenor -> period
    then extract FloatingReferencePeriod
        as "2.105 Floating rate reference period of leg 2 - time period"

reporting rule FloatingRateReferencePeriodOfLeg2Multiplier from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "106" field "Floating rate reference period of leg 2 - multiplier"
        provision "Multiplier of the time period describing the reference period for the floating rate of leg 2."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption -> indexTenor -> periodMultiplier
        as "2.106 Floating rate reference period of leg 2 - multiplier"

reporting rule FloatingRateResetFrequencyPeriodOfLeg2 from TransactionReportInstruction: <"Floating rate reset frequency period of leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "107" field "Floating rate reset frequency period of leg 2"
        provision "Where applicable: time unit associated with the frequency of payments resets, e.g. day, week, month, year or term of the stream for the floating rate of leg 2."]
    [regulatoryReference ISDA PeerReviewGroup date "20230427" date "20230512"
        provision "This is not a CDE field, but common between CFTC and EMIR. This field should be populated for Interest Rate products only under EMIR."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "2.107 Floating rate reset frequency period of Leg 2"

reporting rule FloatingRateResetFrequencyMultiplierOfLeg2 from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR table "2" dataElement "108" field "Floating rate reset frequency multiplier of leg 2"
        provision "Where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment resets dates occur for the floating rate of leg 2. For example, a transaction with payments occurring every two months is represented with a payment frequency period of 'MNTH' (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is 'ADHO'. If payment frequency period is 'EXPI', then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is 'DAIL' and the payment frequency multiplier is 0."]
    [regulatoryReference ISDA PeerReviewGroup date "20230427" date "20230512"
        provision "This is not a CDE field, but common between CFTC and EMIR. This field should be populated for Interest Rate products only under EMIR."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "2.108 Floating rate reset frequency multiplier of leg 2"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule SpreadOfLeg2Monetary from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "109" field "Spread of Leg 2"
        provision "An indication of the spread of leg 2, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), 
            - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). 
            - difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract cde.price.SpreadLeg2
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "2.109 Spread of Leg 2 (Monetary)"

reporting rule SpreadOfLeg2Percentage from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "109" field "Spread of Leg 2"
        provision "An indication of the spread of leg 2, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), 
            - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). 
            - difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract
        if cde.price.SpreadLeg2 exists
        then (if GetPriceNotation(cde.price.SpreadLeg2) = PriceNotationEnum -> Percentage
            then MultiplyPrice(
                        cde.price.SpreadLeg2 -> value,
                        GetPriceNotation(cde.price.SpreadLeg2)
                    ))
        else if GetNameOfTheFloatingRateOfLeg2 exists
        then 0
        as "2.109 Spread of Leg 2 (Percentage)"

reporting rule SpreadOfLeg2Basis from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "109" field "Spread of Leg 2"
        provision "An indication of the spread of leg 2, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), 
            - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). 
            - difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract
        if cde.price.SpreadLeg2 exists
        then (if GetPriceNotation(cde.price.SpreadLeg2) = PriceNotationEnum -> Basis
            then MultiplyPrice(
                        cde.price.SpreadLeg2 -> value,
                        GetPriceNotation(cde.price.SpreadLeg2)
                    ))
        else if GetNameOfTheFloatingRateOfLeg2 exists
        then 0
        as "2.109 Spread of Leg 2 (Basis)"

reporting rule SpreadOfLeg2Notation from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference FCA UKEMIR table "2" dataElement "109" field "Spread of Leg 2"
        provision "An indication of the spread of leg 2, where applicable: for OTC derivative transactions with periodic payments (e.g. interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), 
            - spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). 
            - difference between the reference prices of the two floating leg indexes."]
    filter IsAllowableAction
    then extract
        if cde.price.SpreadLeg2 exists
        then cde.price.SpreadLeg2NotationEnum
        else if GetNameOfTheFloatingRateOfLeg2 exists
        then PriceNotationEnum -> Basis
        as "2.109 Spread of Leg 2 Notation (Non Reportable)"

reporting rule SpreadCurrencyOfLeg2 from TransactionReportInstruction: <"Spread Currency of Leg 2">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "110" field "Spread Currency of Leg 2"
        provision "Where applicable: currency in which the spread of leg 2 is denominated. This data element is only applicable if spread is expressed as monetary amount."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsIRSwaption
        then cde.price.Spread_InterestRate(InterestRateLeg2(UnderlierForProduct))
        else if IsCommoditySwap
        then cde.price.Spread_Commodity(CommodityLeg2)
        else cde.price.Spread_InterestRate(InterestRateLeg2)
    then extract price
    then filter IsPriceMonetary
    then extract unit -> currency
        as "2.110 Spread Currency of Leg 2"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule PackageTransactionSpreadMonetary from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference FCA UKEMIR table "2" dataElement "111" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if:
                - no package is involved, or 
                - package transaction price is used 
            Spread and related data elements of the transactions (spread currency) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction or IsActionTypeEROR
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(
                    cde.price.PackageTransactionSpread,
                    PriceNotationEnum -> Monetary
                )
        as "2.111 Package transaction spread (Monetary)"

reporting rule PackageTransactionSpreadPercentage from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference FCA UKEMIR table "2" dataElement "111" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if:
                - no package is involved, or 
                - package transaction price is used 
            Spread and related data elements of the transactions (spread currency) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Percentage
        then MultiplyPrice(
                    cde.price.PackageTransactionSpread,
                    PriceNotationEnum -> Percentage
                )
        as "2.111 Package transaction spread (Percentage)"

reporting rule PackageTransactionSpreadBasis from TransactionReportInstruction: <"Package transaction spread">
    [regulatoryReference FCA UKEMIR table "2" dataElement "111" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if:
                - no package is involved, or 
                - package transaction price is used 
            Spread and related data elements of the transactions (spread currency) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction
    then extract
        if cde.price.PackageTransactionSpreadNotationEnum = PriceNotationEnum -> Basis
        then MultiplyPrice(cde.price.PackageTransactionSpread, PriceNotationEnum -> Basis)
        as "2.111 Package transaction spread (Basis)"

reporting rule PackageTransactionSpreadNotation from TransactionReportInstruction: <"Package transaction spread Notation">
    [regulatoryReference FCA UKEMIR table "2" dataElement "111" field "Package transaction spread"
        provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if:
                - no package is involved, or 
                - package transaction price is used 
            Spread and related data elements of the transactions (spread currency) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
    filter IsAllowableAction or IsActionTypeEROR
    then extract cde.price.PackageTransactionSpreadNotationEnum
        as "2.111 Package transaction spread Notation (Non Reportable)"

reporting rule PackageTransactionSpreadCurrency from TransactionReportInstruction:
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "112" field "Package transaction spread currency"
        provision "Currency in which the package transaction spread is denominated. This data element is not applicable if no package is involved, or package transaction price is used, or package transaction spread is expressed as percentage or basis points."]
    filter IsAllowableAction
    then extract cde.price.PackageTransactionSpreadCurrency
        as "2.112 Package transaction spread currency"

reporting rule ExchangeRate from ReportableEvent: <"Exchange Rate 1">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "113" field "Exchange rate 1"
        provision "Exchange rate between the two different currencies specified in the derivative transaction agreed by the counterparties at the inception of the transaction, expressed as the rate of exchange from converting the unit currency into the quoted currency."]
    [regulatoryReference ISDA PeerReviewGroup date "20230215"
        provision "FX Spots are not reportable for EMIR, only FX Forwards. So Exchange Rate will only be reported for the spot leg in the case of FX Swaps."]
    // TH review - tradeLot selection
    filter IsAllowableAction
    then extract
        if TradeForEvent exists
        then (extract TradeForEvent
        then filter
            Qualify_ForeignExchange_Swap(EconomicTermsForProduct(ProductForTrade))
                or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(ProductForTrade))
        then extract trade [
            tradableProduct -> tradeLot -> priceQuantity
                filter
                    quantity -> value any = FXNearLeg(ProductForTrade(trade)) -> underlier -> foreignExchange -> exchangedCurrency1 -> priceQuantity -> quantitySchedule -> value
                        and quantity -> value any = FXNearLeg(ProductForTrade(trade)) -> underlier -> foreignExchange -> exchangedCurrency2 -> priceQuantity -> quantitySchedule -> value
                then extract price
                then flatten
                then filter
                    priceType = PriceTypeEnum -> ExchangeRate
                        and arithmeticOperator is absent
                then only-element
                then extract value
        ])
        else if PositionForEvent exists
        then (extract PositionForEvent
        then filter
            Qualify_ForeignExchange_Swap(EconomicTermsForProduct(ProductForPosition))
                or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(ProductForPosition))
        then extract counterpartyPosition [
            positionBase -> tradeLot -> priceQuantity
                filter
                    quantity -> value any = FXNearLeg(
                                ProductForPosition(counterpartyPosition)
                            ) -> underlier -> foreignExchange -> exchangedCurrency1 -> priceQuantity -> quantitySchedule -> value
                        and quantity -> value any = FXNearLeg(
                                ProductForPosition(counterpartyPosition)
                            ) -> underlier -> foreignExchange -> exchangedCurrency2 -> priceQuantity -> quantitySchedule -> value
                then extract price
                then flatten
                then filter
                    priceType = PriceTypeEnum -> ExchangeRate
                        and arithmeticOperator is absent
                then only-element
                then extract value
        ])
        as "2.113 Exchange Rate 1"

reporting rule ForwardExchangeRate from TransactionReportInstruction: <"Forward Exchange Rate">
    [regulatoryReference FCA UKEMIR Trade table "2" field "114"
        provision "Forward exchange rate as agreed between the counterparties in the contractual agreement. It shall be expressed as a price of base currency in the quoted currency."]
    [regulatoryReference ISDA EMEADataAndReporting date "20230518"
        provision "EMIR Refit validation rules do indeed mean that for FX Options you must populate the Strike price (field 2.134) and one of either Exchange rate 1 (field 2.113) or Forward exchange rate (2.114). This is a duplication of data, but the validation rules force this. When this was discussed by the Data and Reporting EMEA WG, the proposal was to populate the Forward exchange rate field rather that Exchange rate 1 as the Strike is more like a forward rate (if exercised)."]
    // TH review - tradeLot selection
    filter IsAllowableAction
    then extract reportableEvent [
        [
            // FX Forwards, FX Options and FX Strategies
            filter
                Qualify_ForeignExchange_Spot_Forward(
                        ProductForTrade(TradeForEvent) -> contractualProduct -> economicTerms
                    )
                    or Qualify_ForeignExchange_NDF(
                            ProductForTrade(TradeForEvent) -> contractualProduct -> economicTerms
                        )
                    or IsFXOption(ProductForTrade(TradeForEvent))
            then extract cde.price.ExchangeRate(reportableEvent),
            // FX Swaps (Far leg)
            extract TradeForEvent(reportableEvent)
            then filter
                Qualify_ForeignExchange_Swap(
                        ProductForTrade -> contractualProduct -> economicTerms
                    )
                    or Qualify_ForeignExchange_NDS(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
            then extract trade [
                trade -> tradableProduct -> tradeLot -> priceQuantity
                    filter
                        quantity -> value any = FXFarLeg(ProductForTrade(trade)) -> underlier -> foreignExchange -> exchangedCurrency1 -> priceQuantity -> quantitySchedule -> value
                            and quantity -> value any = FXFarLeg(ProductForTrade(trade)) -> underlier -> foreignExchange -> exchangedCurrency2 -> priceQuantity -> quantitySchedule -> value
            ]
            then extract price
            then flatten
            then filter
                priceType = PriceTypeEnum -> ExchangeRate and arithmeticOperator is absent
        ]
            extract value
            then last
    ]
        as "2.114 Forward exchange rate"

reporting rule ExchangeRateBasis from TransactionReportInstruction: <"Exchange Rate Basis">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "115" field "Exchange Rate Basis"
        provision "Currency pair and order in which the exchange rate is denominated, expressed as unit currency or quoted currency."]
    filter IsAllowableAction
    then extract cde.price.ExchangeRate
    then extract cde.price.ExchangeRateBasis
        as "2.115 Exchange Rate Basis"

reporting rule BaseProduct from TransactionReportInstruction: <"Base Product">
    [regulatoryReference FCA UKEMIR table "2" dataElement "116" field "Base Product"
        provision "Base product as specified in the classification of commodities in Table 4 of the Annex of the EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract EconomicTermsForProduct
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then payout -> commodityPayout first -> underlier -> commodity
        else if Qualify_Commodity_Option
        then payout -> optionPayout only-element -> underlier -> commodity
        else if Qualify_Commodity_Swaption
        then EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout first -> underlier -> commodity
        else if payout -> forwardPayout -> underlier -> commodity exists
        then payout -> forwardPayout only-element -> underlier -> commodity
        else payout -> commodityPayout only-element -> underlier -> commodity
    then extract productTaxonomy
    then filter source = TaxonomySourceEnum -> EMIR
    then only-element
    then extract value -> classification
    then filter ordinal = 1
    then only-element
    then extract value
        as "2.116 Base Product"

reporting rule SubProduct from TransactionReportInstruction: <"Sub-product">
    [regulatoryReference FCA UKEMIR table "2" dataElement "117" field "Sub Product"
        provision "Sub-product as specified in the classification of commodities in Table 4 of the Annex of the EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023. This field requires a specific base product in field."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract EconomicTermsForProduct
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then payout -> commodityPayout first -> underlier -> commodity
        else if Qualify_Commodity_Option
        then payout -> optionPayout only-element -> underlier -> commodity
        else if Qualify_Commodity_Swaption
        then EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout first -> underlier -> commodity
        else if payout -> forwardPayout -> underlier -> commodity exists
        then payout -> forwardPayout only-element -> underlier -> commodity
        else payout -> commodityPayout only-element -> underlier -> commodity
    then extract productTaxonomy
    then filter source = TaxonomySourceEnum -> EMIR
    then only-element
    then extract value -> classification
    then filter ordinal = 2
    then only-element
    then extract value
        as "2.117 Sub Product"

reporting rule FurtherSubProduct from TransactionReportInstruction: <"Further sub-product">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "118" field "Further sub-product"
        provision "Further sub-product as specified in the classification of commodities in Table 4 of the Annex of the EMIR Technical Standards on the Standards, Formats, Frequency and Methods and Arrangements for Reporting 2023. This field requires a specific sub-product in field."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract EconomicTermsForProduct
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then payout -> commodityPayout first -> underlier -> commodity
        else if Qualify_Commodity_Option
        then payout -> optionPayout only-element -> underlier -> commodity
        else if Qualify_Commodity_Swaption
        then EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout first -> underlier -> commodity
        else if payout -> forwardPayout -> underlier -> commodity exists
        then payout -> forwardPayout only-element -> underlier -> commodity
    then extract productTaxonomy
    then filter source = TaxonomySourceEnum -> EMIR
    then only-element
    then extract value -> classification
    then filter ordinal = 3
    then only-element
    then extract value
        as "2.118 Further sub-product"

reporting rule DeliveryPointOrZone from TransactionReportInstruction: <"Delivery point or zone">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "119" field "Delivery point or zone"
        provision "Delivery point(s) or market area(s)."]
    [regulatoryReference ISDA PeerReviewGroup date "20231020"
        provision "Not fully modelled. Need to add a delivery section in OptionPayout/ForwardPayout similar to the one in CommodityPayout"]
    extract ProductForEvent
    then extract EconomicTermsForProduct
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Swaption
        then EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Option
        then payout -> optionPayout -> delivery only-element
        else if item -> payout -> forwardPayout -> underlier -> commodity exists
        then payout -> forwardPayout -> delivery only-element
    then extract location
    then filter locationIdentifierType = CommodityLocationIdentifierTypeEnum -> DeliveryPoint
    then extract assignedIdentifier -> identifier
    then flatten
        as "2.119 Delivery point or zone"

reporting rule InterconnectionPoint from TransactionReportInstruction: <"Interconnection Point">
    [regulatoryReference FCA UKEMIR table "2" dataElement "120" field "Interconnection Point"
        provision "Identification of the border(s) or border point(s) of a transportation contract."]
    [regulatoryReference ISDA PeerReviewGroup date "20231020"
        provision "Not fully modelled. Need to add a delivery section in OptionPayout/ForwardPayout similar to the one in CommodityPayout"]
    extract TradeForEvent
    then extract ProductForTrade
    then extract EconomicTermsForProduct
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Swaption
        then EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Option
        then payout -> optionPayout -> delivery only-element
        else if item -> payout -> forwardPayout -> underlier -> commodity exists
        then payout -> forwardPayout -> delivery only-element
        else payout -> commodityPayout only-element -> delivery
    then extract location
    then filter
        locationIdentifierType = CommodityLocationIdentifierTypeEnum -> InterconnectionPoint
    then only-element // There should be only one Location
    then extract assignedIdentifier -> identifier
    then only-element // There should be only one assigned Identifier
//    then flatten
        as "2.120 Interconnection Point"

reporting rule LoadType from TransactionReportInstruction: <"Load type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "121" field "Load type"
        provision "Identification of the delivery profile."]
    [regulatoryReference ISDA PeerReviewGroup date "20231020"
        provision "Not fully modelled. Need to add a delivery section in OptionPayout/ForwardPayout similar to the one in CommodityPayout"]
    [regulatoryReference ISDA PeerReviewGroup date "20231114"
        provision "Modelled to accept only one type of delivery. If a transaction has two
         delivery profiles with different load types, those will not get reported."]
    extract EconomicTermsForProduct(ProductForEvent)
    then extract
        if Qualify_Commodity_Swap_FixedFloat or Qualify_Commodity_Swap_Basis
        then (payout -> commodityPayout
            first
            then extract
                if delivery -> periods -> profile exists
                then delivery -> periods -> profile
                else if schedule -> schedulePeriod -> deliveryPeriod -> profile exists
                then schedule -> schedulePeriod -> deliveryPeriod -> profile)
        else if Qualify_Commodity_Swaption
        then (EconomicTermsForProduct(payout -> optionPayout -> underlier only-element) -> payout -> commodityPayout
            first
            then extract
                if delivery -> periods -> profile exists
                then delivery -> periods -> profile
                else if schedule -> schedulePeriod -> deliveryPeriod -> profile exists
                then schedule -> schedulePeriod -> deliveryPeriod -> profile)
        else if Qualify_Commodity_Option
        then (payout -> optionPayout
            only-element
            then extract
                if delivery -> periods -> profile exists
                then delivery -> periods -> profile
                else if schedule -> schedulePeriod -> deliveryPeriod -> profile exists
                then schedule -> schedulePeriod -> deliveryPeriod -> profile)
        else if item -> payout -> forwardPayout -> underlier -> commodity exists
        then (payout -> forwardPayout
            only-element
            then extract
                if delivery -> periods -> profile exists
                then delivery -> periods -> profile
                else if schedule -> schedulePeriod -> deliveryPeriod -> profile exists
                then schedule -> schedulePeriod -> deliveryPeriod -> profile)
    then extract GetLoadType
    then distinct only-element to-string to-enum EnergyLoadType1Code
        as "2.121 Load type"

// Repeatable Field modelling
reporting rule Delivery from TransactionReportInstruction: <"Commodity Delivery">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "122-131" field "Delivery"
        provision "Section of fields 122-131 is repeatable"]
    extract GetReportableDelivery
    then extract
        DeliveryReport {
            deliveryStartTime: DeliveryIntervalStartTime,
            deliveryEndTime: DeliveryIntervalEndTime,
            deliveryStartDate: DeliveryStartDate,
            deliveryEndDate: DeliveryEndDate,
            duration: Duration,
            daysOfTheWeek: DaysOfTheWeek,
            deliveryCapacity: DeliveryCapacity,
            quantityUnit: QuantityUnit,
            priceTimeIntervalQuantity: PriceTimeIntervalQuantity,
            currencyOfThePriceTimeIntervalQuantity: CurrencyOfThePriceTimeIntervalQuantity
        }

reporting rule DeliveryIntervalStartTime from ReportableDelivery: <"Delivery interval start time">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "122" field "Delivery interval start time"
        provision "The start time of the delivery interval for each block or shape."]
    extract deliveryStartTime
        as "2.122/2.131-$ 2.122 Delivery interval start time"

reporting rule DeliveryIntervalEndTime from ReportableDelivery: <"Delivery interval end time">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "123" field "Delivery interval end time"
        provision "The end time of the delivery interval for each block or shape."]
    extract deliveryEndTime
        as "2.122/2.131-$ 2.123 Delivery interval end time"

reporting rule DeliveryStartDate from ReportableDelivery: <"Delivery start date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "124" field "Delivery start date"
        provision "Start date of delivery."]
    extract deliveryStartDate
        as "2.122/2.131-$ 2.124 Delivery start date"

reporting rule DeliveryEndDate from ReportableDelivery: <"Delivery end date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "125" field "Delivery end date"
        provision "End date of delivery."]
    extract deliveryEndDate
        as "2.122/2.131-$ 2.125 Delivery end date"

reporting rule Duration from ReportableDelivery: <"Duration">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "126" field "Duration"
        provision "The duration of the delivery period."]
    extract duration to-string to-enum DurationType1Code
        as "2.122/2.131-$ 2.126 Duration"

reporting rule DaysOfTheWeek from ReportableDelivery: <"Days of the week">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "127" field "Days of the week"
        provision "The days of the week of the delivery."]
    [regulatoryReference ISDA EMEADataAndReporting date "20231107"
        provision "Need to clarify the exact meaning of XBHL and IBHL to ensure they are not reported the other way around"]
    extract daysOfTheWeek
        as "2.122/2.131-$ 2.127 Days of the week"

reporting rule DeliveryCapacity from ReportableDelivery: <"Delivery capacity">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "128" field "Delivery capacity"
        provision "The number of units included in the transaction for each delivery interval specified in fields 2.122 and 2.123."]
    [regulatoryReference ISDA PeerReviewGroup date "20231114"
        provision "Not fully modelled. Need to add a function that calculates how many applicable days there is in an specific period for when the specified frequency is not daily."]
    extract deliveryCapacity
        as "2.122/2.131-$ 2.128 Delivery capacity"

reporting rule QuantityUnit from ReportableDelivery: <"Quantity unit">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "129" field "Quantity unit"
        provision "The unit of measurement used."]
    [regulatoryReference ISDA PeerReviewGroup date "20231114"
        provision "Not fully modelled. Need to add a function that calculates how many applicable days there is in an specific period for when the specified frequency is not daily."]
    extract quantityUnit to-string to-enum EnergyQuantityUnit2Code
        as "2.122/2.131-$ 2.129 Quantity unit"

reporting rule PriceTimeIntervalQuantity from ReportableDelivery: <"Price/time interval quantity">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "130" field "Price time interval quantity"
        provision "If applicable, price per quantity per delivery time interval."]
    extract priceTimeIntervalQuantity
        as "2.122/2.131-$ 2.130 Price time interval quantity"

reporting rule CurrencyOfThePriceTimeIntervalQuantity from ReportableDelivery: <"Currency of the price/time interval quantity">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "131" field "Currency of the price time interval quantity"
        provision "The currency in which the price per time interval quantity is expressed."]
    extract currencyOfThePriceTimeIntervalQuantity
    then extract ConvertNonISOToISOCurrency
        as "2.122/2.131-$ 2.131 Currency of the price time interval quantity"

// End of Repeatable Field modelling
reporting rule OptionType from TransactionReportInstruction: <"Option Type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "132" field "Option type"
        provision "Indication as to whether the derivative contract is a call (right to purchase a specific underlying asset) or a put (right to sell a specific underlying asset) or whether it cannot be determined whether it is a call or a put at the time of execution of the derivative contract. In case of swaptions it shall be: 
                - 'Put', in case of receiver swaption, in which the buyer has the right to enter into a swap as a fixed-rate receiver, 
                - 'Call', in case of payer swaption, in which the buyer has the right to enter into a swap as a fixed-rate payer. 
            In case of Caps and Floors it shall be: 
                - 'Put', in case of a Floor, 
                - 'Call', in case of a Cap."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract cde.link.UPIOptionType
        as "2.132 Option type"

reporting rule OptionStyle from TransactionReportInstruction: <"Option Style">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "133" field "Option Style"
        provision "Indicates whether the option may be exercised only at a fixed date (European), a series of pre-specified dates (Bermudan) or at any time during the life of the contract (American)."]
    [regulatoryReference ISDA EMIRReportingBestPractice table "2" field "79"
        provision "For Caps and Floors, populated with E(European). Reasoning for CapFloors to be reported as E is that such products would report field 2.1  (Contract Type) as OP and therefore it is required to populate the Option exercise style. While a CapFloor would not have an exercise style, there is no option to report Other. Therefore, best practice is be to report as European E."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsFloor or IsCap
        then "EURO"
        else if IsOption
        then (EconomicTermsForProduct -> payout -> optionPayout only-element -> exerciseTerms -> optionStyle
            extract
                if americanExercise exists
                then "AMER"
                else if europeanExercise exists
                then "EURO"
                else if bermudaExercise exists
                then "BERM")
        as "2.133 Option Style"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule StrikePriceMonetary from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "134" field "Strike price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426. Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
    filter IsAllowableAction
    then extract
        if cde.price.StrikePriceNotationEnum = PriceNotationEnum -> Monetary
        then MultiplyPrice(cde.price.StrikePrice, cde.price.StrikePriceNotationEnum)
        as "2.134 Strike Price (Monetary)"

reporting rule StrikePricePercentage from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "134" field "Strike price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426. Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
    filter IsAllowableAction
    then extract
        if cde.price.StrikePriceNotationEnum = PriceNotationEnum -> Percentage
        then MultiplyPrice(cde.price.StrikePrice, cde.price.StrikePriceNotationEnum)
        as "2.134 Strike Price (Percentage)"

reporting rule StrikePriceNotation from TransactionReportInstruction: <"Strike Price Notation">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "134" field "Strike price"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426. Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available. For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
    filter IsAllowableAction
    then extract cde.price.StrikePriceNotationEnum
        as "2.134 Strike Price Notation (Non Reportable)"

/* ---------------------------------------------------------------------------------------------------------------- */
//Repeatable fields modelling
reporting rule StrikePriceSchedule from TransactionReportInstruction: <"Strike Price Schedule">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "135-137" field "Strike Price Schedule"
        provision "Fields 135-137 are repeatable and reportable for options, swaptions and similar products with strike prices varying throughout the life of the
            transaction. Strike price schedule is only applicable if the strike price varies per schedule.
            The currency for the varying strike prices in the schedule is reported in Strike price currency data element."]
    filter IsAllowableAction
    then extract UKEMIRReportableStrikePricePeriod
    then extract
        StrikePriceScheduleReport {
            effectiveDateStrikePrice: EffectiveDateOfTheStrikePrice,
            endDateStrikePrice: EndDateOfTheStrikePrice,
            strikePriceInEffectOnAssociatedEffectiveDateMonetary: StrikePriceInEffectOnAssociatedEffectiveDateMonetary,
            strikePriceInEffectOnAssociatedEffectiveDatePercentage: StrikePriceInEffectOnAssociatedEffectiveDatePercentage,
            strikePriceNotationInEffectOnAssociatedEffectiveDate: empty
        }

func UKEMIRReportableStrikePricePeriod:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        emirReportableStrikePricePeriods PriceReportablePeriod (0..*)
    alias expirationDate: GetExpirationDate(transactionReportInstruction)
    alias genericReportableStrikePriceSchedule:
        GetReportableStrikePricePeriod(transactionReportInstruction)
    set emirReportableStrikePricePeriods:
        Create_ContinuousPriceSchedule(genericReportableStrikePriceSchedule, expirationDate)

reporting rule EffectiveDateOfTheStrikePrice from PriceReportablePeriod: <"Effective date of the strike price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "135" field "Effective date of the strike price"
        provision "Unadjusted effective date of the strike price."]
    cde.price.StrikePriceScheduleEffectiveDate
        as "2.135/2.137-$ 2.135 Effective date of the strike price"

reporting rule EndDateOfTheStrikePrice from PriceReportablePeriod: <"End date of the strike price">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "136" field "End date of the strike price"
        provision "Unadjusted end date of the strike price (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
    cde.price.StrikePriceScheduleEndDate
        as "2.135/2.137-$ 2.136 End date of the strike price"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDateMonetary from PriceReportablePeriod: <"Strike price in effect on associated effective date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "137" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    cde.price.StrikePriceScheduleAmountFormatMonetary
        as "2.135/2.137-$ 2.137 Strike price in effect on associated effective date (Monetary)"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDatePercentage from PriceReportablePeriod: <"Strike price in effect on associated effective date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "137" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    cde.price.StrikePriceScheduleAmountFormatPercentage
        as "2.135/2.137-$ 2.137 Strike price in effect on associated effective date (Percentage)"

reporting rule StrikePriceNotationInEffectOnAssociatedEffectiveDate from PriceReportablePeriod: <"Strike price notation in effect on associated effective date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "137" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive."]
    extract periodValue -> priceNotation
        as "2.135/2.137-$ 2.137 Strike price notation in effect on associated effective date (Non Reportable)"

//End of repeatable fields
reporting rule StrikePriceCurrencyCurrencyPair from TransactionReportInstruction: <"Strike Price Currency/currency pair">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "138" field "Strike price currency/currency pair"
        provision "For equity options, commodity options, and similar products, currency in which the strike price is denominated.For foreign exchange options: Currency pair and order in which the strike price is expressed. It is expressed as unit currency per quoted currency."]
    filter IsAllowableAction
    then cde.price.StrikePriceCurrency
        as "2.138 Strike price currency/currency pair"

reporting rule OptionPremiumAmount from TransactionReportInstruction: <"Option Premium Amount">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "139" field "Option premium amount"
        provision "For options and swaptions of all asset classes, monetary amount paid by the option buyer. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    filter IsAllowableAction
    then if cde.price.OptionPremiumAmount exists
        then cde.price.OptionPremiumAmount
        else if IsCapFloor(ProductForEvent)
        then 9999999999999999999999999
    then extract RoundToPrecision(item, 5, RoundingDirectionEnum -> Nearest)
        as "2.139 Option Premium Amount"

reporting rule OptionPremiumCurrency from TransactionReportInstruction: <"Option Premium Currency">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "140" field "Option premium currency"
        provision "For options and swaptions of all asset classes, currency in which the option premium amount is denominated. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
    filter IsAllowableAction
    then if cde.price.OptionPremiumCurrency exists
        then cde.price.OptionPremiumCurrency
        else if IsCapFloor(ProductForEvent)
        then NotionalCurrency1
        as "2.140 Option Premium Currency"

reporting rule OptionPremiumPaymentDate from TransactionReportInstruction: <"Option Premium Payment Date">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "141" field "Option premium payment date"
        provision "Unadjusted date on which the option premium is paid."]
    if cde.price.OptionPremiumPaymentDate exists
    then cde.price.OptionPremiumPaymentDate
    else if IsCapFloor(ProductForEvent)
    then EffectiveDate
        as "2.141 Option Premium Payment Date"

reporting rule MaturityDateOfTheUnderlying from TransactionReportInstruction: <"Maturity date of the underlying">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "142" field "Maturity date of the underlying"
        provision "In case of swaptions, maturity date of the underlying swap."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsIRSwaption or IsCreditSwaption or IsCommoditySwaption
        then cde.datetime.ExpirationDate(UnderlierForProduct)
        as "2.142 Maturity date of the underlying"

reporting rule Seniority from TransactionReportInstruction: <"Seniority">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "143" field "Seniority"
        provision "Indicates the seniority of the debt security, or debt basket or index underlying a derivative."]
    filter IsAllowableAction
    then extract GetSeniority
        as "2.143 Seniority"

reporting rule ReferenceEntity from TransactionReportInstruction: <"Reference Entity">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "144" field "Reference Entity"
        provision "Identification of the underlying reference entity."]
    filter IsAllowableAction
    then extract
        if UnderlyingIdentificationType is absent // UKEMIR_VR_2013_02
        then ExtractReferenceEntity
        as "2.144 Reference Entity"

reporting rule Series from TransactionReportInstruction: <"Series">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "145" field "Series"
        provision "The series number of the composition of the index if applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexSeries
        as "2.145 Series"

reporting rule Version from TransactionReportInstruction: <"Version">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "146" field "Version"
        provision "A new version of a series is issued if one of the constituents defaults and the index has to be re-weighted to account for the new number of total constituents within the index."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexAnnexVersion
        as "2.146 Version"

reporting rule IndexFactor from TransactionReportInstruction: <"Index Factor">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "147" field "Index Factor"
        provision "The factor to apply to the Notional amount of Leg 1 (Field 2.55 in this Table) to adjust it to all the previous credit events in that Index series."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout
    then extract generalTerms -> indexReferenceInformation -> indexFactor
        as "2.147 Index factor"

reporting rule Tranche from TransactionReportInstruction: <"Tranche">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "148" field "Tranche"
        provision "Indication whether a derivative contract is tranched."]
    [regulatoryReference ISDA PeerReviewGroup date "20230329"
        provision "The tranche only applies to the transaction that is being reported, not the underlyer of the contract. In the case of a credit default swap option, the underlying CDS doesn't exist  yet in the execution of the option trade so the tranche of the underlying CDS should not be reported. In addition, we don't expect that the underlying CDS would be a tranched transaction. It will be a simple swap."]
    filter IsAllowableAction
    then extract ProductForTrade(TradeForEvent)
    then extract
        if IsCreditSwaption
        then UnderlierForProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
        else if IsCreditDefaultSwap
        then contractualProduct -> economicTerms -> payout -> creditDefaultPayout
    then extract
        if generalTerms -> indexReferenceInformation -> tranche exists
        then True
        else if generalTerms -> basketReferenceInformation -> tranche exists
        then True
        else False
        as "2.148 Tranche"

reporting rule CDSIndexAttachmentPoint from TransactionReportInstruction: <"CDS Index Attachment Point">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "149" field "CDS Index Attachment Point"
        provision "Defined lower point at which the level of losses in the underlying portfolio reduces the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% will be reduced after 3% of losses in the portfolio have occurred. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    filter IsAllowableAction
    then cde.index.CDSIndexAttachmentPoint
        as "2.149 CDS Index Attachment Point"

reporting rule CDSIndexDetachmentPoint from TransactionReportInstruction: <"CDS index detachment point">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "150" field "CDS Index Detachment Point"
        provision "Defined point beyond which losses in the underlying portfolio no longer reduce the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% and a detachment point of 6% will be reduced after there have been 3% of losses in the portfolio. 6% losses in the portfolio deplete the notional of the tranche. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
    filter IsAllowableAction
    then cde.index.CDSIndexDetachmentPoint
        as "2.150 CDS Index Detachment Point"

reporting rule ActionType from TransactionReportInstruction: <"Action type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "151" field "Action type"
        provision "- New: A report of a derivative, at a trade or position level, for the first time. 
            - Modify: A modification to the terms or details of a previously reported derivative, at a trade or position level, but not a correction of a report. 
            - Correction: A report correcting the erroneous data fields of a previously submitted report. 
            - Terminate: A Termination of an existing derivative, at a trade or position level. 
            - Error: A cancellation of a wrongly submitted entire report in case the derivative, at a trade or position level, never came into existence or was not subject to Regulation (EU) No 648/2012 reporting requirements but was reported to a trade repository by mistake or a cancellation of a duplicate report. 
            - Revive: Re-opening of a derivative, at a trade or position level, that was cancelled with action type Error or terminated by mistake. 
            - Valuation: An update of a valuation of a derivative, at a trade or position level.
            - Position component: A report of a new derivative that is included in a separate position report on the same day."]
    [docReference FCA UKEMIR Guidelines paragraph "132"
        provision "The categories of derivatives eligible for reporting at position level are: ETDs, centrally cleared OTC derivatives netted by CCPs and Contracts For Difference (CFDs). Although in the case of such derivatives the information concerning positions is most relevant for the assessment of systemic risk, reporting only at position level is not in line with EMIR requirements under Article 9 of EMIR, which requires all counterparties to report e.g. conclusion of a derivative at transaction level."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "2023"
        provision "ETDs transactions are reported with POSC as action type and with a subsequent position UTI according to ESMA EMIR RTS Guidelines paragraph 132. The subsequent position UTI is reported as UTI at position level."]
    /*
     * "4 alphabetic characters:
     * NEWT = New
     * MODI = Modify
     * CORR = Correct
     * TERM = Terminate
     * EROR = Error
     * POSC = Position component
     * To-Do action type values:
     *     REVI = Revive
     *     VAL U = Valuation
     */
    extract cde.event.ActionType
        as "2.151 Action type"

reporting rule EventType from TransactionReportInstruction: <"Event Type">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "152" field "Event Type"
        provision "- Trade: Conclusion of a derivative or renegotiation of its terms that does not result in change of a counterparty.
            - Step-in: An event, where part or entirety of the derivative is transferred to a counterparty 2 (and reported as a new derivative) and the existing derivative is either terminated or its notional is modified.
            - PTRR: Post-trade risk reduction exercise.
            - Early termination: Termination of a derivative, at a trade or position level.
            - Clearing: Clearing as defined in Article 2(3) of Regulation (EU) No 648/2012.
            - Exercise: The exercise of an option or a swaption by one counterparty of the transaction, fully or partially. 
            - Allocation: Allocation event, where an existing derivative is allocated to different counterparties and reported as new derivatives with reduced notional amounts. 
            - Credit event: Applies only to credit derivatives. A credit event that results in a modification of a derivative, at a trade or position level.
            - Corporate event: A corporate action on equity underlying that impacts the derivatives on that equity.
            - Inclusion in position: Inclusion of CCP-cleared derivative or CFD into a position, where an existing derivative is terminated and either a new position is created or the notional of an existing position is modified.  
            - Update: Update of an outstanding derivative performed during the transition period in order to ensure its conformity with the amended reporting requirements."]
    /**
     *         4 alphabetic characters:
     * TRAD = Trade
     * NOVA = Step-in
     * COMP = PTRR
     * ETRM = Early termination
     * CLRG = Clearing
     * EXER = Exercise
     * ALOC = Allocation
     * CREV = Credit event
     * CORP = Corporate event
     * INCP = Inclusion in position (ETD)
     * UPDT = Update
     *         To-Do event type values:
     *             INCP = Inclusion in position (OTC)
     **/
    filter
        (IsActionTypeNEWT or IsActionTypeMODI or IsActionTypePositionMODI or IsActionTypeTERM)
    then extract reportableEvent [
        if (IsActionTypeCORR = False
                and IsActionTypeEROR = False
                and IsActionTypeREVI = False
                and IsActionTypePOSC = False
                and IsActionTypeVALU = False)
        then originatingWorkflowStep
            extract workflowStep [
                if workflowStep -> businessEvent exists
                then workflowStep -> businessEvent
                    extract
                        (if IsEventTypeUPDT(reportableEvent)
                        then EventTypeEnum -> UPDT to-string
                        else if Qualify_Novation
                                or Qualify_PartialNovation
                                or intent = EventIntentEnum -> Novation
                        then EventTypeEnum -> NOVA to-string
                        else if Qualify_Allocation
                                or Qualify_Reallocation
                                or intent = EventIntentEnum -> Allocation
                        then EventTypeEnum -> ALOC to-string
                        else if Qualify_Exercise or intent = EventIntentEnum -> OptionExercise
                        then EventTypeEnum -> EXER to-string
                        else if Qualify_ClearedTrade
                                or reportableEvent -> originatingWorkflowStep -> workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
                                or intent = EventIntentEnum -> Clearing
                        then EventTypeEnum -> CLRG to-string
                        else if Qualify_Compression or intent = EventIntentEnum -> Compression
                        then EventTypeEnum -> COMP to-string
                        else if Qualify_Termination or intent = EventIntentEnum -> EarlyTerminationProvision or Qualify_PartialTermination
                        then EventTypeEnum -> ETRM to-string
                        else if Qualify_CreditEventDetermined or intent = EventIntentEnum -> CreditEvent
                        then EventTypeEnum -> CREV to-string
                        else if Qualify_CorporateActionDetermined or intent = EventIntentEnum -> CorporateActionAdjustment
                        then EventTypeEnum -> CORP to-string
                        else if Qualify_ContractFormation
                                or Qualify_Increase
                                or Qualify_Renegotiation
                                or Qualify_IndexTransition
                                or Qualify_FullReturn
                                or instruction -> primitiveInstruction -> quantityChange exists
                                or instruction -> primitiveInstruction -> transfer exists
                                or intent = EventIntentEnum -> ContractTermsAmendment
                        then EventTypeEnum -> TRAD to-string
                        else "ToDo")
                else if workflowStep -> counterpartyPositionBusinessEvent exists
                then if workflowStep -> counterpartyPositionBusinessEvent -> intent = PositionEventIntentEnum -> OptionExercise
                    then EventTypeEnum -> EXER to-string
                    else if workflowStep -> counterpartyPositionBusinessEvent -> intent = PositionEventIntentEnum -> Transfer
                    then EventTypeEnum -> NOVA to-string
                    else if workflowStep -> counterpartyPositionBusinessEvent -> intent = PositionEventIntentEnum -> CorporateActionAdjustment
                    then EventTypeEnum -> CORP to-string
                    else EventTypeEnum -> INCP to-string
            ]
    ]
        as "2.152 Event Type"

reporting rule EventDate from TransactionReportInstruction: <"Event Date">
    [regulatoryReference FCA UKEMIR table "2" dataElement "153" field "Event date"
        provision "Date on which the reportable event relating to the derivative contract and captured by the report took place or, in case of a modification when the modification become effective."]
    extract
        if originatingWorkflowStep -> businessEvent exists
        then originatingWorkflowStep -> businessEvent -> eventDate
        else originatingWorkflowStep -> counterpartyPositionBusinessEvent -> eventDate
        as "2.153 Event Date"

reporting rule Level from ReportableEvent: <"Level">
    [regulatoryReference FCA UKEMIR Trade table "2" dataElement "154" field "Level"
        provision "Indication whether the report is done at trade or position level. Position level report can be used only as a supplement to trade level reporting to report post- trade events and only if individual trades in fungible products have been replaced by the position."]
    extract cde.event.Level
        as "2.154 Level"

func UKEMIRIsMicXOFF:
    inputs:
        reportableEvent ReportableEvent (0..1)
    output:
        isMicXOFF boolean (1..1)
    set isMicXOFF:
        reportableEvent -> reportableInformation -> enrichment -> micData is absent
            and GetVenueOfExecution(reportableEvent -> reportableInformation) is absent
            and reportableEvent -> reportableInformation -> transactionInformation -> fcaTransactionInformation only-element -> tradableOnTradingVenue = TradableOnTradingVenueEnum -> Admitted

func UKEMIRIsMicXXXX:
    inputs:
        reportableEvent ReportableEvent (0..1)
    output:
        isMicXXXX boolean (1..1)
    set isMicXXXX:
        reportableEvent -> reportableInformation -> enrichment -> micData is absent
            and GetVenueOfExecution(reportableEvent -> reportableInformation) is absent
            and reportableEvent -> reportableInformation -> transactionInformation -> fcaTransactionInformation only-element -> tradableOnTradingVenue = TradableOnTradingVenueEnum -> NotAdmitted
